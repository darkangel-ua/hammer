/** \file
 *  This C source file was generated by $ANTLR version 3.1.1
 *
 *     -  From the grammar source file : hammer_sema_v2.gt
 *     -                            On : 2018-12-08 18:07:32
 *     -           for the tree parser : hammer_sema_v2TreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/

/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */


#include <hammer/sema/actions.h>
#include <hammer/parscore/identifier.h>
#include <hammer/ast/requirement_set.h>
#include <hammer/ast/path.h>
#include <hammer/ast/feature.h>
#include <hammer/ast/condition.h>

#define SEMA static_cast<hammer::sema::actions*>(PARSER->super)
#define DECLARE_TYPE(Type, name) Type name ( Type ::allocator_type{SEMA->get_context()});

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "hammer_sema_v2.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   phammer_sema_v2_##scope##_SCOPE
#define SCOPE_STACK(scope)  phammer_sema_v2_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->phammer_sema_v2_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   hammer_sema_v2TokenNames[50+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "Hamfile",
        (pANTLR3_UINT8) "Rule",
        (pANTLR3_UINT8) "Local",
        (pANTLR3_UINT8) "Explicit",
        (pANTLR3_UINT8) "Arguments",
        (pANTLR3_UINT8) "EmptyArgument",
        (pANTLR3_UINT8) "NamedArgument",
        (pANTLR3_UINT8) "Structure",
        (pANTLR3_UINT8) "EmptyField",
        (pANTLR3_UINT8) "NamedField",
        (pANTLR3_UINT8) "List",
        (pANTLR3_UINT8) "Feature",
        (pANTLR3_UINT8) "Condition",
        (pANTLR3_UINT8) "RuleInvocation",
        (pANTLR3_UINT8) "Path",
        (pANTLR3_UINT8) "PathRootName",
        (pANTLR3_UINT8) "PathTrailingSlash",
        (pANTLR3_UINT8) "TargetRef",
        (pANTLR3_UINT8) "TargetRefSpec",
        (pANTLR3_UINT8) "TargetRefBuildRequest",
        (pANTLR3_UINT8) "Wildcard",
        (pANTLR3_UINT8) "LogicalAnd",
        (pANTLR3_UINT8) "LogicalOr",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "Id",
        (pANTLR3_UINT8) "PublicTag",
        (pANTLR3_UINT8) "Slash",
        (pANTLR3_UINT8) "PathUri",
        (pANTLR3_UINT8) "DoubleSlash",
        (pANTLR3_UINT8) "QuestionMark",
        (pANTLR3_UINT8) "Asterix",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "STRING_1",
        (pANTLR3_UINT8) "STRING_ID",
        (pANTLR3_UINT8) "STRING_ID1",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'->'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'&&'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static const hammer::ast::hamfile*	hamfile    (phammer_sema_v2 ctx);
static void	statement    (phammer_sema_v2 ctx, hammer::ast::statements_t* statements);
static const hammer::ast::statement*	top_level_rule_invocation    (phammer_sema_v2 ctx);
static void	target_def_prefix    (phammer_sema_v2 ctx, hammer::parscore::source_location* explicit_tag, hammer::parscore::source_location* local_tag);
static void	arguments    (phammer_sema_v2 ctx, hammer::ast::expressions_t* args);
static const hammer::ast::expression*	argument    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	named_argument    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	expression    (phammer_sema_v2 ctx);
static void	list_of    (phammer_sema_v2 ctx, hammer::ast::expressions_t* args);
static const hammer::ast::expression*	list_element    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	public_expression    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	expression_a    (phammer_sema_v2 ctx);
static const hammer::ast::path*	path    (phammer_sema_v2 ctx);
static void	path_root_name    (phammer_sema_v2 ctx, hammer::parscore::token& root_name);
static void	path_elements    (phammer_sema_v2 ctx, hammer::ast::expressions_t& elements);
static const hammer::ast::expression*	path_element    (phammer_sema_v2 ctx);
static void	path_trailing_slash    (phammer_sema_v2 ctx, hammer::parscore::token& trailing_slash);
static const hammer::ast::expression*	wildcard    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	wildcard_elem    (phammer_sema_v2 ctx);
static void	public_tag    (phammer_sema_v2 ctx, hammer::parscore::source_location* tag_loc);
static const hammer::ast::expression*	rule_invocation    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	struct_    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	struct_field    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	named_field    (phammer_sema_v2 ctx);
static const hammer::ast::feature*	feature    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	feature_value    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	target_ref    (phammer_sema_v2 ctx);
static const hammer::ast::path*	target_ref_impl    (phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request);
static void	target_ref_spec    (phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request);
static void	target_ref_build_request    (phammer_sema_v2 ctx, hammer::ast::features_t* build_request);
static const hammer::ast::expression*	condition    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	condition_condition    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	condition_result    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	logical_or    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	logical_and    (phammer_sema_v2 ctx);
static void	hammer_sema_v2Free(phammer_sema_v2 ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "hammer_sema_v2.gt";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new hammer_sema_v2 parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API phammer_sema_v2
hammer_sema_v2New   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return hammer_sema_v2NewSSD(instream, NULL);
}

/** \brief Create a new hammer_sema_v2 parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API phammer_sema_v2
hammer_sema_v2NewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    phammer_sema_v2 ctx;	    /* Context structure we will build and return   */
    
    ctx	= (phammer_sema_v2) ANTLR3_CALLOC(1, sizeof(hammer_sema_v2));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in hammer_sema_v2.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our hammer_sema_v2 interface
     */
    ctx->hamfile	= hamfile;
    ctx->statement	= statement;
    ctx->top_level_rule_invocation	= top_level_rule_invocation;
    ctx->target_def_prefix	= target_def_prefix;
    ctx->arguments	= arguments;
    ctx->argument	= argument;
    ctx->named_argument	= named_argument;
    ctx->expression	= expression;
    ctx->list_of	= list_of;
    ctx->list_element	= list_element;
    ctx->public_expression	= public_expression;
    ctx->expression_a	= expression_a;
    ctx->path	= path;
    ctx->path_root_name	= path_root_name;
    ctx->path_elements	= path_elements;
    ctx->path_element	= path_element;
    ctx->path_trailing_slash	= path_trailing_slash;
    ctx->wildcard	= wildcard;
    ctx->wildcard_elem	= wildcard_elem;
    ctx->public_tag	= public_tag;
    ctx->rule_invocation	= rule_invocation;
    ctx->struct_	= struct_;
    ctx->struct_field	= struct_field;
    ctx->named_field	= named_field;
    ctx->feature	= feature;
    ctx->feature_value	= feature_value;
    ctx->target_ref	= target_ref;
    ctx->target_ref_impl	= target_ref_impl;
    ctx->target_ref_spec	= target_ref_spec;
    ctx->target_ref_build_request	= target_ref_build_request;
    ctx->condition	= condition;
    ctx->condition_condition	= condition_condition;
    ctx->condition_result	= condition_result;
    ctx->logical_or	= logical_or;
    ctx->logical_and	= logical_and;
    ctx->free			= hammer_sema_v2Free;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = hammer_sema_v2TokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 hammer_sema_v2Free(phammer_sema_v2 ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return hammer_sema_v2TokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_Hamfile_in_hamfile81  */
static	ANTLR3_BITWORD FOLLOW_Hamfile_in_hamfile81_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Hamfile_in_hamfile81	= { FOLLOW_Hamfile_in_hamfile81_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_hamfile83  */
static	ANTLR3_BITWORD FOLLOW_statement_in_hamfile83_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000028) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_hamfile83	= { FOLLOW_statement_in_hamfile83_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_top_level_rule_invocation_in_statement115  */
static	ANTLR3_BITWORD FOLLOW_top_level_rule_invocation_in_statement115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_top_level_rule_invocation_in_statement115	= { FOLLOW_top_level_rule_invocation_in_statement115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Rule_in_top_level_rule_invocation138  */
static	ANTLR3_BITWORD FOLLOW_Rule_in_top_level_rule_invocation138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Rule_in_top_level_rule_invocation138	= { FOLLOW_Rule_in_top_level_rule_invocation138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_def_prefix_in_top_level_rule_invocation140  */
static	ANTLR3_BITWORD FOLLOW_target_def_prefix_in_top_level_rule_invocation140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_target_def_prefix_in_top_level_rule_invocation140	= { FOLLOW_target_def_prefix_in_top_level_rule_invocation140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_top_level_rule_invocation146  */
static	ANTLR3_BITWORD FOLLOW_Id_in_top_level_rule_invocation146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_top_level_rule_invocation146	= { FOLLOW_Id_in_top_level_rule_invocation146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_top_level_rule_invocation148  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_top_level_rule_invocation148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_top_level_rule_invocation148	= { FOLLOW_arguments_in_top_level_rule_invocation148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Local_in_target_def_prefix166  */
static	ANTLR3_BITWORD FOLLOW_Local_in_target_def_prefix166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Local_in_target_def_prefix166	= { FOLLOW_Local_in_target_def_prefix166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Explicit_in_target_def_prefix173  */
static	ANTLR3_BITWORD FOLLOW_Explicit_in_target_def_prefix173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Explicit_in_target_def_prefix173	= { FOLLOW_Explicit_in_target_def_prefix173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Arguments_in_arguments189  */
static	ANTLR3_BITWORD FOLLOW_Arguments_in_arguments189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Arguments_in_arguments189	= { FOLLOW_Arguments_in_arguments189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_arguments192  */
static	ANTLR3_BITWORD FOLLOW_argument_in_arguments192_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027CE08) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_arguments192	= { FOLLOW_argument_in_arguments192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyArgument_in_argument219  */
static	ANTLR3_BITWORD FOLLOW_EmptyArgument_in_argument219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyArgument_in_argument219	= { FOLLOW_EmptyArgument_in_argument219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_argument226  */
static	ANTLR3_BITWORD FOLLOW_expression_in_argument226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_argument226	= { FOLLOW_expression_in_argument226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_named_argument_in_argument233  */
static	ANTLR3_BITWORD FOLLOW_named_argument_in_argument233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_named_argument_in_argument233	= { FOLLOW_named_argument_in_argument233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedArgument_in_named_argument250  */
static	ANTLR3_BITWORD FOLLOW_NamedArgument_in_named_argument250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedArgument_in_named_argument250	= { FOLLOW_NamedArgument_in_named_argument250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_argument252  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_argument252_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027C800) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_argument252	= { FOLLOW_Id_in_named_argument252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_named_argument254  */
static	ANTLR3_BITWORD FOLLOW_expression_in_named_argument254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_named_argument254	= { FOLLOW_expression_in_named_argument254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedArgument_in_named_argument264  */
static	ANTLR3_BITWORD FOLLOW_NamedArgument_in_named_argument264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedArgument_in_named_argument264	= { FOLLOW_NamedArgument_in_named_argument264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_argument266  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_argument266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_argument266	= { FOLLOW_Id_in_named_argument266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyArgument_in_named_argument268  */
static	ANTLR3_BITWORD FOLLOW_EmptyArgument_in_named_argument268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyArgument_in_named_argument268	= { FOLLOW_EmptyArgument_in_named_argument268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_of_in_expression293  */
static	ANTLR3_BITWORD FOLLOW_list_of_in_expression293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_list_of_in_expression293	= { FOLLOW_list_of_in_expression293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_expression308  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_expression308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_expression308	= { FOLLOW_target_ref_in_expression308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_expression315  */
static	ANTLR3_BITWORD FOLLOW_path_in_expression315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_expression315	= { FOLLOW_path_in_expression315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_expression322  */
static	ANTLR3_BITWORD FOLLOW_Id_in_expression322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_expression322	= { FOLLOW_Id_in_expression322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_expression336  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_expression336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_expression336	= { FOLLOW_public_expression_in_expression336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_expression350  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_expression350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_expression350	= { FOLLOW_expression_a_in_expression350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_invocation_in_expression357  */
static	ANTLR3_BITWORD FOLLOW_rule_invocation_in_expression357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_invocation_in_expression357	= { FOLLOW_rule_invocation_in_expression357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_struct__in_expression364  */
static	ANTLR3_BITWORD FOLLOW_struct__in_expression364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_struct__in_expression364	= { FOLLOW_struct__in_expression364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_List_in_list_of380  */
static	ANTLR3_BITWORD FOLLOW_List_in_list_of380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_List_in_list_of380	= { FOLLOW_List_in_list_of380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_element_in_list_of383  */
static	ANTLR3_BITWORD FOLLOW_list_element_in_list_of383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000030278008) };
static  ANTLR3_BITSET_LIST FOLLOW_list_element_in_list_of383	= { FOLLOW_list_element_in_list_of383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_list_element413  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_list_element413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_list_element413	= { FOLLOW_target_ref_in_list_element413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_list_element420  */
static	ANTLR3_BITWORD FOLLOW_path_in_list_element420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_list_element420	= { FOLLOW_path_in_list_element420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_list_element427  */
static	ANTLR3_BITWORD FOLLOW_Id_in_list_element427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_list_element427	= { FOLLOW_Id_in_list_element427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_list_element441  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_list_element441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_list_element441	= { FOLLOW_public_expression_in_list_element441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_list_element455  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_list_element455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_list_element455	= { FOLLOW_expression_a_in_list_element455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_invocation_in_list_element462  */
static	ANTLR3_BITWORD FOLLOW_rule_invocation_in_list_element462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_invocation_in_list_element462	= { FOLLOW_rule_invocation_in_list_element462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_public_expression478  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_public_expression478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_public_expression478	= { FOLLOW_PublicTag_in_public_expression478_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_public_expression480  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_public_expression480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_public_expression480	= { FOLLOW_expression_a_in_public_expression480_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_expression_a496  */
static	ANTLR3_BITWORD FOLLOW_feature_in_expression_a496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_expression_a496	= { FOLLOW_feature_in_expression_a496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_in_expression_a503  */
static	ANTLR3_BITWORD FOLLOW_condition_in_expression_a503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_in_expression_a503	= { FOLLOW_condition_in_expression_a503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Path_in_path525  */
static	ANTLR3_BITWORD FOLLOW_Path_in_path525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Path_in_path525	= { FOLLOW_Path_in_path525_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_root_name_in_path527  */
static	ANTLR3_BITWORD FOLLOW_path_root_name_in_path527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000011000000) };
static  ANTLR3_BITSET_LIST FOLLOW_path_root_name_in_path527	= { FOLLOW_path_root_name_in_path527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_elements_in_path531  */
static	ANTLR3_BITWORD FOLLOW_path_elements_in_path531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_elements_in_path531	= { FOLLOW_path_elements_in_path531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_trailing_slash_in_path534  */
static	ANTLR3_BITWORD FOLLOW_path_trailing_slash_in_path534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_trailing_slash_in_path534	= { FOLLOW_path_trailing_slash_in_path534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PathRootName_in_path_root_name551  */
static	ANTLR3_BITWORD FOLLOW_PathRootName_in_path_root_name551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PathRootName_in_path_root_name551	= { FOLLOW_PathRootName_in_path_root_name551_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_element_in_path_elements565  */
static	ANTLR3_BITWORD FOLLOW_path_element_in_path_elements565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000011000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_element_in_path_elements565	= { FOLLOW_path_element_in_path_elements565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_path_element582  */
static	ANTLR3_BITWORD FOLLOW_Id_in_path_element582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_path_element582	= { FOLLOW_Id_in_path_element582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wildcard_in_path_element589  */
static	ANTLR3_BITWORD FOLLOW_wildcard_in_path_element589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wildcard_in_path_element589	= { FOLLOW_wildcard_in_path_element589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PathTrailingSlash_in_path_trailing_slash602  */
static	ANTLR3_BITWORD FOLLOW_PathTrailingSlash_in_path_trailing_slash602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PathTrailingSlash_in_path_trailing_slash602	= { FOLLOW_PathTrailingSlash_in_path_trailing_slash602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Wildcard_in_wildcard623  */
static	ANTLR3_BITWORD FOLLOW_Wildcard_in_wildcard623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Wildcard_in_wildcard623	= { FOLLOW_Wildcard_in_wildcard623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wildcard_elem_in_wildcard626  */
static	ANTLR3_BITWORD FOLLOW_wildcard_elem_in_wildcard626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000610000008) };
static  ANTLR3_BITSET_LIST FOLLOW_wildcard_elem_in_wildcard626	= { FOLLOW_wildcard_elem_in_wildcard626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_wildcard_elem648  */
static	ANTLR3_BITWORD FOLLOW_Id_in_wildcard_elem648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_wildcard_elem648	= { FOLLOW_Id_in_wildcard_elem648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QuestionMark_in_wildcard_elem655  */
static	ANTLR3_BITWORD FOLLOW_QuestionMark_in_wildcard_elem655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QuestionMark_in_wildcard_elem655	= { FOLLOW_QuestionMark_in_wildcard_elem655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Asterix_in_wildcard_elem662  */
static	ANTLR3_BITWORD FOLLOW_Asterix_in_wildcard_elem662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Asterix_in_wildcard_elem662	= { FOLLOW_Asterix_in_wildcard_elem662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_public_tag677  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_public_tag677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_public_tag677	= { FOLLOW_PublicTag_in_public_tag677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RuleInvocation_in_rule_invocation700  */
static	ANTLR3_BITWORD FOLLOW_RuleInvocation_in_rule_invocation700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RuleInvocation_in_rule_invocation700	= { FOLLOW_RuleInvocation_in_rule_invocation700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_rule_invocation704  */
static	ANTLR3_BITWORD FOLLOW_Id_in_rule_invocation704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_rule_invocation704	= { FOLLOW_Id_in_rule_invocation704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_rule_invocation706  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_rule_invocation706_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_rule_invocation706	= { FOLLOW_arguments_in_rule_invocation706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Structure_in_struct_729  */
static	ANTLR3_BITWORD FOLLOW_Structure_in_struct_729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Structure_in_struct_729	= { FOLLOW_Structure_in_struct_729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_struct_field_in_struct_732  */
static	ANTLR3_BITWORD FOLLOW_struct_field_in_struct_732_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027F808) };
static  ANTLR3_BITSET_LIST FOLLOW_struct_field_in_struct_732	= { FOLLOW_struct_field_in_struct_732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyField_in_struct_field753  */
static	ANTLR3_BITWORD FOLLOW_EmptyField_in_struct_field753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyField_in_struct_field753	= { FOLLOW_EmptyField_in_struct_field753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_named_field_in_struct_field760  */
static	ANTLR3_BITWORD FOLLOW_named_field_in_struct_field760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_named_field_in_struct_field760	= { FOLLOW_named_field_in_struct_field760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_struct_field767  */
static	ANTLR3_BITWORD FOLLOW_expression_in_struct_field767_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_struct_field767	= { FOLLOW_expression_in_struct_field767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedField_in_named_field783  */
static	ANTLR3_BITWORD FOLLOW_NamedField_in_named_field783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedField_in_named_field783	= { FOLLOW_NamedField_in_named_field783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_field785  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_field785_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027C800) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_field785	= { FOLLOW_Id_in_named_field785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_named_field787  */
static	ANTLR3_BITWORD FOLLOW_expression_in_named_field787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_named_field787	= { FOLLOW_expression_in_named_field787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedField_in_named_field797  */
static	ANTLR3_BITWORD FOLLOW_NamedField_in_named_field797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedField_in_named_field797	= { FOLLOW_NamedField_in_named_field797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_field799  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_field799_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_field799	= { FOLLOW_Id_in_named_field799_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyField_in_named_field801  */
static	ANTLR3_BITWORD FOLLOW_EmptyField_in_named_field801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyField_in_named_field801	= { FOLLOW_EmptyField_in_named_field801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Feature_in_feature819  */
static	ANTLR3_BITWORD FOLLOW_Feature_in_feature819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Feature_in_feature819	= { FOLLOW_Feature_in_feature819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_feature821  */
static	ANTLR3_BITWORD FOLLOW_Id_in_feature821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000030240000) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_feature821	= { FOLLOW_Id_in_feature821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_value_in_feature823  */
static	ANTLR3_BITWORD FOLLOW_feature_value_in_feature823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_value_in_feature823	= { FOLLOW_feature_value_in_feature823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_feature_value841  */
static	ANTLR3_BITWORD FOLLOW_Id_in_feature_value841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_feature_value841	= { FOLLOW_Id_in_feature_value841_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_feature_value848  */
static	ANTLR3_BITWORD FOLLOW_path_in_feature_value848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_feature_value848	= { FOLLOW_path_in_feature_value848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_feature_value855  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_feature_value855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_feature_value855	= { FOLLOW_target_ref_in_feature_value855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_target_ref876  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_target_ref876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_target_ref876	= { FOLLOW_PublicTag_in_target_ref876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_impl_in_target_ref878  */
static	ANTLR3_BITWORD FOLLOW_target_ref_impl_in_target_ref878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_impl_in_target_ref878	= { FOLLOW_target_ref_impl_in_target_ref878_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_impl_in_target_ref887  */
static	ANTLR3_BITWORD FOLLOW_target_ref_impl_in_target_ref887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_impl_in_target_ref887	= { FOLLOW_target_ref_impl_in_target_ref887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRef_in_target_ref_impl906  */
static	ANTLR3_BITWORD FOLLOW_TargetRef_in_target_ref_impl906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRef_in_target_ref_impl906	= { FOLLOW_TargetRef_in_target_ref_impl906_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_target_ref_impl908  */
static	ANTLR3_BITWORD FOLLOW_path_in_target_ref_impl908_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_target_ref_impl908	= { FOLLOW_path_in_target_ref_impl908_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_spec_in_target_ref_impl910  */
static	ANTLR3_BITWORD FOLLOW_target_ref_spec_in_target_ref_impl910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_spec_in_target_ref_impl910	= { FOLLOW_target_ref_spec_in_target_ref_impl910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRef_in_target_ref_impl921  */
static	ANTLR3_BITWORD FOLLOW_TargetRef_in_target_ref_impl921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRef_in_target_ref_impl921	= { FOLLOW_TargetRef_in_target_ref_impl921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_target_ref_impl923  */
static	ANTLR3_BITWORD FOLLOW_Id_in_target_ref_impl923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400008) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_target_ref_impl923	= { FOLLOW_Id_in_target_ref_impl923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_spec_in_target_ref_impl925  */
static	ANTLR3_BITWORD FOLLOW_target_ref_spec_in_target_ref_impl925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_spec_in_target_ref_impl925	= { FOLLOW_target_ref_spec_in_target_ref_impl925_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefSpec_in_target_ref_spec944  */
static	ANTLR3_BITWORD FOLLOW_TargetRefSpec_in_target_ref_spec944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefSpec_in_target_ref_spec944	= { FOLLOW_TargetRefSpec_in_target_ref_spec944_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_target_ref_spec946  */
static	ANTLR3_BITWORD FOLLOW_Id_in_target_ref_spec946_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800008) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_target_ref_spec946	= { FOLLOW_Id_in_target_ref_spec946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_build_request_in_target_ref_spec948  */
static	ANTLR3_BITWORD FOLLOW_target_ref_build_request_in_target_ref_spec948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_build_request_in_target_ref_spec948	= { FOLLOW_target_ref_build_request_in_target_ref_spec948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefSpec_in_target_ref_spec959  */
static	ANTLR3_BITWORD FOLLOW_TargetRefSpec_in_target_ref_spec959_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefSpec_in_target_ref_spec959	= { FOLLOW_TargetRefSpec_in_target_ref_spec959_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_build_request_in_target_ref_spec961  */
static	ANTLR3_BITWORD FOLLOW_target_ref_build_request_in_target_ref_spec961_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_build_request_in_target_ref_spec961	= { FOLLOW_target_ref_build_request_in_target_ref_spec961_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefBuildRequest_in_target_ref_build_request976  */
static	ANTLR3_BITWORD FOLLOW_TargetRefBuildRequest_in_target_ref_build_request976_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefBuildRequest_in_target_ref_build_request976	= { FOLLOW_TargetRefBuildRequest_in_target_ref_build_request976_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_target_ref_build_request979  */
static	ANTLR3_BITWORD FOLLOW_feature_in_target_ref_build_request979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008008) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_target_ref_build_request979	= { FOLLOW_feature_in_target_ref_build_request979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Condition_in_condition999  */
static	ANTLR3_BITWORD FOLLOW_Condition_in_condition999_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Condition_in_condition999	= { FOLLOW_Condition_in_condition999_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_condition1001  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_condition1001_bits[]	= { ANTLR3_UINT64_LIT(0x000000002000C000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_condition1001	= { FOLLOW_condition_condition_in_condition1001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_result_in_condition1003  */
static	ANTLR3_BITWORD FOLLOW_condition_result_in_condition1003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_result_in_condition1003	= { FOLLOW_condition_result_in_condition1003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_condition_condition1020  */
static	ANTLR3_BITWORD FOLLOW_feature_in_condition_condition1020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_condition_condition1020	= { FOLLOW_feature_in_condition_condition1020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logical_or_in_condition_condition1027  */
static	ANTLR3_BITWORD FOLLOW_logical_or_in_condition_condition1027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logical_or_in_condition_condition1027	= { FOLLOW_logical_or_in_condition_condition1027_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logical_and_in_condition_condition1034  */
static	ANTLR3_BITWORD FOLLOW_logical_and_in_condition_condition1034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logical_and_in_condition_condition1034	= { FOLLOW_logical_and_in_condition_condition1034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_condition_result1054  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_condition_result1054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_condition_result1054	= { FOLLOW_public_expression_in_condition_result1054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_condition_result1062  */
static	ANTLR3_BITWORD FOLLOW_feature_in_condition_result1062_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_condition_result1062	= { FOLLOW_feature_in_condition_result1062_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_of_in_condition_result1069  */
static	ANTLR3_BITWORD FOLLOW_list_of_in_condition_result1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_list_of_in_condition_result1069	= { FOLLOW_list_of_in_condition_result1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LogicalOr_in_logical_or1087  */
static	ANTLR3_BITWORD FOLLOW_LogicalOr_in_logical_or1087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LogicalOr_in_logical_or1087	= { FOLLOW_LogicalOr_in_logical_or1087_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_or1091  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_or1091_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006008000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_or1091	= { FOLLOW_condition_condition_in_logical_or1091_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_or1095  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_or1095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_or1095	= { FOLLOW_condition_condition_in_logical_or1095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LogicalAnd_in_logical_and1113  */
static	ANTLR3_BITWORD FOLLOW_LogicalAnd_in_logical_and1113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LogicalAnd_in_logical_and1113	= { FOLLOW_LogicalAnd_in_logical_and1113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_and1117  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_and1117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006008000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_and1117	= { FOLLOW_condition_condition_in_logical_and1117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_and1121  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_and1121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_and1121	= { FOLLOW_condition_condition_in_logical_and1121_bits, 1	};
     


/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );
 */
static const ANTLR3_INT32 dfa7_eot[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_eof[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_min[11] =
    {
	11, -1, 2, -1, -1, -1, -1, -1, -1, 15, -1
    };
static const ANTLR3_INT32 dfa7_max[11] =
    {
	29, -1, 2, -1, -1, -1, -1, -1, -1, 21, -1
    };
static const ANTLR3_INT32 dfa7_accept[11] =
    {
	-1, 1, -1, 2, 3, 4, 6, 7, 8, -1, 5
    };
static const ANTLR3_INT32 dfa7_special[11] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa7_T_empty	    NULL

static const ANTLR3_INT32 dfa7_T0[] =
    {
	8, -1, -1, 1, 6, 6, 7, 4, -1, -1, 3, -1, -1, -1, -1, -1, -1, 5, 2
    };static const ANTLR3_INT32 dfa7_T1[] =
    {
	10, 10, -1, -1, -1, -1, 3
    };static const ANTLR3_INT32 dfa7_T2[] =
    {
	9
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa7_transitions[] =
{
    dfa7_T0, dfa7_T_empty, dfa7_T2, dfa7_T_empty, dfa7_T_empty, dfa7_T_empty, 
    dfa7_T_empty, dfa7_T_empty, dfa7_T_empty, dfa7_T1, dfa7_T_empty	
};


/* Declare tracking structure for Cyclic DFA 7
 */
static
ANTLR3_CYCLIC_DFA cdfa7
    =	{
	    7,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa7_eot,	    /* EOT table			    */
	    dfa7_eof,	    /* EOF table			    */
	    dfa7_min,	    /* Minimum tokens for each state    */
	    dfa7_max,	    /* Maximum tokens for each state    */
	    dfa7_accept,	/* Accept table			    */
	    dfa7_special,	/* Special transition states	    */
	    dfa7_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 7
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */ 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start hamfile
 * hammer_sema_v2.gt:22:1: hamfile returns [const hammer::ast::hamfile* result] : ^( Hamfile ( statement[&statements] )* ) ;
 */
static const hammer::ast::hamfile*
hamfile(phammer_sema_v2 ctx)
{   
    const hammer::ast::hamfile* result = NULL;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::statements_t, statements); 
    {
        // hammer_sema_v2.gt:24:2: ( ^( Hamfile ( statement[&statements] )* ) )
        // hammer_sema_v2.gt:24:4: ^( Hamfile ( statement[&statements] )* )
        {
             MATCHT(Hamfile, &FOLLOW_Hamfile_in_hamfile81); 
            if  (HASEXCEPTION())
            {
                goto rulehamfileEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulehamfileEx;
                }


                // hammer_sema_v2.gt:24:14: ( statement[&statements] )*

                for (;;)
                {
                    int alt1=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA1_0 = LA(1);
                        if ( (LA1_0 == Rule) ) 
                        {
                            alt1=1;
                        }

                    }
                    switch (alt1) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:24:14: statement[&statements]
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_hamfile83);
                	        statement(ctx, &statements);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulehamfileEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop1;	/* break out of the loop */
                	    break;
                    }
                }
                loop1: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulehamfileEx;
                }

            }
            {
                 result = SEMA->on_hamfile(statements); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehamfileEx; /* Prevent compiler warnings */
    rulehamfileEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end hamfile */

/** 
 * $ANTLR start statement
 * hammer_sema_v2.gt:27:1: statement[hammer::ast::statements_t* statements] : top_level_rule_invocation ;
 */
static void
statement(phammer_sema_v2 ctx, hammer::ast::statements_t* statements)
{   
    const hammer::ast::statement* top_level_rule_invocation1;
    #undef	RETURN_TYPE_top_level_rule_invocation1
    #define	RETURN_TYPE_top_level_rule_invocation1 const hammer::ast::statement*

    /* Initialize rule variables
     */


    top_level_rule_invocation1 = NULL;

    {
        // hammer_sema_v2.gt:28:2: ( top_level_rule_invocation )
        // hammer_sema_v2.gt:28:4: top_level_rule_invocation
        {
            FOLLOWPUSH(FOLLOW_top_level_rule_invocation_in_statement115);
            top_level_rule_invocation1=top_level_rule_invocation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatementEx;
            }

            {
                 statements->push_back(top_level_rule_invocation1); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start top_level_rule_invocation
 * hammer_sema_v2.gt:31:1: top_level_rule_invocation returns [const hammer::ast::statement* result] : ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] ) ;
 */
static const hammer::ast::statement*
top_level_rule_invocation(phammer_sema_v2 ctx)
{   
    const hammer::ast::statement* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
            hammer::parscore::source_location explicit_tag, local_tag;

    name       = NULL;

    {
        // hammer_sema_v2.gt:35:2: ( ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] ) )
        // hammer_sema_v2.gt:35:4: ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] )
        {
             MATCHT(Rule, &FOLLOW_Rule_in_top_level_rule_invocation138); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            // hammer_sema_v2.gt:35:11: ( target_def_prefix[&explicit_tag, &local_tag] )?
            {
                int alt2=2;
                {
                    int LA2_0 = LA(1);
                    if ( (((LA2_0 >= Local) && (LA2_0 <= Explicit))) ) 
                    {
                        alt2=1;
                    }
                }
                switch (alt2) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:35:11: target_def_prefix[&explicit_tag, &local_tag]
            	    {
            	        FOLLOWPUSH(FOLLOW_target_def_prefix_in_top_level_rule_invocation140);
            	        target_def_prefix(ctx, &explicit_tag, &local_tag);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletop_level_rule_invocationEx;
            	        }


            	    }
            	    break;

                }
            }
            name = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_top_level_rule_invocation146); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }

            FOLLOWPUSH(FOLLOW_arguments_in_top_level_rule_invocation148);
            arguments(ctx, &args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }

            {
                 result = SEMA->on_top_level_rule_invocation(explicit_tag, local_tag, name->getToken(name), args); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletop_level_rule_invocationEx; /* Prevent compiler warnings */
    ruletop_level_rule_invocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end top_level_rule_invocation */

/** 
 * $ANTLR start target_def_prefix
 * hammer_sema_v2.gt:38:1: target_def_prefix[hammer::parscore::source_location* explicit_tag,\n\t\t hammer::parscore::source_location* local_tag] : ( Local | Explicit );
 */
static void
target_def_prefix(phammer_sema_v2 ctx, hammer::parscore::source_location* explicit_tag, hammer::parscore::source_location* local_tag)
{   
    pANTLR3_BASE_TREE    Local2;
    pANTLR3_BASE_TREE    Explicit3;

    /* Initialize rule variables
     */


    Local2       = NULL;
    Explicit3       = NULL;

    {
        {
            //  hammer_sema_v2.gt:40:2: ( Local | Explicit )
            
            ANTLR3_UINT32 alt3;

            alt3=2;


            {
                int LA3_0 = LA(1);
                if ( (LA3_0 == Local) ) 
                {
                    alt3=1;
                }
                else if ( (LA3_0 == Explicit) ) 
                {
                    alt3=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 3;
                    EXCEPTION->state        = 0;


                    goto ruletarget_def_prefixEx;
                }
            }
            switch (alt3) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:40:4: Local
        	    {
        	        Local2 = (pANTLR3_BASE_TREE) MATCHT(Local, &FOLLOW_Local_in_target_def_prefix166); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_def_prefixEx;
        	        }

        	        {
        	             *local_tag = hammer::parscore::source_location(Local2->getToken(Local2)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:41:4: Explicit
        	    {
        	        Explicit3 = (pANTLR3_BASE_TREE) MATCHT(Explicit, &FOLLOW_Explicit_in_target_def_prefix173); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_def_prefixEx;
        	        }

        	        {
        	             *explicit_tag = hammer::parscore::source_location(Explicit3->getToken(Explicit3)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_def_prefixEx; /* Prevent compiler warnings */
    ruletarget_def_prefixEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_def_prefix */

/** 
 * $ANTLR start arguments
 * hammer_sema_v2.gt:44:1: arguments[hammer::ast::expressions_t* args] : ^( Arguments ( argument )* ) ;
 */
static void
arguments(phammer_sema_v2 ctx, hammer::ast::expressions_t* args)
{   
    const hammer::ast::expression* argument4;
    #undef	RETURN_TYPE_argument4
    #define	RETURN_TYPE_argument4 const hammer::ast::expression*

    /* Initialize rule variables
     */


    argument4 = NULL;

    {
        // hammer_sema_v2.gt:45:2: ( ^( Arguments ( argument )* ) )
        // hammer_sema_v2.gt:45:4: ^( Arguments ( argument )* )
        {
             MATCHT(Arguments, &FOLLOW_Arguments_in_arguments189); 
            if  (HASEXCEPTION())
            {
                goto ruleargumentsEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargumentsEx;
                }


                // hammer_sema_v2.gt:45:16: ( argument )*

                for (;;)
                {
                    int alt4=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA4_0 = LA(1);
                        if ( (((LA4_0 >= EmptyArgument) && (LA4_0 <= Structure)) || ((LA4_0 >= List) && (LA4_0 <= Path)) || LA4_0 == TargetRef || ((LA4_0 >= Id) && (LA4_0 <= PublicTag))) ) 
                        {
                            alt4=1;
                        }

                    }
                    switch (alt4) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:45:17: argument
                	    {
                	        FOLLOWPUSH(FOLLOW_argument_in_arguments192);
                	        argument4=argument(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleargumentsEx;
                	        }

                	        {
                	             args->push_back(argument4); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop4;	/* break out of the loop */
                	    break;
                    }
                }
                loop4: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargumentsEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentsEx; /* Prevent compiler warnings */
    ruleargumentsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end arguments */

/** 
 * $ANTLR start argument
 * hammer_sema_v2.gt:48:1: argument returns [const hammer::ast::expression* result] : ( EmptyArgument | expression | named_argument );
 */
static const hammer::ast::expression*
argument(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    EmptyArgument5;
    const hammer::ast::expression* expression6;
    #undef	RETURN_TYPE_expression6
    #define	RETURN_TYPE_expression6 const hammer::ast::expression*

    const hammer::ast::expression* named_argument7;
    #undef	RETURN_TYPE_named_argument7
    #define	RETURN_TYPE_named_argument7 const hammer::ast::expression*

    /* Initialize rule variables
     */


    EmptyArgument5       = NULL;
    expression6 = NULL;
    named_argument7 = NULL;

    {
        {
            //  hammer_sema_v2.gt:49:2: ( EmptyArgument | expression | named_argument )
            
            ANTLR3_UINT32 alt5;

            alt5=3;

            switch ( LA(1) ) 
            {
            case EmptyArgument:
            	{
            		alt5=1;
            	}
                break;
            case Structure:
            case List:
            case Feature:
            case Condition:
            case RuleInvocation:
            case Path:
            case TargetRef:
            case Id:
            case PublicTag:
            	{
            		alt5=2;
            	}
                break;
            case NamedArgument:
            	{
            		alt5=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;
            }

            switch (alt5) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:49:4: EmptyArgument
        	    {
        	        EmptyArgument5 = (pANTLR3_BASE_TREE) MATCHT(EmptyArgument, &FOLLOW_EmptyArgument_in_argument219); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = SEMA->on_empty_expr(EmptyArgument5->getToken(EmptyArgument5)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:50:4: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_argument226);
        	        expression6=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = expression6; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:51:4: named_argument
        	    {
        	        FOLLOWPUSH(FOLLOW_named_argument_in_argument233);
        	        named_argument7=named_argument(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = named_argument7; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end argument */

/** 
 * $ANTLR start named_argument
 * hammer_sema_v2.gt:54:1: named_argument returns [const hammer::ast::expression* result] : ( ^( NamedArgument Id expression ) | ^( NamedArgument Id EmptyArgument ) );
 */
static const hammer::ast::expression*
named_argument(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id8;
    pANTLR3_BASE_TREE    Id10;
    pANTLR3_BASE_TREE    EmptyArgument11;
    const hammer::ast::expression* expression9;
    #undef	RETURN_TYPE_expression9
    #define	RETURN_TYPE_expression9 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id8       = NULL;
    Id10       = NULL;
    EmptyArgument11       = NULL;
    expression9 = NULL;

    {
        {
            //  hammer_sema_v2.gt:55:2: ( ^( NamedArgument Id expression ) | ^( NamedArgument Id EmptyArgument ) )
            
            ANTLR3_UINT32 alt6;

            alt6=2;


            {
                int LA6_0 = LA(1);
                if ( (LA6_0 == NamedArgument) ) 
                {

                    {
                        int LA6_1 = LA(2);
                        if ( (LA6_1 == DOWN) ) 
                        {

                            {
                                int LA6_2 = LA(3);
                                if ( (LA6_2 == Id) ) 
                                {

                                    {
                                        int LA6_3 = LA(4);
                                        if ( (LA6_3 == EmptyArgument) ) 
                                        {
                                            alt6=2;
                                        }
                                        else if ( (LA6_3 == Structure || ((LA6_3 >= List) && (LA6_3 <= Path)) || LA6_3 == TargetRef || ((LA6_3 >= Id) && (LA6_3 <= PublicTag))) ) 
                                        {
                                            alt6=1;
                                        }
                                        else 
                                        {
                                        
                                            CONSTRUCTEX();
                                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            EXCEPTION->message      = (void *)"";
                                            EXCEPTION->decisionNum  = 6;
                                            EXCEPTION->state        = 3;


                                            goto rulenamed_argumentEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 6;
                                    EXCEPTION->state        = 2;


                                    goto rulenamed_argumentEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 6;
                            EXCEPTION->state        = 1;


                            goto rulenamed_argumentEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 6;
                    EXCEPTION->state        = 0;


                    goto rulenamed_argumentEx;
                }
            }
            switch (alt6) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:55:4: ^( NamedArgument Id expression )
        	    {
        	         MATCHT(NamedArgument, &FOLLOW_NamedArgument_in_named_argument250); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        Id8 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_argument252); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_named_argument254);
        	        expression9=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id8->getToken(Id8), expression9); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:56:4: ^( NamedArgument Id EmptyArgument )
        	    {
        	         MATCHT(NamedArgument, &FOLLOW_NamedArgument_in_named_argument264); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        Id10 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_argument266); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        EmptyArgument11 = (pANTLR3_BASE_TREE) MATCHT(EmptyArgument, &FOLLOW_EmptyArgument_in_named_argument268); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id10->getToken(Id10), SEMA->on_empty_expr(EmptyArgument11->getToken(EmptyArgument11))); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenamed_argumentEx; /* Prevent compiler warnings */
    rulenamed_argumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end named_argument */

/** 
 * $ANTLR start expression
 * hammer_sema_v2.gt:59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );
 */
static const hammer::ast::expression*
expression(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id14;
    const hammer::ast::expression* target_ref12;
    #undef	RETURN_TYPE_target_ref12
    #define	RETURN_TYPE_target_ref12 const hammer::ast::expression*

    const hammer::ast::path* path13;
    #undef	RETURN_TYPE_path13
    #define	RETURN_TYPE_path13 const hammer::ast::path*

    const hammer::ast::expression* public_expression15;
    #undef	RETURN_TYPE_public_expression15
    #define	RETURN_TYPE_public_expression15 const hammer::ast::expression*

    const hammer::ast::expression* expression_a16;
    #undef	RETURN_TYPE_expression_a16
    #define	RETURN_TYPE_expression_a16 const hammer::ast::expression*

    const hammer::ast::expression* rule_invocation17;
    #undef	RETURN_TYPE_rule_invocation17
    #define	RETURN_TYPE_rule_invocation17 const hammer::ast::expression*

    const hammer::ast::expression* struct_18;
    #undef	RETURN_TYPE_struct_18
    #define	RETURN_TYPE_struct_18 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
    Id14       = NULL;
    target_ref12 = NULL;
    path13 = NULL;
    public_expression15 = NULL;
    expression_a16 = NULL;
    rule_invocation17 = NULL;
    struct_18 = NULL;

    {
        {
            //  hammer_sema_v2.gt:61:2: ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ )
            
            ANTLR3_UINT32 alt7;

            alt7=8;

            alt7 = cdfa7.predict(ctx, RECOGNIZER, ISTREAM, &cdfa7);
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }

            switch (alt7) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:61:4: list_of[&args]
        	    {
        	        FOLLOWPUSH(FOLLOW_list_of_in_expression293);
        	        list_of(ctx, &args);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = SEMA->on_list_of(args); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:62:11: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_expression308);
        	        target_ref12=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = target_ref12; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:63:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_expression315);
        	        path13=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = path13; 
        	        }

        	    }
        	    break;
        	case 4:
        	    // hammer_sema_v2.gt:64:4: Id
        	    {
        	        Id14 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_expression322); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id14->getToken(Id14)); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // hammer_sema_v2.gt:65:11: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_expression336);
        	        public_expression15=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = public_expression15; 
        	        }

        	    }
        	    break;
        	case 6:
        	    // hammer_sema_v2.gt:66:11: expression_a
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_a_in_expression350);
        	        expression_a16=expression_a(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = expression_a16; 
        	        }

        	    }
        	    break;
        	case 7:
        	    // hammer_sema_v2.gt:67:4: rule_invocation
        	    {
        	        FOLLOWPUSH(FOLLOW_rule_invocation_in_expression357);
        	        rule_invocation17=rule_invocation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = rule_invocation17; 
        	        }

        	    }
        	    break;
        	case 8:
        	    // hammer_sema_v2.gt:68:4: struct_
        	    {
        	        FOLLOWPUSH(FOLLOW_struct__in_expression364);
        	        struct_18=struct_(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = struct_18; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end expression */

/** 
 * $ANTLR start list_of
 * hammer_sema_v2.gt:72:1: list_of[hammer::ast::expressions_t* args] : ^( List ( list_element )+ ) ;
 */
static void
list_of(phammer_sema_v2 ctx, hammer::ast::expressions_t* args)
{   
    const hammer::ast::expression* list_element19;
    #undef	RETURN_TYPE_list_element19
    #define	RETURN_TYPE_list_element19 const hammer::ast::expression*

    /* Initialize rule variables
     */


    list_element19 = NULL;

    {
        // hammer_sema_v2.gt:73:2: ( ^( List ( list_element )+ ) )
        // hammer_sema_v2.gt:73:4: ^( List ( list_element )+ )
        {
             MATCHT(List, &FOLLOW_List_in_list_of380); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }

            // hammer_sema_v2.gt:73:11: ( list_element )+
            {
                int cnt8=0;

                for (;;)
                {
                    int alt8=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA8_0 = LA(1);
            	    if ( (((LA8_0 >= Feature) && (LA8_0 <= Path)) || LA8_0 == TargetRef || ((LA8_0 >= Id) && (LA8_0 <= PublicTag))) ) 
            	    {
            	        alt8=1;
            	    }

            	}
            	switch (alt8) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:73:12: list_element
            	        {
            	            FOLLOWPUSH(FOLLOW_list_element_in_list_of383);
            	            list_element19=list_element(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulelist_ofEx;
            	            }

            	            {
            	                 args->push_back(list_element19); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt8 >= 1 )
            		{
            		    goto loop8;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulelist_ofEx;
            	}
            	cnt8++;
                }
                loop8: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelist_ofEx; /* Prevent compiler warnings */
    rulelist_ofEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end list_of */

/** 
 * $ANTLR start list_element
 * hammer_sema_v2.gt:75:1: list_element returns [const hammer::ast::expression* result] : ( target_ref | path | Id | public_expression | expression_a | rule_invocation );
 */
static const hammer::ast::expression*
list_element(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id22;
    const hammer::ast::expression* target_ref20;
    #undef	RETURN_TYPE_target_ref20
    #define	RETURN_TYPE_target_ref20 const hammer::ast::expression*

    const hammer::ast::path* path21;
    #undef	RETURN_TYPE_path21
    #define	RETURN_TYPE_path21 const hammer::ast::path*

    const hammer::ast::expression* public_expression23;
    #undef	RETURN_TYPE_public_expression23
    #define	RETURN_TYPE_public_expression23 const hammer::ast::expression*

    const hammer::ast::expression* expression_a24;
    #undef	RETURN_TYPE_expression_a24
    #define	RETURN_TYPE_expression_a24 const hammer::ast::expression*

    const hammer::ast::expression* rule_invocation25;
    #undef	RETURN_TYPE_rule_invocation25
    #define	RETURN_TYPE_rule_invocation25 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id22       = NULL;
    target_ref20 = NULL;
    path21 = NULL;
    public_expression23 = NULL;
    expression_a24 = NULL;
    rule_invocation25 = NULL;

    {
        {
            //  hammer_sema_v2.gt:76:2: ( target_ref | path | Id | public_expression | expression_a | rule_invocation )
            
            ANTLR3_UINT32 alt9;

            alt9=6;

            switch ( LA(1) ) 
            {
            case PublicTag:
            	{

            		{
            		    int LA9_1 = LA(2);
            		    if ( (LA9_1 == DOWN) ) 
            		    {

            		        {
            		            int LA9_7 = LA(3);
            		            if ( (LA9_7 == TargetRef) ) 
            		            {
            		                alt9=1;
            		            }
            		            else if ( (((LA9_7 >= Feature) && (LA9_7 <= Condition))) ) 
            		            {
            		                alt9=4;
            		            }
            		            else 
            		            {
            		            
            		                CONSTRUCTEX();
            		                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		                EXCEPTION->message      = (void *)"";
            		                EXCEPTION->decisionNum  = 9;
            		                EXCEPTION->state        = 7;


            		                goto rulelist_elementEx;
            		            }
            		        }
            		    }
            		    else 
            		    {
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 9;
            		        EXCEPTION->state        = 1;


            		        goto rulelist_elementEx;
            		    }
            		}
            	}
                break;
            case TargetRef:
            	{
            		alt9=1;
            	}
                break;
            case Path:
            	{
            		alt9=2;
            	}
                break;
            case Id:
            	{
            		alt9=3;
            	}
                break;
            case Feature:
            case Condition:
            	{
            		alt9=5;
            	}
                break;
            case RuleInvocation:
            	{
            		alt9=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto rulelist_elementEx;
            }

            switch (alt9) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:76:4: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_list_element413);
        	        target_ref20=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = target_ref20; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:77:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_list_element420);
        	        path21=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = path21; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:78:4: Id
        	    {
        	        Id22 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_list_element427); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id22->getToken(Id22)); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // hammer_sema_v2.gt:79:11: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_list_element441);
        	        public_expression23=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = public_expression23; 
        	        }

        	    }
        	    break;
        	case 5:
        	    // hammer_sema_v2.gt:80:11: expression_a
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_a_in_list_element455);
        	        expression_a24=expression_a(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = expression_a24; 
        	        }

        	    }
        	    break;
        	case 6:
        	    // hammer_sema_v2.gt:81:4: rule_invocation
        	    {
        	        FOLLOWPUSH(FOLLOW_rule_invocation_in_list_element462);
        	        rule_invocation25=rule_invocation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = rule_invocation25; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulelist_elementEx; /* Prevent compiler warnings */
    rulelist_elementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end list_element */

/** 
 * $ANTLR start public_expression
 * hammer_sema_v2.gt:83:1: public_expression returns [const hammer::ast::expression* result] : ^( PublicTag expression_a ) ;
 */
static const hammer::ast::expression*
public_expression(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    PublicTag26;
    const hammer::ast::expression* expression_a27;
    #undef	RETURN_TYPE_expression_a27
    #define	RETURN_TYPE_expression_a27 const hammer::ast::expression*

    /* Initialize rule variables
     */


    PublicTag26       = NULL;
    expression_a27 = NULL;

    {
        // hammer_sema_v2.gt:84:2: ( ^( PublicTag expression_a ) )
        // hammer_sema_v2.gt:84:4: ^( PublicTag expression_a )
        {
            PublicTag26 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_public_expression478); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_a_in_public_expression480);
            expression_a27=expression_a(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }

            {
                 result = SEMA->on_public_expr(PublicTag26->getToken(PublicTag26), expression_a27); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepublic_expressionEx; /* Prevent compiler warnings */
    rulepublic_expressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end public_expression */

/** 
 * $ANTLR start expression_a
 * hammer_sema_v2.gt:86:1: expression_a returns [const hammer::ast::expression* result] : ( feature | condition );
 */
static const hammer::ast::expression*
expression_a(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::feature* feature28;
    #undef	RETURN_TYPE_feature28
    #define	RETURN_TYPE_feature28 const hammer::ast::feature*

    const hammer::ast::expression* condition29;
    #undef	RETURN_TYPE_condition29
    #define	RETURN_TYPE_condition29 const hammer::ast::expression*

    /* Initialize rule variables
     */


    feature28 = NULL;
    condition29 = NULL;

    {
        {
            //  hammer_sema_v2.gt:87:2: ( feature | condition )
            
            ANTLR3_UINT32 alt10;

            alt10=2;


            {
                int LA10_0 = LA(1);
                if ( (LA10_0 == Feature) ) 
                {
                    alt10=1;
                }
                else if ( (LA10_0 == Condition) ) 
                {
                    alt10=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 10;
                    EXCEPTION->state        = 0;


                    goto ruleexpression_aEx;
                }
            }
            switch (alt10) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:87:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_expression_a496);
        	        feature28=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpression_aEx;
        	        }

        	        {
        	             result = feature28; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:88:4: condition
        	    {
        	        FOLLOWPUSH(FOLLOW_condition_in_expression_a503);
        	        condition29=condition(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpression_aEx;
        	        }

        	        {
        	             result = condition29; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpression_aEx; /* Prevent compiler warnings */
    ruleexpression_aEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end expression_a */

/** 
 * $ANTLR start path
 * hammer_sema_v2.gt:90:1: path returns [const hammer::ast::path* result] : ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? ) ;
 */
static const hammer::ast::path*
path(phammer_sema_v2 ctx)
{   
    const hammer::ast::path* result = NULL;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
            hammer::parscore::token root_name, trailing_slash; 
    {
        // hammer_sema_v2.gt:93:2: ( ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? ) )
        // hammer_sema_v2.gt:93:4: ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? )
        {
             MATCHT(Path, &FOLLOW_Path_in_path525); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            // hammer_sema_v2.gt:93:11: ( path_root_name[root_name] )?
            {
                int alt11=2;
                {
                    int LA11_0 = LA(1);
                    if ( (LA11_0 == PathRootName) ) 
                    {
                        alt11=1;
                    }
                }
                switch (alt11) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:93:11: path_root_name[root_name]
            	    {
            	        FOLLOWPUSH(FOLLOW_path_root_name_in_path527);
            	        path_root_name(ctx, root_name);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepathEx;
            	        }


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_path_elements_in_path531);
            path_elements(ctx, elements);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            // hammer_sema_v2.gt:93:62: ( path_trailing_slash[trailing_slash] )?
            {
                int alt12=2;
                {
                    int LA12_0 = LA(1);
                    if ( (LA12_0 == PathTrailingSlash) ) 
                    {
                        alt12=1;
                    }
                }
                switch (alt12) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:93:62: path_trailing_slash[trailing_slash]
            	    {
            	        FOLLOWPUSH(FOLLOW_path_trailing_slash_in_path534);
            	        path_trailing_slash(ctx, trailing_slash);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepathEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }

            {
                 result = SEMA->on_path(root_name, elements, trailing_slash); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepathEx; /* Prevent compiler warnings */
    rulepathEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end path */

/** 
 * $ANTLR start path_root_name
 * hammer_sema_v2.gt:95:1: path_root_name[hammer::parscore::token& root_name] : PathRootName ;
 */
static void
path_root_name(phammer_sema_v2 ctx, hammer::parscore::token& root_name)
{   
    pANTLR3_BASE_TREE    PathRootName30;

    /* Initialize rule variables
     */


    PathRootName30       = NULL;

    {
        // hammer_sema_v2.gt:96:2: ( PathRootName )
        // hammer_sema_v2.gt:96:4: PathRootName
        {
            PathRootName30 = (pANTLR3_BASE_TREE) MATCHT(PathRootName, &FOLLOW_PathRootName_in_path_root_name551); 
            if  (HASEXCEPTION())
            {
                goto rulepath_root_nameEx;
            }

            {
                 root_name = hammer::parscore::token(PathRootName30->getToken(PathRootName30)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_root_nameEx; /* Prevent compiler warnings */
    rulepath_root_nameEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_root_name */

/** 
 * $ANTLR start path_elements
 * hammer_sema_v2.gt:98:1: path_elements[hammer::ast::expressions_t& elements] : ( path_element )+ ;
 */
static void
path_elements(phammer_sema_v2 ctx, hammer::ast::expressions_t& elements)
{   
    const hammer::ast::expression* path_element31;
    #undef	RETURN_TYPE_path_element31
    #define	RETURN_TYPE_path_element31 const hammer::ast::expression*

    /* Initialize rule variables
     */


    path_element31 = NULL;

    {
        // hammer_sema_v2.gt:99:2: ( ( path_element )+ )
        // hammer_sema_v2.gt:99:4: ( path_element )+
        {
            // hammer_sema_v2.gt:99:4: ( path_element )+
            {
                int cnt13=0;

                for (;;)
                {
                    int alt13=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA13_0 = LA(1);
            	    if ( (LA13_0 == Wildcard || LA13_0 == Id) ) 
            	    {
            	        alt13=1;
            	    }

            	}
            	switch (alt13) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:99:5: path_element
            	        {
            	            FOLLOWPUSH(FOLLOW_path_element_in_path_elements565);
            	            path_element31=path_element(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepath_elementsEx;
            	            }

            	            {
            	                 elements.push_back(path_element31); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt13 >= 1 )
            		{
            		    goto loop13;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepath_elementsEx;
            	}
            	cnt13++;
                }
                loop13: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_elementsEx; /* Prevent compiler warnings */
    rulepath_elementsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_elements */

/** 
 * $ANTLR start path_element
 * hammer_sema_v2.gt:101:1: path_element returns [const hammer::ast::expression* result] : ( Id | wildcard );
 */
static const hammer::ast::expression*
path_element(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id32;
    const hammer::ast::expression* wildcard33;
    #undef	RETURN_TYPE_wildcard33
    #define	RETURN_TYPE_wildcard33 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id32       = NULL;
    wildcard33 = NULL;

    {
        {
            //  hammer_sema_v2.gt:102:2: ( Id | wildcard )
            
            ANTLR3_UINT32 alt14;

            alt14=2;


            {
                int LA14_0 = LA(1);
                if ( (LA14_0 == Id) ) 
                {
                    alt14=1;
                }
                else if ( (LA14_0 == Wildcard) ) 
                {
                    alt14=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulepath_elementEx;
                }
            }
            switch (alt14) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:102:4: Id
        	    {
        	        Id32 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_path_element582); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepath_elementEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id32->getToken(Id32)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:103:4: wildcard
        	    {
        	        FOLLOWPUSH(FOLLOW_wildcard_in_path_element589);
        	        wildcard33=wildcard(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepath_elementEx;
        	        }

        	        {
        	             result = wildcard33; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_elementEx; /* Prevent compiler warnings */
    rulepath_elementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end path_element */

/** 
 * $ANTLR start path_trailing_slash
 * hammer_sema_v2.gt:105:1: path_trailing_slash[hammer::parscore::token& trailing_slash] : PathTrailingSlash ;
 */
static void
path_trailing_slash(phammer_sema_v2 ctx, hammer::parscore::token& trailing_slash)
{   
    pANTLR3_BASE_TREE    PathTrailingSlash34;

    /* Initialize rule variables
     */


    PathTrailingSlash34       = NULL;

    {
        // hammer_sema_v2.gt:106:2: ( PathTrailingSlash )
        // hammer_sema_v2.gt:106:4: PathTrailingSlash
        {
            PathTrailingSlash34 = (pANTLR3_BASE_TREE) MATCHT(PathTrailingSlash, &FOLLOW_PathTrailingSlash_in_path_trailing_slash602); 
            if  (HASEXCEPTION())
            {
                goto rulepath_trailing_slashEx;
            }

            {
                 trailing_slash = hammer::parscore::token(PathTrailingSlash34->getToken(PathTrailingSlash34)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_trailing_slashEx; /* Prevent compiler warnings */
    rulepath_trailing_slashEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_trailing_slash */

/** 
 * $ANTLR start wildcard
 * hammer_sema_v2.gt:108:1: wildcard returns [const hammer::ast::expression* result] : ^( Wildcard ( wildcard_elem )+ ) ;
 */
static const hammer::ast::expression*
wildcard(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* wildcard_elem35;
    #undef	RETURN_TYPE_wildcard_elem35
    #define	RETURN_TYPE_wildcard_elem35 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
    wildcard_elem35 = NULL;

    {
        // hammer_sema_v2.gt:110:2: ( ^( Wildcard ( wildcard_elem )+ ) )
        // hammer_sema_v2.gt:110:4: ^( Wildcard ( wildcard_elem )+ )
        {
             MATCHT(Wildcard, &FOLLOW_Wildcard_in_wildcard623); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }

            // hammer_sema_v2.gt:110:15: ( wildcard_elem )+
            {
                int cnt15=0;

                for (;;)
                {
                    int alt15=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA15_0 = LA(1);
            	    if ( (LA15_0 == Id || ((LA15_0 >= QuestionMark) && (LA15_0 <= Asterix))) ) 
            	    {
            	        alt15=1;
            	    }

            	}
            	switch (alt15) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:110:16: wildcard_elem
            	        {
            	            FOLLOWPUSH(FOLLOW_wildcard_elem_in_wildcard626);
            	            wildcard_elem35=wildcard_elem(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewildcardEx;
            	            }

            	            {
            	                 elements.push_back(wildcard_elem35); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt15 >= 1 )
            		{
            		    goto loop15;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulewildcardEx;
            	}
            	cnt15++;
                }
                loop15: ;	/* Jump to here if this rule does not match */
            }
            {
                 result = SEMA->on_list_of(elements); 
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewildcardEx; /* Prevent compiler warnings */
    rulewildcardEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end wildcard */

/** 
 * $ANTLR start wildcard_elem
 * hammer_sema_v2.gt:113:1: wildcard_elem returns [const hammer::ast::expression* result] : ( Id | QuestionMark | Asterix );
 */
static const hammer::ast::expression*
wildcard_elem(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id36;
    pANTLR3_BASE_TREE    QuestionMark37;
    pANTLR3_BASE_TREE    Asterix38;

    /* Initialize rule variables
     */


    Id36       = NULL;
    QuestionMark37       = NULL;
    Asterix38       = NULL;

    {
        {
            //  hammer_sema_v2.gt:114:2: ( Id | QuestionMark | Asterix )
            
            ANTLR3_UINT32 alt16;

            alt16=3;

            switch ( LA(1) ) 
            {
            case Id:
            	{
            		alt16=1;
            	}
                break;
            case QuestionMark:
            	{
            		alt16=2;
            	}
                break;
            case Asterix:
            	{
            		alt16=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto rulewildcard_elemEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:114:4: Id
        	    {
        	        Id36 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_wildcard_elem648); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id36->getToken(Id36)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:115:4: QuestionMark
        	    {
        	        QuestionMark37 = (pANTLR3_BASE_TREE) MATCHT(QuestionMark, &FOLLOW_QuestionMark_in_wildcard_elem655); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(QuestionMark37->getToken(QuestionMark37)); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:116:4: Asterix
        	    {
        	        Asterix38 = (pANTLR3_BASE_TREE) MATCHT(Asterix, &FOLLOW_Asterix_in_wildcard_elem662); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(Asterix38->getToken(Asterix38)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulewildcard_elemEx; /* Prevent compiler warnings */
    rulewildcard_elemEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end wildcard_elem */

/** 
 * $ANTLR start public_tag
 * hammer_sema_v2.gt:119:1: public_tag[hammer::parscore::source_location* tag_loc] : PublicTag ;
 */
static void
public_tag(phammer_sema_v2 ctx, hammer::parscore::source_location* tag_loc)
{   
    pANTLR3_BASE_TREE    PublicTag39;

    /* Initialize rule variables
     */


    PublicTag39       = NULL;

    {
        // hammer_sema_v2.gt:120:2: ( PublicTag )
        // hammer_sema_v2.gt:120:4: PublicTag
        {
            PublicTag39 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_public_tag677); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_tagEx;
            }

            {
                 *tag_loc = hammer::parscore::source_location(PublicTag39->getToken(PublicTag39)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepublic_tagEx; /* Prevent compiler warnings */
    rulepublic_tagEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end public_tag */

/** 
 * $ANTLR start rule_invocation
 * hammer_sema_v2.gt:123:1: rule_invocation returns [const hammer::ast::expression* result] : ^( RuleInvocation name= Id arguments[&args] ) ;
 */
static const hammer::ast::expression*
rule_invocation(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
    name       = NULL;

    {
        // hammer_sema_v2.gt:125:2: ( ^( RuleInvocation name= Id arguments[&args] ) )
        // hammer_sema_v2.gt:125:4: ^( RuleInvocation name= Id arguments[&args] )
        {
             MATCHT(RuleInvocation, &FOLLOW_RuleInvocation_in_rule_invocation700); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_rule_invocation704); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            FOLLOWPUSH(FOLLOW_arguments_in_rule_invocation706);
            arguments(ctx, &args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            {
                 result = SEMA->on_rule_invocation(name->getToken(name), args); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerule_invocationEx; /* Prevent compiler warnings */
    rulerule_invocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end rule_invocation */

/** 
 * $ANTLR start struct_
 * hammer_sema_v2.gt:127:1: struct_ returns [const hammer::ast::expression* result] : ^( Structure ( struct_field )* ) ;
 */
static const hammer::ast::expression*
struct_(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Structure41;
    const hammer::ast::expression* struct_field40;
    #undef	RETURN_TYPE_struct_field40
    #define	RETURN_TYPE_struct_field40 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, fields); 
            hammer::parscore::source_location start_brace;

    Structure41       = NULL;
    struct_field40 = NULL;

    {
        // hammer_sema_v2.gt:131:2: ( ^( Structure ( struct_field )* ) )
        // hammer_sema_v2.gt:131:4: ^( Structure ( struct_field )* )
        {
            Structure41 = (pANTLR3_BASE_TREE) MATCHT(Structure, &FOLLOW_Structure_in_struct_729); 
            if  (HASEXCEPTION())
            {
                goto rulestruct_Ex;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulestruct_Ex;
                }


                // hammer_sema_v2.gt:131:16: ( struct_field )*

                for (;;)
                {
                    int alt17=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA17_0 = LA(1);
                        if ( (((LA17_0 >= Structure) && (LA17_0 <= Path)) || LA17_0 == TargetRef || ((LA17_0 >= Id) && (LA17_0 <= PublicTag))) ) 
                        {
                            alt17=1;
                        }

                    }
                    switch (alt17) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:131:17: struct_field
                	    {
                	        FOLLOWPUSH(FOLLOW_struct_field_in_struct_732);
                	        struct_field40=struct_field(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulestruct_Ex;
                	        }

                	        {
                	             fields.push_back(struct_field40); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop17;	/* break out of the loop */
                	    break;
                    }
                }
                loop17: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulestruct_Ex;
                }

            }
            {
                 result = SEMA->on_struct(Structure41->getToken(Structure41), fields); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestruct_Ex; /* Prevent compiler warnings */
    rulestruct_Ex: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end struct_ */

/** 
 * $ANTLR start struct_field
 * hammer_sema_v2.gt:133:1: struct_field returns [const hammer::ast::expression* result] : ( EmptyField | named_field | expression );
 */
static const hammer::ast::expression*
struct_field(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    EmptyField42;
    const hammer::ast::expression* named_field43;
    #undef	RETURN_TYPE_named_field43
    #define	RETURN_TYPE_named_field43 const hammer::ast::expression*

    const hammer::ast::expression* expression44;
    #undef	RETURN_TYPE_expression44
    #define	RETURN_TYPE_expression44 const hammer::ast::expression*

    /* Initialize rule variables
     */


    EmptyField42       = NULL;
    named_field43 = NULL;
    expression44 = NULL;

    {
        {
            //  hammer_sema_v2.gt:134:2: ( EmptyField | named_field | expression )
            
            ANTLR3_UINT32 alt18;

            alt18=3;

            switch ( LA(1) ) 
            {
            case EmptyField:
            	{
            		alt18=1;
            	}
                break;
            case NamedField:
            	{
            		alt18=2;
            	}
                break;
            case Structure:
            case List:
            case Feature:
            case Condition:
            case RuleInvocation:
            case Path:
            case TargetRef:
            case Id:
            case PublicTag:
            	{
            		alt18=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto rulestruct_fieldEx;
            }

            switch (alt18) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:134:4: EmptyField
        	    {
        	        EmptyField42 = (pANTLR3_BASE_TREE) MATCHT(EmptyField, &FOLLOW_EmptyField_in_struct_field753); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestruct_fieldEx;
        	        }

        	        {
        	             result = SEMA->on_empty_expr(EmptyField42->getToken(EmptyField42)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:135:4: named_field
        	    {
        	        FOLLOWPUSH(FOLLOW_named_field_in_struct_field760);
        	        named_field43=named_field(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestruct_fieldEx;
        	        }

        	        {
        	             result = named_field43; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:136:4: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_struct_field767);
        	        expression44=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestruct_fieldEx;
        	        }

        	        {
        	             result = expression44; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestruct_fieldEx; /* Prevent compiler warnings */
    rulestruct_fieldEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end struct_field */

/** 
 * $ANTLR start named_field
 * hammer_sema_v2.gt:138:1: named_field returns [const hammer::ast::expression* result] : ( ^( NamedField Id expression ) | ^( NamedField Id EmptyField ) );
 */
static const hammer::ast::expression*
named_field(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id45;
    pANTLR3_BASE_TREE    Id47;
    pANTLR3_BASE_TREE    EmptyField48;
    const hammer::ast::expression* expression46;
    #undef	RETURN_TYPE_expression46
    #define	RETURN_TYPE_expression46 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id45       = NULL;
    Id47       = NULL;
    EmptyField48       = NULL;
    expression46 = NULL;

    {
        {
            //  hammer_sema_v2.gt:139:2: ( ^( NamedField Id expression ) | ^( NamedField Id EmptyField ) )
            
            ANTLR3_UINT32 alt19;

            alt19=2;


            {
                int LA19_0 = LA(1);
                if ( (LA19_0 == NamedField) ) 
                {

                    {
                        int LA19_1 = LA(2);
                        if ( (LA19_1 == DOWN) ) 
                        {

                            {
                                int LA19_2 = LA(3);
                                if ( (LA19_2 == Id) ) 
                                {

                                    {
                                        int LA19_3 = LA(4);
                                        if ( (LA19_3 == EmptyField) ) 
                                        {
                                            alt19=2;
                                        }
                                        else if ( (LA19_3 == Structure || ((LA19_3 >= List) && (LA19_3 <= Path)) || LA19_3 == TargetRef || ((LA19_3 >= Id) && (LA19_3 <= PublicTag))) ) 
                                        {
                                            alt19=1;
                                        }
                                        else 
                                        {
                                        
                                            CONSTRUCTEX();
                                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            EXCEPTION->message      = (void *)"";
                                            EXCEPTION->decisionNum  = 19;
                                            EXCEPTION->state        = 3;


                                            goto rulenamed_fieldEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 19;
                                    EXCEPTION->state        = 2;


                                    goto rulenamed_fieldEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 19;
                            EXCEPTION->state        = 1;


                            goto rulenamed_fieldEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 19;
                    EXCEPTION->state        = 0;


                    goto rulenamed_fieldEx;
                }
            }
            switch (alt19) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:139:4: ^( NamedField Id expression )
        	    {
        	         MATCHT(NamedField, &FOLLOW_NamedField_in_named_field783); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        Id45 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_field785); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_named_field787);
        	        expression46=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id45->getToken(Id45), expression46); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:140:4: ^( NamedField Id EmptyField )
        	    {
        	         MATCHT(NamedField, &FOLLOW_NamedField_in_named_field797); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        Id47 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_field799); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        EmptyField48 = (pANTLR3_BASE_TREE) MATCHT(EmptyField, &FOLLOW_EmptyField_in_named_field801); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id47->getToken(Id47), SEMA->on_empty_expr(EmptyField48->getToken(EmptyField48))); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenamed_fieldEx; /* Prevent compiler warnings */
    rulenamed_fieldEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end named_field */

/** 
 * $ANTLR start feature
 * hammer_sema_v2.gt:142:1: feature returns [const hammer::ast::feature* result] : ^( Feature Id feature_value ) ;
 */
static const hammer::ast::feature*
feature(phammer_sema_v2 ctx)
{   
    const hammer::ast::feature* result = NULL;

    pANTLR3_BASE_TREE    Id49;
    const hammer::ast::expression* feature_value50;
    #undef	RETURN_TYPE_feature_value50
    #define	RETURN_TYPE_feature_value50 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id49       = NULL;
    feature_value50 = NULL;

    {
        // hammer_sema_v2.gt:143:2: ( ^( Feature Id feature_value ) )
        // hammer_sema_v2.gt:143:4: ^( Feature Id feature_value )
        {
             MATCHT(Feature, &FOLLOW_Feature_in_feature819); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            Id49 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_feature821); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            FOLLOWPUSH(FOLLOW_feature_value_in_feature823);
            feature_value50=feature_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            {
                 result = SEMA->on_feature(Id49->getToken(Id49), feature_value50); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefeatureEx; /* Prevent compiler warnings */
    rulefeatureEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end feature */

/** 
 * $ANTLR start feature_value
 * hammer_sema_v2.gt:146:1: feature_value returns [const hammer::ast::expression* result] : ( Id | path | target_ref );
 */
static const hammer::ast::expression*
feature_value(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id51;
    const hammer::ast::path* path52;
    #undef	RETURN_TYPE_path52
    #define	RETURN_TYPE_path52 const hammer::ast::path*

    const hammer::ast::expression* target_ref53;
    #undef	RETURN_TYPE_target_ref53
    #define	RETURN_TYPE_target_ref53 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id51       = NULL;
    path52 = NULL;
    target_ref53 = NULL;

    {
        {
            //  hammer_sema_v2.gt:147:2: ( Id | path | target_ref )
            
            ANTLR3_UINT32 alt20;

            alt20=3;

            switch ( LA(1) ) 
            {
            case Id:
            	{
            		alt20=1;
            	}
                break;
            case Path:
            	{
            		alt20=2;
            	}
                break;
            case TargetRef:
            case PublicTag:
            	{
            		alt20=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto rulefeature_valueEx;
            }

            switch (alt20) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:147:4: Id
        	    {
        	        Id51 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_feature_value841); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id51->getToken(Id51)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:148:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_feature_value848);
        	        path52=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = path52; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:149:4: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_feature_value855);
        	        target_ref53=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = target_ref53; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulefeature_valueEx; /* Prevent compiler warnings */
    rulefeature_valueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end feature_value */

/** 
 * $ANTLR start target_ref
 * hammer_sema_v2.gt:151:1: target_ref returns [const hammer::ast::expression* result] : ( ^( PublicTag target_ref_impl[&target_name, &build_request] ) | target_ref_impl[&target_name, &build_request] );
 */
static const hammer::ast::expression*
target_ref(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    PublicTag54;
    const hammer::ast::path* target_ref_impl55;
    #undef	RETURN_TYPE_target_ref_impl55
    #define	RETURN_TYPE_target_ref_impl55 const hammer::ast::path*

    const hammer::ast::path* target_ref_impl56;
    #undef	RETURN_TYPE_target_ref_impl56
    #define	RETURN_TYPE_target_ref_impl56 const hammer::ast::path*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::features_t, build_request); 
            hammer::parscore::identifier target_name; 
    PublicTag54       = NULL;
    target_ref_impl55 = NULL;
    target_ref_impl56 = NULL;

    {
        {
            //  hammer_sema_v2.gt:154:2: ( ^( PublicTag target_ref_impl[&target_name, &build_request] ) | target_ref_impl[&target_name, &build_request] )
            
            ANTLR3_UINT32 alt21;

            alt21=2;


            {
                int LA21_0 = LA(1);
                if ( (LA21_0 == PublicTag) ) 
                {
                    alt21=1;
                }
                else if ( (LA21_0 == TargetRef) ) 
                {
                    alt21=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 21;
                    EXCEPTION->state        = 0;


                    goto ruletarget_refEx;
                }
            }
            switch (alt21) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:154:4: ^( PublicTag target_ref_impl[&target_name, &build_request] )
        	    {
        	        PublicTag54 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_target_ref876); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_target_ref_impl_in_target_ref878);
        	        target_ref_impl55=target_ref_impl(ctx, &target_name, &build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        {
        	             result = SEMA->on_target_ref(PublicTag54->getToken(PublicTag54), target_ref_impl55, target_name, build_request); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:155:4: target_ref_impl[&target_name, &build_request]
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_impl_in_target_ref887);
        	        target_ref_impl56=target_ref_impl(ctx, &target_name, &build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        {
        	             result = SEMA->on_target_ref(hammer::parscore::source_location(), target_ref_impl56, target_name, build_request); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_refEx; /* Prevent compiler warnings */
    ruletarget_refEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end target_ref */

/** 
 * $ANTLR start target_ref_impl
 * hammer_sema_v2.gt:158:1: target_ref_impl[hammer::parscore::identifier* target_name, \n\t hammer::ast::features_t* build_request] returns [const hammer::ast::path* result] : ( ^( TargetRef path ( target_ref_spec[target_name, build_request] )? ) | ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? ) );
 */
static const hammer::ast::path*
target_ref_impl(phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request)
{   
    const hammer::ast::path* result = NULL;

    pANTLR3_BASE_TREE    Id58;
    const hammer::ast::path* path57;
    #undef	RETURN_TYPE_path57
    #define	RETURN_TYPE_path57 const hammer::ast::path*

    /* Initialize rule variables
     */


    Id58       = NULL;
    path57 = NULL;

    {
        {
            //  hammer_sema_v2.gt:161:2: ( ^( TargetRef path ( target_ref_spec[target_name, build_request] )? ) | ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? ) )
            
            ANTLR3_UINT32 alt24;

            alt24=2;


            {
                int LA24_0 = LA(1);
                if ( (LA24_0 == TargetRef) ) 
                {

                    {
                        int LA24_1 = LA(2);
                        if ( (LA24_1 == DOWN) ) 
                        {

                            {
                                int LA24_2 = LA(3);
                                if ( (LA24_2 == Id) ) 
                                {
                                    alt24=2;
                                }
                                else if ( (LA24_2 == Path) ) 
                                {
                                    alt24=1;
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 24;
                                    EXCEPTION->state        = 2;


                                    goto ruletarget_ref_implEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 24;
                            EXCEPTION->state        = 1;


                            goto ruletarget_ref_implEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 24;
                    EXCEPTION->state        = 0;


                    goto ruletarget_ref_implEx;
                }
            }
            switch (alt24) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:161:4: ^( TargetRef path ( target_ref_spec[target_name, build_request] )? )
        	    {
        	         MATCHT(TargetRef, &FOLLOW_TargetRef_in_target_ref_impl906); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_path_in_target_ref_impl908);
        	        path57=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        // hammer_sema_v2.gt:161:21: ( target_ref_spec[target_name, build_request] )?
        	        {
        	            int alt22=2;
        	            {
        	                int LA22_0 = LA(1);
        	                if ( (LA22_0 == TargetRefSpec) ) 
        	                {
        	                    alt22=1;
        	                }
        	            }
        	            switch (alt22) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:161:21: target_ref_spec[target_name, build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_spec_in_target_ref_impl910);
        	        	        target_ref_spec(ctx, target_name, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_implEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        {
        	             result = path57; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:162:4: ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? )
        	    {
        	         MATCHT(TargetRef, &FOLLOW_TargetRef_in_target_ref_impl921); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        Id58 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_target_ref_impl923); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        // hammer_sema_v2.gt:162:19: ( target_ref_spec[target_name, build_request] )?
        	        {
        	            int alt23=2;
        	            {
        	                int LA23_0 = LA(1);
        	                if ( (LA23_0 == TargetRefSpec) ) 
        	                {
        	                    alt23=1;
        	                }
        	            }
        	            switch (alt23) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:162:19: target_ref_spec[target_name, build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_spec_in_target_ref_impl925);
        	        	        target_ref_spec(ctx, target_name, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_implEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        {
        	             DECLARE_TYPE(hammer::ast::expressions_t, elements); elements.push_back(SEMA->on_id(Id58->getToken(Id58))); result = SEMA->on_path({}, elements, {}); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_implEx; /* Prevent compiler warnings */
    ruletarget_ref_implEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end target_ref_impl */

/** 
 * $ANTLR start target_ref_spec
 * hammer_sema_v2.gt:165:1: target_ref_spec[hammer::parscore::identifier* target_name, \n\t hammer::ast::features_t* build_request] : ( ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? ) | ^( TargetRefSpec target_ref_build_request[build_request] ) );
 */
static void
target_ref_spec(phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request)
{   
    pANTLR3_BASE_TREE    Id59;

    /* Initialize rule variables
     */


    Id59       = NULL;

    {
        {
            //  hammer_sema_v2.gt:167:2: ( ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? ) | ^( TargetRefSpec target_ref_build_request[build_request] ) )
            
            ANTLR3_UINT32 alt26;

            alt26=2;


            {
                int LA26_0 = LA(1);
                if ( (LA26_0 == TargetRefSpec) ) 
                {

                    {
                        int LA26_1 = LA(2);
                        if ( (LA26_1 == DOWN) ) 
                        {

                            {
                                int LA26_2 = LA(3);
                                if ( (LA26_2 == Id) ) 
                                {
                                    alt26=1;
                                }
                                else if ( (LA26_2 == TargetRefBuildRequest) ) 
                                {
                                    alt26=2;
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 26;
                                    EXCEPTION->state        = 2;


                                    goto ruletarget_ref_specEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 26;
                            EXCEPTION->state        = 1;


                            goto ruletarget_ref_specEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 26;
                    EXCEPTION->state        = 0;


                    goto ruletarget_ref_specEx;
                }
            }
            switch (alt26) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:167:4: ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? )
        	    {
        	         MATCHT(TargetRefSpec, &FOLLOW_TargetRefSpec_in_target_ref_spec944); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        Id59 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_target_ref_spec946); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        // hammer_sema_v2.gt:167:23: ( target_ref_build_request[build_request] )?
        	        {
        	            int alt25=2;
        	            {
        	                int LA25_0 = LA(1);
        	                if ( (LA25_0 == TargetRefBuildRequest) ) 
        	                {
        	                    alt25=1;
        	                }
        	            }
        	            switch (alt25) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:167:23: target_ref_build_request[build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_build_request_in_target_ref_spec948);
        	        	        target_ref_build_request(ctx, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_specEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        {
        	             *target_name = hammer::parscore::identifier(Id59->getToken(Id59)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:168:4: ^( TargetRefSpec target_ref_build_request[build_request] )
        	    {
        	         MATCHT(TargetRefSpec, &FOLLOW_TargetRefSpec_in_target_ref_spec959); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_target_ref_build_request_in_target_ref_spec961);
        	        target_ref_build_request(ctx, build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_specEx; /* Prevent compiler warnings */
    ruletarget_ref_specEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_ref_spec */

/** 
 * $ANTLR start target_ref_build_request
 * hammer_sema_v2.gt:170:1: target_ref_build_request[hammer::ast::features_t* build_request] : ^( TargetRefBuildRequest ( feature )+ ) ;
 */
static void
target_ref_build_request(phammer_sema_v2 ctx, hammer::ast::features_t* build_request)
{   
    const hammer::ast::feature* feature60;
    #undef	RETURN_TYPE_feature60
    #define	RETURN_TYPE_feature60 const hammer::ast::feature*

    /* Initialize rule variables
     */


    feature60 = NULL;

    {
        // hammer_sema_v2.gt:171:2: ( ^( TargetRefBuildRequest ( feature )+ ) )
        // hammer_sema_v2.gt:171:4: ^( TargetRefBuildRequest ( feature )+ )
        {
             MATCHT(TargetRefBuildRequest, &FOLLOW_TargetRefBuildRequest_in_target_ref_build_request976); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }

            // hammer_sema_v2.gt:171:28: ( feature )+
            {
                int cnt27=0;

                for (;;)
                {
                    int alt27=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA27_0 = LA(1);
            	    if ( (LA27_0 == Feature) ) 
            	    {
            	        alt27=1;
            	    }

            	}
            	switch (alt27) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:171:29: feature
            	        {
            	            FOLLOWPUSH(FOLLOW_feature_in_target_ref_build_request979);
            	            feature60=feature(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletarget_ref_build_requestEx;
            	            }

            	            {
            	                 build_request->push_back(feature60); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt27 >= 1 )
            		{
            		    goto loop27;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletarget_ref_build_requestEx;
            	}
            	cnt27++;
                }
                loop27: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_build_requestEx; /* Prevent compiler warnings */
    ruletarget_ref_build_requestEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_ref_build_request */

/** 
 * $ANTLR start condition
 * hammer_sema_v2.gt:173:1: condition returns [const hammer::ast::expression* result] : ^( Condition condition_condition condition_result ) ;
 */
static const hammer::ast::expression*
condition(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* condition_condition61;
    #undef	RETURN_TYPE_condition_condition61
    #define	RETURN_TYPE_condition_condition61 const hammer::ast::expression*

    const hammer::ast::expression* condition_result62;
    #undef	RETURN_TYPE_condition_result62
    #define	RETURN_TYPE_condition_result62 const hammer::ast::expression*

    /* Initialize rule variables
     */


    condition_condition61 = NULL;
    condition_result62 = NULL;

    {
        // hammer_sema_v2.gt:174:2: ( ^( Condition condition_condition condition_result ) )
        // hammer_sema_v2.gt:174:4: ^( Condition condition_condition condition_result )
        {
             MATCHT(Condition, &FOLLOW_Condition_in_condition999); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_condition1001);
            condition_condition61=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            FOLLOWPUSH(FOLLOW_condition_result_in_condition1003);
            condition_result62=condition_result(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            {
                 result = SEMA->on_condition(condition_condition61, condition_result62); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconditionEx; /* Prevent compiler warnings */
    ruleconditionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition */

/** 
 * $ANTLR start condition_condition
 * hammer_sema_v2.gt:176:1: condition_condition returns [const hammer::ast::expression* result] : ( feature | logical_or | logical_and );
 */
static const hammer::ast::expression*
condition_condition(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::feature* feature63;
    #undef	RETURN_TYPE_feature63
    #define	RETURN_TYPE_feature63 const hammer::ast::feature*

    const hammer::ast::expression* logical_or64;
    #undef	RETURN_TYPE_logical_or64
    #define	RETURN_TYPE_logical_or64 const hammer::ast::expression*

    const hammer::ast::expression* logical_and65;
    #undef	RETURN_TYPE_logical_and65
    #define	RETURN_TYPE_logical_and65 const hammer::ast::expression*

    /* Initialize rule variables
     */


    feature63 = NULL;
    logical_or64 = NULL;
    logical_and65 = NULL;

    {
        {
            //  hammer_sema_v2.gt:177:2: ( feature | logical_or | logical_and )
            
            ANTLR3_UINT32 alt28;

            alt28=3;

            switch ( LA(1) ) 
            {
            case Feature:
            	{
            		alt28=1;
            	}
                break;
            case LogicalOr:
            	{
            		alt28=2;
            	}
                break;
            case LogicalAnd:
            	{
            		alt28=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto rulecondition_conditionEx;
            }

            switch (alt28) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:177:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_condition_condition1020);
        	        feature63=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = feature63; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:178:4: logical_or
        	    {
        	        FOLLOWPUSH(FOLLOW_logical_or_in_condition_condition1027);
        	        logical_or64=logical_or(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = logical_or64; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:179:4: logical_and
        	    {
        	        FOLLOWPUSH(FOLLOW_logical_and_in_condition_condition1034);
        	        logical_and65=logical_and(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = logical_and65; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecondition_conditionEx; /* Prevent compiler warnings */
    rulecondition_conditionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition_condition */

/** 
 * $ANTLR start condition_result
 * hammer_sema_v2.gt:181:1: condition_result returns [const hammer::ast::expression* result] : ( public_expression | feature | list_of[&elements] );
 */
static const hammer::ast::expression*
condition_result(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* public_expression66;
    #undef	RETURN_TYPE_public_expression66
    #define	RETURN_TYPE_public_expression66 const hammer::ast::expression*

    const hammer::ast::feature* feature67;
    #undef	RETURN_TYPE_feature67
    #define	RETURN_TYPE_feature67 const hammer::ast::feature*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
    public_expression66 = NULL;
    feature67 = NULL;

    {
        {
            //  hammer_sema_v2.gt:183:2: ( public_expression | feature | list_of[&elements] )
            
            ANTLR3_UINT32 alt29;

            alt29=3;

            switch ( LA(1) ) 
            {
            case PublicTag:
            	{
            		alt29=1;
            	}
                break;
            case Feature:
            	{
            		alt29=2;
            	}
                break;
            case List:
            	{
            		alt29=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto rulecondition_resultEx;
            }

            switch (alt29) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:183:4: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_condition_result1054);
        	        public_expression66=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = public_expression66; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:184:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_condition_result1062);
        	        feature67=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = feature67; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:185:4: list_of[&elements]
        	    {
        	        FOLLOWPUSH(FOLLOW_list_of_in_condition_result1069);
        	        list_of(ctx, &elements);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = SEMA->on_list_of(elements); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecondition_resultEx; /* Prevent compiler warnings */
    rulecondition_resultEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition_result */

/** 
 * $ANTLR start logical_or
 * hammer_sema_v2.gt:187:1: logical_or returns [const hammer::ast::expression* result] : ^( LogicalOr left= condition_condition right= condition_condition ) ;
 */
static const hammer::ast::expression*
logical_or(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* left;
    #undef	RETURN_TYPE_left
    #define	RETURN_TYPE_left const hammer::ast::expression*

    const hammer::ast::expression* right;
    #undef	RETURN_TYPE_right
    #define	RETURN_TYPE_right const hammer::ast::expression*

    /* Initialize rule variables
     */


    left = NULL;
    right = NULL;

    {
        // hammer_sema_v2.gt:188:2: ( ^( LogicalOr left= condition_condition right= condition_condition ) )
        // hammer_sema_v2.gt:188:4: ^( LogicalOr left= condition_condition right= condition_condition )
        {
             MATCHT(LogicalOr, &FOLLOW_LogicalOr_in_logical_or1087); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_or1091);
            left=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_or1095);
            right=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            {
                 result = SEMA->on_logical_or(left, right); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelogical_orEx; /* Prevent compiler warnings */
    rulelogical_orEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end logical_or */

/** 
 * $ANTLR start logical_and
 * hammer_sema_v2.gt:190:1: logical_and returns [const hammer::ast::expression* result] : ^( LogicalAnd left= condition_condition right= condition_condition ) ;
 */
static const hammer::ast::expression*
logical_and(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* left;
    #undef	RETURN_TYPE_left
    #define	RETURN_TYPE_left const hammer::ast::expression*

    const hammer::ast::expression* right;
    #undef	RETURN_TYPE_right
    #define	RETURN_TYPE_right const hammer::ast::expression*

    /* Initialize rule variables
     */


    left = NULL;
    right = NULL;

    {
        // hammer_sema_v2.gt:191:2: ( ^( LogicalAnd left= condition_condition right= condition_condition ) )
        // hammer_sema_v2.gt:191:4: ^( LogicalAnd left= condition_condition right= condition_condition )
        {
             MATCHT(LogicalAnd, &FOLLOW_LogicalAnd_in_logical_and1113); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_and1117);
            left=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_and1121);
            right=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            {
                 result = SEMA->on_logical_and(left, right); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelogical_andEx; /* Prevent compiler warnings */
    rulelogical_andEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end logical_and */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
