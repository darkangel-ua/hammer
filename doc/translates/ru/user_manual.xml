<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<book lang="en">
  <title>Hammer. Руководство пользователя</title>
  <chapter>
    <title>Вступление</title>
    <section>
      <title>Что такое Hammer?</title>
      <para>Hammer это кроссплатформенная консольная утилита для автоматизации сборки проектов. Ее самый близкий аналог - boost jam (bjam) - билдовая среда для boost&apos;a. </para>
      <remark> TODO </remark>
    </section>
    <section>
      <title>Предистория Hammer&apos;a</title>
      <para>История Hammer&apos;a началась в 2008 году, когда Костика в доску заебала долгая раздупляемость Jam&apos;a в больших проектах и невозможность управлять различными версиями библиотек (того же  boost&apos;a) под различные компоненты. Последнего, кстати, не умеет ни одна билдовая система кроме Hammer&apos;е появились в 2007, но первые файлы увидели свет в 2008. В 2009, мае месяце проект был выложен на sourceforge и с тех пор потихоньку себе развивался фактически только Костиком. Но с августа 2009 у   меня наконец-то &quot;дошли руки&quot; к Hammer&apos;у и я начал активно его тестировать под Linux и Windows. Пока поддерживаются только эти платформы, но в скором будущем, надеюсь добавим остальные :) .</para>
      <remark> TODO </remark>
    </section>
    <section>
      <title>Что умеет Hammer?</title>
      <para>Hammer умеет следующие вещи: </para>
      <para>реализована поддержка компиляторов msvc (8.0, надо еще 6.0, 7.0, 7.1, 9.0); gcc 3.x.x &amp; 4.x.x. Хотелось бы Intel, Comeau, Watcom, Borland, Digital Mars, CodeWarrior, IBM, QNX, SUN, HP, Darwin и остальные что есть.</para>
      <para>реализована поддержка OC: Windows (98, 2000, XP, 2003 Server, Vista, 2008 Server, Windows7), Linux (Fedora, openSUSE, Ubuntu, etc), Solaris, QNX, FreeBSD, other UNIX.</para>
      <para>реализована поддержка платформ: x86, x86_64, ARM, PowerPC.</para>
      <para>Также Hammer умеет генерировать проекты для Visual Studio 2003, 2005, 2008; Хотелось бы чтобы умел работать и с Eclipse, NetBeans, CMake, Makefiles, QtCreator.</para>
    </section>
    <section>
      <title>Фичи Hammer&apos;a</title>
      <remark> TODO </remark>
    </section>
  </chapter>
  <chapter>
    <title>Обзор</title>
    <section>
      <title>Размещение в файловой системе</title>
      <para>Предложенный вариант организации рабочего пространства не обязательный, но рекомендуемый для использования. Вы можете организовывать проекты на файловой системе любым способом каким хотите или должны,  но не всегда способы такого расположения могут использовать всю мощь Hammer&apos;a. <remark> TODO: Can you rephrase the sentence, a little hard to grasp. </remark> </para>
      <para>Разработка большого, сложного программного обеспечения с десятками или сотнями компонент не простая задача. Нет единого способа управления всем этим хозяйством и это только усиливает проблемы. <remark> TODO: what? </remark> В  Linux&apos;e вам нужно скачать исходники, распаковать и выполнить  <command>./configure &amp;&amp; make &amp;&amp; make install</command> . В  Windows нет стандартного способа для этого. Способ Linux значительно проще и определеннее, но не идеален. Вы просто так не сможете разрабатывать два различных компонента, зависящих от двух различных версий одной и той же  библиотеки без танцев с бубном.</para>
      <para>Имея одну, простую, унифицированную и легкую для понимания организацию проекта вы очень упрощаете взаимодействие между разработчиками и избавляетесь от ментальных оков, когда нужно писать кросс-платформенный код.</para>
      <para>Незакончено!</para>
    </section>
    <section>
      <title>Скриптовый язык Hammer&apos;a</title>
      <para>На данный момент скриптовый язык hammer&apos;a  очень похож на  язык perforce Jam но без контроля выражений <remark>допереводить!</remark>Только правила заимствованы.   Правила выглядят как вызов функции и в большинстве случаев носят декларативный характер и очень далеки от реального вызова функции. Базовый синтаксис выглядит следующим оразом.:</para>
      <programlisting>rule-name argument_1 : argument_2 : ... : argument_N ;</programlisting>
      <para>Каждый аргумент это список строк разделенных  <emphasis>пробелом</emphasis>, который может быть нулевой длинны. Символ  &apos;:&apos; используется для разделения аргументов, а  &apos;;&apos; закрывает выражение.</para>
      <note>
        <para>Обратите внимание, что в связи с некторыми  лексическими проблемами, реальный разделитель между аргументами выглядит как &lt;пробел&gt;&lt;двоеточие&gt;&lt;пробел&gt;&apos;, а  не  просто &apos;&lt;пробел&gt;&apos;. </para>
      </note>
      <para>Примеры:</para>
      <programlisting>exe test : main.cpp ;</programlisting>
      <para>здесь мы имеем правило именуемое <code>exe</code>, с первым аргументом <code>test</code>, и вторым аргументом <code>main.cpp</code> .</para>
      <para><programlisting>lib iconv : : &lt;name&gt;iconv &lt;toolset&gt;gcc ;</programlisting>здесь мы имеем правило именуемое <code>lib</code>, с первым аргументом  <code>iconv</code>, пустым вторым аргументом, и третим аргументом  <code>&lt;name&gt;iconv &lt;toolset&gt;gcc</code>.</para>
    </section>
    <section>
      <title>Проекты</title>
      <section>
        <title>Основы</title>
        <para>Для управления сложностью в разработке ПО мы делим ПО на части - библиотеки. Это делает жизнь значительно проще. Бибилотеки обычно собираются из исходников, подключаемых файлов, документации и тестов. Исходники могут быть собраны в библиотеку, документы могут быть собраны из  DocBook в HTML, тесты моут быть собраны и запущены. </para>
        <para>Hammer&apos;s <emphasis>project</emphasis> это просто файл. Он содержит таргеты, которые можно собирать, или описание структуры и свойств проекта, или и то и другое.  Для представления сказанного рассмотрим пример:</para>
        <graphic fileref="../../common/images/project-layout.png" align="center"/>
        <para>Тут у нас маленький кусочек  библиотеки boost приведенной к модулярному виду. Проект  <filename>boost/hamfile</filename> не содержит таргетов для сборки. Он только указывает  hammer&apos;y где искать под-проекты boost&apos;a:</para>
        <programlisting>...
use-project filesystem : filesystem ;
use-project thread : thread ;
...</programlisting>
        <para>Проект <filename>boost/filesystem/hamfile</filename>:</para>
        <programlisting>version-alias filesystem : trunc ;</programlisting>
        <para>уже содержит таргеты, но <code>version-alias</code> это не совсем настоящий  таргет - мы объясним это позже.<remark>где, блять, это обьяснение? нету нифига!</remark> И, наконец,  <filename>boost/filesystem/trunc/build/hamfile</filename> содержит таргет для сборки<code>boost.filesystem</code>:</para>
        <programlisting>lib boost.filesystem
    :
     @/boost/core/&lt;version&gt;1.36.0
     [ glob ../src/*.cpp ]
     @/boost/system/&lt;version&gt;1.36.0
     @/boost/iterator/&lt;version&gt;1.36.0
     @/boost/exception/&lt;version&gt;1.36.0
    :
     &lt;link&gt;shared:&lt;define&gt;BOOST_ALL_DYN_LINK=1 
     &lt;link&gt;static:&lt;define&gt;BOOST_All_STATIC_LINK=1
     @&lt;include&gt;../include
    ;
</programlisting>
        <para>Каждый  Hammer-файл может иметь правило описания проекта в следующей форме:</para>
        <programlisting>project &lt;project-name&gt; : requirements &lt;property-set&gt;
                       : usage-requirements &lt;property-set&gt;
                       ;</programlisting>
        <para>Сейчас <code>&lt;project-name&gt;</code> не несет никакой семантической нагрузки. Ноt <emphasis>requirements</emphasis> и <emphasis>usage-requirements</emphasis> действительно необходимы в сложных проектах с большим количеством библиотек и таргетов. Как будет показано в разделе Таргеты почти все собираемые таргеты имеют  requirements и usage-requirements. Когда  hammer скрипт имеет определение  <code>проекта</code> рядом с другими определениями таргетов, все таргеты будет наследовать  requirements и usage-requirements из определения проекта. Например:<programlisting>project foobar : requirements &lt;define&gt;FOO=1
               : usage-requirements &lt;define&gt;BOO=1
               ;

lib foobar : main.cpp ;
lib barfoo : test.cpp ;</programlisting></para>
        <para>эквивалентно:<programlisting>lib foobar : main.cpp : &lt;define&gt;FOO=1 : : &lt;define&gt;BOO=1 ;
lib barfoo : test.cpp : &lt;define&gt;FOO=1 : : &lt;define&gt;BOO=1 ;</programlisting></para>
      </section>
      <section>
        <title>Наследование проектов</title>
        <para>Так как  Hammer-проекты это просто файлы и организованые в файловой системе иерархическим способом отражая  underlying структуру ПО - мы автоматически получаем иерархию проетов. Смотря на представленную выше иерархию проектов мы видим проект   <code>boost</code> который состоит из <code>boost/filesystem</code> и <code>boost/thread</code> под-проектов. Файловая система проектов состоит из <code>boost.filesystem</code> таргета размещенном в <filename>hammer/filesystem/trunc/build/hamfile</filename> и <code>test</code> таргета, размещенного в  <filename>boost/filesystem/trunc/test/build/hamfile</filename>, который является подпроектом проекта <code>boost/filesystem</code>. </para>
        <para>Обычно проект  <code>boost</code> может иметь некоторые  requirements  и usage requirements которые являются общими для всех под-проектов. Так как каждый подпроект  <emphasis>наследует</emphasis> все requirements и usage requirements от проектов верхних уровней тем же способом, что и таргеты внутри каждого  <filename>hamfile&apos;a</filename>, таргет <code>boost.filesystem</code> в проекте  <filename>boost/filesystem/trunc/build/hamfile</filename> наследует  requirements и usage requirements от  <filename>boost/hamfile</filename> и <filename>boost/filesystem/hamfile</filename> описания проектов.</para>
      </section>
    </section>
    <section>
      <title>Признаки и свойства</title>
      <para>Чтобы портабельно представить аспекты конфигурирования таргетов, такие как  debug и release варианты, или single- и multi-threaded сборки, Hammer использует  <emphasis>признаки</emphasis> с асоциированными <emphasis>значениями</emphasis>. Например, признак  <code>debug-symbols</code> может иметь значение  <code>on</code> или <code>off</code>.  <emphasis>Свойство</emphasis> это просто пара (признак, значение).</para>
      <para>В скрипте свойства  просто размещаются с помощью специального синтаксиса  <code>&lt;имя-признака&gt;значение</code>. Например <code>&lt;link&gt;static</code> - признак <code>link</code> со значением <code>static</code>.<remark> TODO: What links with what? </remark></para>
      <para>Каждый признак имеет множество асоциированных  <emphasis>атрибутов</emphasis>. Атрибуты признака - это низкоуровневые описания как билдовая система должна интерпретировать значения признаков когда они появляются в билд запросе. Мы также ссылаемся на атрибуты свойств, так что  <code>присущие</code> свойства, к примеру, являются одними, чьи признаки имеют <code>присущие</code> атрибуты.</para>
      <para><table>
          <title>Атрибуты признаков</title>
          <tgroup cols="2">
            <colspec colwidth="2.5 cm"/>
            <tbody>
              <row>
                <entry align="center">дополнительный</entry>
                <entry>Дополнительные признаки предполагают неизменность результата сборки в общем. Признак, который управляет уровнем предупреждений компилятора является типичным примером дополнительного признака. Не дополнительные признаки допускают влияние на результат сборки.</entry>
              </row>
              <row>
                <entry align="center">распостраняющийся</entry>
                <entry>Признаки такого рода распостраняются на зависимости. Это означает, что если таргет собран с использованием распостраняемого свойства, билдовая система пытается использовать то же свойство при сборке любых его зависимостей как часть таргета. Например, когда исполняемый файл требует быть собраным msvc-8.0 инструментарием, он обычно линкуется с библиотеками собраными тем же инструментарием. Таким образом признак &lt;toolset&gt; является распостраняющимся.</entry>
              </row>
              <row>
                <entry align="center">свободный</entry>
                <entry>Большинство признаков имеют конечное множество разрешенных атрибутов, и могут принимать только одно значение из этого множества в данной спецификации сборки. Свободные признаки, с другой стороны, могут иметь несколько значений одновременно и каждое значение может быть произвольной строкой. Например, можно одновременно иметь несколько определений для препроцессора: &lt;define&gt;NDEBUG=1 &lt;define&gt;HAS_CONFIG_H=1 </entry>
              </row>
              <row>
                <entry align="center">опциональный</entry>
                <entry>Опциональный атрибут - это атрибут, который не обязателен для сборки. Каждый неопциональный, несвободный признаки и признаки без атрибутов по-умолчанию имеют значения по-умолчанию, которые используются в случае если значение признака неопределено явно ни в реквайрементах таргета, ни в требваниях к сборке, заданных пользователем. </entry>
              </row>
              <row>
                <entry align="center">путь</entry>
                <entry>Значение признака пути определяет путь. The value of a path feature specifies a path. Путь трактуется как относительный к директории с <filename>hamfile</filename>, где признак путь используется и транслируется соответственно билдовой системой, когда сборка запущена из другой директории.</entry>
              </row>
              <row>
                <entry align="center">составной</entry>
                <entry>Составной признак фактически соответствует группам признаков. Например, вариант сборки является составным признаком. Когда генерирутся таргеты из множества свойств сборки, составные признаки рекурсивно разворачиваются и прибавляются к множеству свойств сборки, таким образом рулы могут найти их при необходимости. Несоставные несвободные признаки переопределяют компоненты составных признаков в множестве свойств сборки.</entry>
              </row>
              <row>
                <entry align="center">не умолчательный</entry>
                <entry>Этот атрибут изпользуется чтобы отключить умолчательное поведение присвоения значений по-уполчанию неопциональным несвободным признакам.</entry>
              </row>
              <row>
                <entry align="center">беспроверочный</entry>
                <entry>Этот атрибут отключает валидацию разрешенных значений для признака. с помощью этого признака возможно определить признак, который может иметь любое значение, как у свободного признака, но с поведением несвободного недополнительного признака.</entry>
              </row>
              <row>
                <entry align="center">зависимость</entry>
                <entry>Значение зависимого атрибута - это ссылка на таргет.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>
    <section>
      <title>Таргеты</title>
      <section>
        <title>Основы</title>
        <para>Таргет это правило в  hammer&apos;s файле который определяет некоторые действия, как сборка исполняемого файла, сборка динамической библиотеки, копирование таргета из одного места в другое, или сборка и выполнение тестов. </para>
        <para>В большинстве случаем таргеты имеют следуюющий вид:</para>
        <programlisting>target-rule-name target-name 
   : [sources] 
   : [requirements]
   : [usage-requirements] 
   : [default-build]
   : [usage-requirements]
   ;</programlisting>
        <para>Некоторые аргументы могут быть пропущены (на самом деле почти все), но в большинстве случаев  <code>sources</code> и <code>requirements</code> имеют некоторые значения. </para>
        <para>Рассмотрим пример:</para>
        <programlisting>lib foo : main.cpp ;</programlisting>
        <para>Таргет реализует динамическую библиотеку <code>foo</code> из исходного файла <code>main.cpp</code>. </para>
        <programlisting>lib foo : main.cpp : &lt;link&gt;static ;</programlisting>
        <para>Таргет реализует статическую библиотеку <code>foo</code> из исходного файла <code>main.cpp</code>, указывая в разделе   requirements таргета  свойство <code>&lt;link&gt;static</code>.<programlisting>lib foo : main.cpp : &lt;link&gt;static : : &lt;define&gt;FOO_STATIC ;</programlisting></para>
        <para>Таргет реализует статическую библиотеку  <code>foo</code> из исходного файла <code>main.cpp</code>  указывая  в requirements таргета свойство <code>&lt;link&gt;static</code> и указывая в  usage requirements свойство  <code>&lt;define&gt;FOO_STATIC</code>.</para>
        <para>Сборка таргета по-умолчанию в данном случае не используется, поэтомму следует оставить секцию default-build пустой.</para>
      </section>
      <section>
        <title>Исходники таргета</title>
        <para>Исходники таргета могут принимать три различных формы:</para>
        <itemizedlist>
          <listitem>
            <para>Первая форма -  это  файл представленный как относительный к проекту или абсолютному пути.</para>
          </listitem>
          <listitem>
            <para>Вторая форма - это системный путь к проекту, опционально с именем таргета и свойствами сборки с которыми таргет должен быть собран. Примеры:</para>
            <itemizedlist>
              <listitem>
                <programlisting>lib a : b a.cpp ;</programlisting>
                <para>исходниками библиотеки <code>a</code>  являются  обычный файл <code>a.cpp</code> и все таргеты из проекта <filename>./b/hamfile</filename>.</para>
              </listitem>
              <listitem>
                <programlisting>lib b : ../c b.cpp ;</programlisting>
                <para>исходниками библиотеки <code>b</code> являются обычный файл <filename>b.cpp</filename> и все таргеты проекта <filename>../c/hamfile</filename>.</para>
              </listitem>
              <listitem>
                <programlisting>lib c : ../d//d_1 c.cpp ;</programlisting>
                <para>исходниками библиотеки <code>c</code> являются обычный файл <filename>c.cpp</filename> и таргет  <code>d_1</code> из проекта  <filename>../d/hamfile</filename>.</para>
              </listitem>
              <listitem>
                <programlisting>lib d : f/lib_f//f_1/&lt;link&gt;static d.cpp ;</programlisting>
                <para> исходниками  библиотеки <code>d</code> являются обычный файл <code>d.cpp</code> и таргет <code>f_1</code> из проекта <filename>./f/lib_f/hamfile</filename>, который должен быть собран в статическую библиотеку.</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Третья форма подобна второй, но с одним дополнением - предворяющей косой чертой <code>slash (&apos;/&apos;)</code>. Она описвывает  <emphasis>символьное имя</emphasis> которое не завязывается на структуру директорий или пути к файлам.</para>
          </listitem>
        </itemizedlist>
        <para>Последний вариант является <emphasis>рекомендуемой</emphasis> формой для исходников, которые являются таргетами. Когда вы задаете относительный путь к исходному таргету, или еще хуже - абсолютный путь, это делает проекты сильно привязанными к файловой системе.</para>
        <para>Расмотрим маленький пример. Вы написали простую библиотеку, которая зависит от библиотеки  <code>zlib</code>:<programlisting>lib foo : foo.cpp ../../zlib/build ;</programlisting></para>
        <para>Используя вторую форму вы  указываете что проект <code>zlib</code> должен располагатся близко к <code>foo</code>. Это провоцирует всех разработчиков размещать эти два проекта вместе. Это неприемлемо! Но, если Вы используете третью форму, то такие проблемы никогда не возникнут:<programlisting>lib foo : foo.cpp /zlib ;</programlisting></para>
        <para>Теперь<code>foo</code> не завязан на местоположение <code>zlib</code>. Hammer преобразует /zlib в правильный путь, который указан где-нибудь выше с помощью правила <code>use-project</code>.</para>
      </section>
      <section>
        <title>Требования таргета</title>
        <para>Требования таргета это множество свойств, которые должны всегда присутствовать при сборке таргета. Например, когда Вы хотите, чтобы некоторая библиотека была собрана статически, нужно прописать <code>&lt;link&gt;static</code> в требованиях таргета:</para>
        <programlisting>lib foo : foo.cpp : &lt;link&gt;static ;</programlisting>
        <para>Существует много различных признаков, которые  влияют на сборку разными способами. Вы можете <remark> TODO ? Чего туду, непонятно :)</remark> </para>
        <para>Чтобы собрать <code>foo</code> коректно нужно прописать  <emphasis>define</emphasis> и <emphasis>include</emphasis> признаки и много других, которые должны присутствовать в свойствах сборки таргета:</para>
        <programlisting>lib foo 
   : 
    foo.cpp 
   : 
    &lt;include&gt;../include 
    &lt;define&gt;FOO_DEFINE
    &lt;link&gt;static
   ;</programlisting>
        <para>Very often you need to specify some property <emphasis>conditionally</emphasis>. This is done by following syntax:</para>
        <programlisting>lib foo 
   : 
    foo.cpp 
   : 
    &lt;include&gt;../include
    &lt;link&gt;shared:&lt;define&gt;EXPORT_FOO
   ;</programlisting>
        <para>Здесь мы определям библиотеку <code>foo</code> с <emphasis>условным</emphasis>  требованием<programlisting>&lt;link&gt;shared:&lt;define&gt;EXPORT_FOO</programlisting>которое говорит билдовой системе добавить <code>&lt;define&gt;EXPORT_FOO</code> призак к требованиям  <code>foo</code>, в случае статической сборки библиотеки.</para>
      </section>
      <section>
        <title>Требования к использованию таргета</title>
        <para>Требования к использованию таргета это набор свойств,  которые нужно применить для всех его прямых пользователей. Этот концепт интенсивно используется в разработке библиотек и приложений на C++.</para>
        <para>Предположим Вы разрабатываете библиотеку  <code>foo</code>:</para>
        <programlisting>lib foo : foo.cpp : &lt;include&gt;../include ;</programlisting>
        <para>Для использования этой библиотеки вы должны сделать следующее:<programlisting>lib bar 
   : 
    bar.cpp 
    ../../foo/build                # place foo in sources
   : 
    &lt;include&gt;../include            # bar&apos;s include path
    &lt;include&gt;../../foo/include     # foo&apos;s include path
   ;</programlisting></para>
        <para>Для успешной сборки библиотеки <code>bar</code> Вы должны указать где искать подключаемые файлы для <code>foo</code>. <code>bar</code> является маленькой библиотекой, но как насчет  более сложной, с 5-10 зависимостями? Более того, что Вы будете прописывать в  <code>&lt;include&gt;</code> когда те библиотеки появятся в исходниках как символические имена?</para>
        <para>Для решения этой проблемы нужно использовать  <emphasis>требования к использованию</emphasis>. Переписанный вариант объявления <code>foo</code> с требованиями к использованию выглядит так:<programlisting>lib foo 
   : 
     foo.cpp 
   : 
    &lt;include&gt;../include 
   : 
   : 
    &lt;include&gt;../include 
   ;</programlisting></para>
        <para>Теперь <code>bar</code> можно переписать следующим образом:<programlisting>lib bar 
   : 
     bar.cpp
     ../../foo/build
   :
    &lt;include&gt;../include
                          # we don&apos;t need to specify 
                          # &lt;include&gt;../../foo/include
                          # any more 
   ;</programlisting></para>
      </section>
      <section>
        <title>Альтернативы таргета</title>
        <para>Иногда нужно собрать таргет используя используя совершенно другой набор исходников в зависимости от требования к сборке. Напримеер, когда таргет собирается <emphasis>gcc</emphasis>, он выглядит так:<programlisting>lib foo : gcc_foo.cpp ;</programlisting></para>
        <para>но когда собирается  <emphasis>msvc</emphasis>, выглядит по-другому:<programlisting>lib foo : msvc_foo.cpp ;</programlisting></para>
        <para>Другой пример - использование скомпилированных заголовочных файлов. Некоторые компиляторы имеют поддержку  pch, а некоторые нет. Но билдовый скрипт должен работть для обеих.</para>
        <para>Чтобы разрешить все эти проблемы можно использовать альтернатывные таргеты. Первая задача может быть решена следующим образом:<programlisting>lib foo : gcc_foo.cpp  : &lt;toolset&gt;gcc ;  #first alternative
lib foo : msvc_foo.cpp : &lt;toolset&gt;msvc ; #second alternative</programlisting></para>
        <para>Когда пользователь использует <code>/foo</code> в исходниках некоторого таргета, билдовая система загружает файл проекта <code>foo</code> и видит  <emphasis>два</emphasis> таргета <code>foo</code>. Чтобы решить который использовать, сравниваются требования к сборке и требования к таргету. Если требования к сборке содержат свойство <code>&lt;toolset&gt;gcc</code> тогда <emphasis>первая</emphasis> альтернатива выбирается. Если требования к сборке содержат свойство <code>&lt;toolset&gt;msvc</code> то <emphasis>вторая</emphasis> выбирается. </para>
        <para>Вторую задачу можно разрешить так:<programlisting>pch stdafx : stdafx.h stdafx.cpp : &lt;toolset&gt;msvc ;
alias stdafx ;

lib foo : stdafx foo.cpp ;</programlisting></para>
        <para>Здесь  <code>foo</code> будет собрано с поддержкой pch только для  msvc инструментария. Как можно увидеть таргеты с одним именем могут иметь разные <emphasis>типы</emphasis>. Таргеты <code>pch</code> сбоирают скомпилированные заголовочные файлы из даных исходников.  <code>alias</code> таргет - это специальный таргет, который ничего не делает кроме возвращения своих исходников их прямому пользователю.</para>
        <para>Механизм выбора альтернативы очень прост - только несвободные недополнительные признаки участвуют в выборе из альтернатив и таргет с наиболее подходящими свойствами будет выбран.</para>
      </section>
      <section>
        <title>Доступные исходники и требования</title>
        <para>Доступные исходники и требования были введены чтобы уменьшить писанину и сделать билдовые скрипты читабельнее.</para>
        <para>Когда Вы разрабатываете библиотеку некоторые из зависимостей используются для реализации деталей, а некоторые для открытой части. Предположим Вы  пишете библиотеку <code>foo</code> которая использует  <code>/boost/date_time</code> библиотеку:<programlisting>lib foo 
   : 
    foo.cpp /boost/date_time 
   : 
    &lt;include&gt;../include   #where to find foo&apos;s includes 
   :
   :
    &lt;include&gt;../include   #export includes for foo&apos;s users
   ;</programlisting></para>
        <para>В <filename>foo.h</filename> , который является частью открытого интерфейса библиотеки <code>foo</code>,  подключаются некоторые из заголовочных файлов <code>/boost/date_time</code>, поэтому <code>/boost/date_time</code> должна быть <emphasis>открытым исходником</emphasis> для библиотеки <code>foo</code>. </para>
        <para>В такой форме  собрать библиотеку <code>foo</code> не проблема - сборка происходит коректно благодаря требованиям к использованию библиотеки <code>/boost/date_time</code>, которые правильно  проносят пути к подключаемым файлам  для таргета <code>foo</code>. Но когда кто-то попробует использовать <code>foo</code> для сборки  <code>bar</code>:<programlisting>lib bar 
   : 
    bar.cpp /foo
   :
    &lt;include&gt;../include #where to find bar&apos;s includes
   : 
   :
    &lt;include&gt;../include #export includes for foo&apos;s users
   ;</programlisting></para>
        <para>у него сразу возникнут проблемы. Потому как требования к использованию таргета <code>/boost/date_time</code> применимы только к  <code>foo</code>, как к прямому пользователю, компилятор не увидит правильных путей к подключаемым файоам (модулям, ресурсам) для <code>/boost/date_time</code> при сборке <code>bar</code>. Пути к подключаемым файлам  таргета<code>/boost/date_time</code> нужны для сборки <code>bar</code> потому что <code>bar</code> использует <code>/foo</code>, который  <emphasis>неявно</emphasis>, через  <filename>foo.h</filename>,  использует некоторые из заколовочных файлов <code>/boost/date_time</code>.</para>
        <para>Чтобы разрешить эту проблему таргет <code>foo</code> следует переписать:<programlisting>lib foo 
   : 
    foo.cpp /boost/date_time 
   : 
    &lt;include&gt;../include   #where to find foo&apos;s includes 
   :
   :
    &lt;include&gt;../include   #export includes for foo&apos;s users
    &lt;use&gt;/boost/date_time #export /boost/date_time usage 
                          #requiremenst to foo&apos;s users
   ;</programlisting></para>
        <para>Когда свойство  <code>&lt;use&gt;some-lib</code> появляется в каком-либо требовании таргета, билдовая система добавляет требования к использованию  <code>some-lib</code> к требованиям таргета. Таким образом теперь, когда мы используем  <code>foo</code> как исходник для <code>bar</code>, требования к использованию <code>foo</code>&apos;s будут добавлены к требованиям <code>bar</code> и так как требования к использованию <code>foo</code> содержат свойство <code>&lt;use&gt;/boost/date_time</code>, то все требования к использованию <code>/boost/date_time</code> будут добавлены к требованиям  <code>bar</code>. Это даст все необходимые <code>&lt;include&gt;</code> признаки в требованиях <code>bar</code> для его коректной сборки.</para>
        <para>Указывая <code>/boost/date_time</code> в исходниках и потом <code>&lt;use&gt;/boost/date_time</code> в требованиях к использованию выглядит не очень хорошей идеей, особенно когда таких исходников много. Чтобы упростить жизнь разработчикам был ввседен специальный синтаксис. Чтобы определить что некоторый из таргетов является  <emphasis>открытым исходником</emphasis> следует дописать символ <code>@</code> перед ним. Переписанный таргет <code>foo</code> с использованием нового синтаксиса:<programlisting>lib foo 
   : 
    foo.cpp 
    @/boost/date_time     #public source
   : 
    &lt;include&gt;../include   #where to find foo&apos;s includes 
   :
   :
    &lt;include&gt;../include   #export includes for foo&apos;s users
   ;</programlisting></para>
        <para>Как можно увидеть некоторое дублирование кода все же присутствует. <code>&lt;include&gt;../include</code> появляется и в требованиях и в требованиях к использованию. Чтобы упростить это мы можем применить тот же открытый прцип к требованиям таргета:<programlisting>lib foo 
   : 
    foo.cpp 
    @/boost/date_time     #public source
   : 
    @&lt;include&gt;../include  #public requirement 
   ;</programlisting></para>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Собираем!</title>
    <section>
      <title>Исполняемые файлы</title>
      <section>
        <title>Определение</title>
        <para>Чтобы собрать исполняемый файл нужно использовать правило  <code>exe</code>:<programlisting>exe exe-name 
   : sources
   : [requirements]
   : [default build]
   : [usage requirements]
   ;          </programlisting></para>
      </section>
      <section>
        <title>Пример: Простой исполняемый файл</title>
        <figure label="test">
          <title>Уровень файловой системы</title>
          <graphic fileref="../../common/images/simple-exe-layout.png" align="center"/>
        </figure>
        <figure>
          <title>
            <filename>../../common/examples/hamroot</filename>
          </title>
          <programlisting>...
use-project /simple-exe : simple-exe/build ;
...</programlisting>
        </figure>
        <figure>
          <title>
            <filename>../../common/examples/simple-exe/build/hamfile</filename>
          </title>
          <programlisting>exe simple-exe : ../src/main.cpp ;</programlisting>
        </figure>
      </section>
    </section>
    <section>
      <title>Библиотеки</title>
      <para>Все библиотеки имеют один и тот же синтаксис - нужно использовать правило <code>lib</code>:<programlisting>lib lib-name
   : [sources]
   : [requirements]
   : [default build]
   : [usage requirements]
   ;</programlisting></para>
      <section>
        <title>Статические и динамические библиотеки</title>
        <para>Чтобы собирать статические библиотеки  нужно указать свойство <code>&lt;link&gt;static</code> в требованиях таргета:<programlisting>lib foo : foo.cpp : &lt;link&gt;static ;</programlisting></para>
        <para>Чтобы  собирать динамические библиотеки нужно указать свойство <code>&lt;link&gt;shared</code> в требованиях таргета:<programlisting>lib bar : bar.cpp : &lt;link&gt;shared ;</programlisting></para>
        <para>По-умолчанию признак <code>&lt;link&gt;</code> имеет значение  <code>shared</code>. Поэтому, если явно не утановить значение в требованиях, то  библиотека будет собрана <emphasis>динамически</emphasis>. </para>
        <para>Явное указание признака в требованиях таргета является плохим стилем, если нет реальных причин задавать тип линковки. Если известны шаблоны использования бибилиотеки, лучше добавить признак <code>&lt;link&gt;</code> в секцию  <emphasis>сборка по-умолчанию</emphasis> section. Это позволит пользователям библиотеки собирать ее как угодно по их желанию, но в случае отсутсвия признака <code>&lt;link&gt;</code> в требованиях сборки она будет собиратся динамически.</para>
        <para>Например, Вы разрабатываете библиотеку <code>foo</code>:<programlisting>lib foo : foo.cpp ;</programlisting></para>
        <para>и решаете что она должна линковатся динамически, потому что в большинстве случаев пользователи используют почти весь код из <code>foo.</code> Если добавить  <code>&lt;link&gt;shared</code> в требования:<programlisting>lib foo : foo.cpp : &lt;link&gt;shared ;</programlisting></para>
        <para>никто не сможет собрать как динамическую. Но если кто-то захочет использовать библиотеку для разработки некоторого приложения Х и одним из основных требований будет отсутсвие динамических зависимостей? Прописывая <code>&lt;link&gt;shared</code> в требования  <code>foo</code> делает невозможным  использовать <code>foo</code> таким оразом.</para>
        <para>Чтоыб разрешить пользователям <code>foo</code> делать что им вздумается и собирать библиотеку как динамическую по умолчанию нужно прописать  <code>foo</code> как:</para>
        <programlisting>lib foo 
   : 
    foo.cpp 
   : 
                  # no &lt;link&gt;shared in requirements
   : 
    &lt;link&gt;shared  # place it in usage requirements
   ;</programlisting>
      </section>
      <section>
        <title>Пример: Статические и динамические библиотеки</title>
        <para>В этом примере будет показано как собрать проект, который состоит из трех различных форм библиотек - динамической, статической и, так называемой, &apos;безсвязную&apos;. Последняя является библиотекой, которая не имеет признака <code>&lt;link&gt;</code> в требованиях и потому может быть собрана как статически так и динамически.</para>
        <figure>
          <title>Структура файловой системы</title>
          <graphic fileref="../../common/images/shared-static-libs-layout.png" align="center"/>
        </figure>
        <figure>
          <title>
            <filename>../../common/examples/hamroot</filename>
          </title>
          <programlisting>...
use-project /libs : libs ;
...</programlisting>
        </figure>
        <figure>
          <title>
            <filename>../../common/examples/libs/hamfile</filename>
          </title>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../common/examples/libs/hamfile" encoding="UTF-8" parse="text"/></programlisting>
        </figure>
        <figure>
          <title><filename>example/libs/test/build/hamfile</filename> - main project</title>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../common/examples/libs/test/build/hamfile" encoding="UTF-8" parse="text"/></programlisting>
        </figure>
        <figure>
          <title><filename>../../common/examples/libs/shared-lib/build/hamfile</filename> - shared library</title>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../common/examples/libs/shared-lib/build/hamfile" encoding="UTF-8" parse="text"/></programlisting>
        </figure>
        <figure>
          <title><filename>../../common/examples/libs/static-lib/build/hamfile</filename> - static library</title>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../common/examples/libs/static-lib/build/hamfile" encoding="UTF-8" parse="text"/></programlisting>
        </figure>
        <figure>
          <title><filename>../../common/examples/libs/unconstrained-lib/build/hamfile</filename> - unconstrained library</title>
          <programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../common/examples/libs/unconstrained-lib/build/hamfile" encoding="UTF-8" parse="text"/></programlisting>
        </figure>
      </section>
      <section>
        <title>Prebuilt libraries</title>
        <para>Большинство проприетарных библиотек не распостраняются с исходным кодом, только как собранные библиотеки. В то же время  есть множество предустановленных собранных библиотек под Linux. Для их использования  Hammer имет три соответствующие правила:<programlisting>searched-static-lib lib-name
   : [sources]
   : [static library name]
   : [requirements]
   : [usage requirements] 
   ;

searched-shared-lib lib-name
   : [sources]
   : [shared library name]
   : [requirements]
   : [usage requirements] 
   ;

prebuilt-lib lib-name
   : [library file name]
   : [requirements]
   : [usage requirements] 
   ;</programlisting></para>
        <para>Тех три правила достаточно чтобы описать любую собраную библиотеку. Обратите внимание, что <code>searched-static-lib</code> и <code>searched-shared-lib</code> должны иметь исходные файлы даже если библиотека не будет собиратся. Это так вследствии  unix/linux линкера ld -  <emphasis>возможно</emphasis> необходимо определить правильную последовательность библиотек для успешной сборки.</para>
        <para><code>searched-static-lib</code> описывает статическую библиотеку, размещенную где-нибудь в системе или директории, которая может быть указана признаком <code>&lt;search&gt;</code> в требованиях. Для каждого компилятора <code>[static library name]</code> имеет уникальную форму. Для  gcc это имя является именем без префикса <filename>lib</filename> или <filename>.a</filename> суфикса. Для компилятора  Microsoft это полное имя, например как  <code>winsock.lib</code>. Чтобы определить как следует передавать имя библиотеки заданному линковщику, следует обратится к документации на этот линковщик.</para>
        <para><code>searched-shared-lib</code> это почти то же что и <code>searched-static-lib</code> за исключением, что это правило описывает динамическую библиотеку. Правила именования для<code>[shared lirary name]</code> определяются переключателями линковщика.</para>
        <para><code>prebuild-lib</code> описывает библиотеку, которая размещена в известном месте в файловой системе. Пока <code>searched-static-lib</code> и <code>searched-shared-lib</code> являются правилом установленных в системе библиотек, то правило  - для библиотек, которые являются частью некоторого проекта. Например, оно может описывать некоторую собранную закрытую библиотеку в качестве исходника, так что проект Hammer&quot;а  может быть легко с ней слинкован.</para>
      </section>
    </section>
    <section>
      <title>Примеры: Prebuilt libraries</title>
      <para>На самом деле одчень сложно обеспечить обширные и содержательные примеры для этого типа библиотек через их природу. Таким образом обеспечением только Linux и Windows вариантов предполагается что этого будет достаточно для понимания.</para>
      <figure>
        <title>В Linux</title>
        <programlisting>searched-static-lib xml2 
   :                  # note - no sources provided
   : 
    xml2              # note - full file name is libxml2.a
   :
    &lt;search&gt;/opt/libs # optional additional search path 
                      # where linker should look for 
                      # library
   ;
explicit xml2 ;

# build executable linked with preinstalled 
# xml2 library
exe test
   : 
    main.cpp 
    xml2 
   ;</programlisting>
      </figure>
      <figure>
        <title>В Windows</title>
        <programlisting>searched-static-lib sockets 
   : 
   :
    Ws2_32.lib # note - it is full name of library file
   ; 
explicit sockets ;
 
#build executable linked with system sockets library
exe test : main.cpp sockets ;</programlisting>
      </figure>
      <figure>
        <title>Соранные (prebuilt) lib</title>
        <programlisting># bar library built for msvc toolset
prebuilt-lib bar
   :
    ../libs/bar-msvc.lib         # path to library file
   :
    &lt;toolset&gt;msvc
   ;

# this is alternative for gcc toolset
prebuilt-lib bar
   : 
    ../libs/libbar-gcc.a         # path to library file
   : 
    &lt;toolset&gt;gcc
   ;
explicit bar ;

# test executable that links with prebuilt bar lib that 
# ether preinstalled nor system and placed in ../libs dir
exe test 
   : 
    main
    bar
   ;
</programlisting>
      </figure>
    </section>
  </chapter>
  <chapter>
    <title>Ссылки</title>
    <address>http://buildhammer.sourceforge.net</address>
    <address>http://boost.org</address>
    <address>http://www.antlr.org/works/index.html</address>
  </chapter>
  <appendix>
    <title>Словари</title>
    <glossary>
      <title>Словарь терминов</title>
      <glossentry>
        <glossterm>attribute</glossterm>
        <glossdef>
          <para>атрибут</para>
        </glossdef>
      </glossentry>
      <glossentry>
        <glossterm>feature</glossterm>
        <glossdef>
          <para>признак</para>
        </glossdef>
      </glossentry>
      <glossentry>
        <glossterm>requirements</glossterm>
        <glossdef>
          <para>требования</para>
        </glossdef>
      </glossentry>
      <glossentry>
        <glossterm>rule</glossterm>
        <glossdef>
          <para>правило</para>
        </glossdef>
      </glossentry>
      <glossentry>
        <glossterm>target</glossterm>
        <glossdef>
          <para>таргет</para>
        </glossdef>
      </glossentry>
      <glossentry>
        <glossterm>toolset</glossterm>
        <glossdef>
          <para>инструментарий</para>
        </glossdef>
      </glossentry>
    </glossary>
    <glossary>
      <title>Словарь сокращений</title>
      <glossentry>
        <glossterm>GCC</glossterm>
        <glossdef>
          <para>GNU Compilers Collection</para>
        </glossdef>
      </glossentry>
      <glossentry>
        <glossterm>MSVC</glossterm>
        <glossdef>
          <para>Microsoft Visual Compiler</para>
        </glossdef>
      </glossentry>
    </glossary>
  </appendix>
</book>
