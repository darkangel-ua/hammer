<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<book>
  <title>Hammer User Manual</title>
  <chapter>
    <title>Introduction</title>
    <section>
      <title>What is Hammer?</title>
    </section>
    <section>
      <title>Hammer&apos;s history</title>
    </section>
    <section>
      <title>Hammer&apos;s features</title>
    </section>
  </chapter>
  <chapter>
    <title>Overview</title>
    <section>
      <title>Filesystem layout</title>
      <para>The proposed working space organization is not a mandated, but recommended to use. You can organize projects in many ways you wish or must in the filesystem, but not all layouts can be used to expose full  power of Hammer. </para>
      <para>Developing big, complex software with tens or hundreds of components is not a simple task. There is no single way how programmes manage all this mess and this is only amplifies the problems. On Linux you need to download sources, unpack and do <command>./configure &amp;&amp; make &amp;&amp; make install</command> . On Windows there is no standard way at all. Linux way is much simpler and defined, but not perfect. You just can&apos;t develop two different components depended on two different versions of the same library without some magic.  </para>
      <para>Having one, simple, unified  and easy to understand project organization will greatly simplify developers communication and removes mental switches when you need to developing cross platform code.</para>
      <para>Unfinished.</para>
    </section>
    <section>
      <title>Hammer&apos;s script language</title>
      <para>For now hammer&apos;s script language is very similar to perforce Jam language but without any control flow statements. Only rules was borrowed.  Rules is look like function invocations and most of the time have declarative meaning and very rare as real function invocation. So basic syntax is:</para>
      <programlisting>rule-name argument_1 : argument_2 : ... : argument_N ;</programlisting>
      <para>Each argument is a list of strings separated with <emphasis>space</emphasis> that can be zero length. Symbol &apos;:&apos; is used to separate arguments and &apos;;&apos; must enclose rule statement.</para>
      <note>
        <para>Because of some lexical problems real separator between arguments is &apos;&lt;space&gt;&lt;colon&gt;&lt;space&gt;&apos; not just &apos;&lt;colon&gt;&apos;. </para>
      </note>
      <para>Examples:</para>
      <programlisting>exe test : main.cpp ;</programlisting>
      <para>there we have rule name is  <code>lib</code>, first argument is <code>test</code>, second argument is <code>main.cpp</code> .</para>
      <para><programlisting>lib iconv : : &lt;name&gt;iconv &lt;toolset&gt;gcc ;</programlisting>there we have rule name is <code>lib</code>, first argument is <code>iconv</code>, second argument is nothing, third argument is <code>&lt;name&gt;iconv &lt;toolset&gt;gcc</code>.</para>
    </section>
    <section>
      <title>Projects</title>
      <section>
        <title>Basics</title>
        <para>To manage all that complexity in software developing we divide software into peaces - libraries. That  makes ours life much easy. Library usually consists from sources, includes, docs and tests. Sources can be build into library, docs can be build from DocBook to HTML, tests can be build and run. </para>
        <para>Hammer&apos;s <emphasis>project</emphasis> is just hammer script file. It can contain  targets to build or projects structuring declarations or both of them. To illustrate what we talking about let&apos;s see on the example.</para>
        <graphic fileref="images/project-layout.png" align="center"/>
        <para>Here we have a small part of well known boost library collection rearranged to be modular. The project <filename>boost/hamfile</filename> doesn&apos;t have any build targets. It only instruct hammer where to find boost&apos;s sub-projects:</para>
        <programlisting>use-project filesystem : filesystem ;
use-project thread : thread ;</programlisting>
        <para>The project <filename>boost/filesystem/hamfile</filename>:</para>
        <programlisting>version-alias filesystem : trunc ;</programlisting>
        <para>does have targets, but <code>version-alias</code> is not exactly real target - we will explain it later. And finally <filename>boost/filesystem/trunc/build/hamfile</filename> contains target to build called <code>boost.filesystem</code>:</para>
        <programlisting>lib boost.filesystem
    :
     @/boost/core/&lt;version&gt;1.36.0
     [ glob ../src/*.cpp ]
     @/boost/system/&lt;version&gt;1.36.0
     @/boost/iterator/&lt;version&gt;1.36.0
     @/boost/exception/&lt;version&gt;1.36.0
    :
     &lt;link&gt;shared:&lt;define&gt;BOOST_ALL_DYN_LINK=1 
     &lt;link&gt;static:&lt;define&gt;BOOST_All_STATIC_LINK=1
     @&lt;include&gt;../include
    ;
</programlisting>
        <para>Every Hammer script file may have project description rule in the form:</para>
        <programlisting>project &lt;project-name&gt; : requirements &lt;property-set&gt;
                       : usage-requirements &lt;property-set&gt;
                       ;</programlisting>
        <para>For now <code>&lt;project-name&gt;</code> doesn&apos;t have any semantic load. But <emphasis>requirements</emphasis> and <emphasis>usage-requirements</emphasis> is really helpful in complex projects with many libraries and targets. As will be showed in Targets section mostly all build targets has requirements and usage-requirements. When hammer script has <code>project</code> definition along with other targets definitions, all that targets will inherits requirements and usage-requirements from project definition. Example:<programlisting>project foobar : requirements &lt;define&gt;FOO=1
               : usage-requirements &lt;define&gt;BOO=1
               ;

lib foobar : main.cpp ;
lib barfoo : test.cpp ;</programlisting></para>
        <para>is equivalent to:<programlisting>lib foobar : main.cpp : &lt;define&gt;FOO=1 : : &lt;define&gt;BOO=1 ;
lib barfoo : test.cpp : &lt;define&gt;FOO=1 : : &lt;define&gt;BOO=1 ;</programlisting></para>
      </section>
      <section>
        <title>Project inheritance</title>
        <para>Because Hammer&apos;s projects is just files and   organized in filesystem in hierarchical way  reflecting underlying software structure we automatically get a projects hierarchy. Looking at previously presented project hierarchy we see  <code>boost</code> project that consists from <code>boost/filesystem</code> and <code>boost/thread</code> sub-projects. Filesystem project consists from  <code>boost.filesystem</code> library target placed in <filename>hammer/filesystem/trunc/build/hamfile</filename> and <code>test</code> target placed in <filename>boost/filesystem/trunc/test/build/hamfile</filename> that is subproject of <code>boost/filesystem</code> project. </para>
        <para>It is naturally that <code>boost</code> project may have some requirements and usage requirements that is same for all its sub-projects. Because of that every subproject <emphasis>inherits</emphasis> all requirements and usage requirements from upper project same way as that done for targets inside any <filename>hamfile</filename>. The target <code>boost.filesystem</code> in hammer project <filename>boost/filesystem/trunc/build/hamfile</filename> will  inherit requirements and usage requirements from <filename>boost/hamfile</filename> and <filename>boost/filesystem/hamfile</filename> hammer projects descriptions.</para>
      </section>
    </section>
    <section>
      <title>Features and properties</title>
      <para>To portably represent aspects of target configuration such as debug and release variants, or single- and multi-threaded builds, Hammer uses <emphasis>features</emphasis> with associated <emphasis>values</emphasis>. For example, the <code>debug-symbols</code> feature can have a value of <code>on</code> or <code>off</code>. A <emphasis>property</emphasis> is just a (feature, value) pair.</para>
      <para>In script properties easy located by special syntactic form <code>&lt;feature-name&gt;value</code>. For example <code>&lt;link&gt;static</code> - feature <code>link</code> with value <code>static</code>.</para>
      <para>Each feature has a set of associated <emphasis>attributes</emphasis>. Feature attributes are low-level descriptions of how the build system should interpret a feature&apos;s values when they appear in a build request.We also refer to the attributes of properties, so that an <code>incidental</code> property, for example, is one whose feature has the <code>incidental</code>  attribute.<table>
          <title>Feature&apos;s attributes</title>
          <tgroup cols="2">
            <colspec colwidth="2.5 cm"/>
            <tbody>
              <row>
                <entry align="center">incidental</entry>
                <entry>Incidental features are assumed not to affect build products at all. A feature that controls a compiler&apos;s warning level is one example of a likely incidental feature. Non-incidental features are assumed to affect build products.</entry>
              </row>
              <row>
                <entry align="center">propagated</entry>
                <entry>Features of this kind are propagated to dependencies. That is, if a arget is built using a propagated property, the build systems attempts to use the same property when building any of its dependencies as part of that arget. For instance, when an exectuable is requested to build with msvc-8.0 toolset, one usually wants it to be linked with libraries builded with same toolset. Thus, the &lt;toolset&gt; feature is propagated.</entry>
              </row>
              <row>
                <entry align="center">free</entry>
                <entry>Most features have a finite set of allowed values, and can only take on a single value from that set in a given build specification. Free features, on the other hand, can have several values at a time and each value can be an arbitrary string. For example, it is possible to have several preprocessor symbols defined simultaneously: &lt;define&gt;NDEBUG=1 &lt;define&gt;HAS_CONFIG_H=1 </entry>
              </row>
              <row>
                <entry align="center">optional</entry>
                <entry>An optional feature is a feature that is not required to appear in a build specification. Every non-optional, non-free and without no-default attribute feature has a default value that is used when a value for the feature is not otherwise specified, either in a target&apos;s requirements or in the user&apos;s build request. </entry>
              </row>
              <row>
                <entry align="center">path</entry>
                <entry>The value of a path feature specifies a path. The path is treated as relative to the directory of <filename>hamfile</filename> where path feature is used and is translated appropriately by the build system when the build is invoked from a different directory</entry>
              </row>
              <row>
                <entry align="center">composite</entry>
                <entry>Composite features actually correspond to groups of properties. For example, a build variant is a composite feature. When generating targets from a set of build properties, composite features are recursively expanded and added to the build property set, so rules can find them if necessary. Non-composite non-free features override components of composite features in a build property set.</entry>
              </row>
              <row>
                <entry align="center">no-defaults</entry>
                <entry>This attribute used to disable default behaviour of assigning default values to non-optional non-free features.</entry>
              </row>
              <row>
                <entry align="center">no-checks</entry>
                <entry>This attribute disable validating allowed values for feature. With help of this attribute it is posible to define feature that can have any value like free feature, but behave like non-free non-incidental features.</entry>
              </row>
              <row>
                <entry align="center">dependency</entry>
                <entry>The value of dependency feature is a target reference.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </section>
    <section>
      <title>Targets</title>
      <section>
        <title>Basics</title>
        <para>Target is a rule in hammer&apos;s script file that define some action such as build executable,  build shared lib, copy target from one location to another or build and run some tests. </para>
        <para>Most of the time targets takes the following form:</para>
        <programlisting>target-rule-name target-name 
   : [sources] 
   : [requirements]
   : [usage-requirements] 
   : [default-build]
   : [usage-requirements]
   ;</programlisting>
        <para>Some argument can be omitted (almost all), but most of the time <code>sources</code> and <code>requirements</code> will have some values. </para>
        <para>Let&apos;s look on some examples:</para>
        <programlisting>lib foo : main.cpp ;</programlisting>
        <para>Target will produce shared library <code>foo</code> from sources <code>main.cpp</code>. </para>
        <programlisting>lib foo : main.cpp : &lt;link&gt;static ;</programlisting>
        <para>Target will produce static library <code>foo</code> from sources <code>main.cpp</code>  using target requirements <code>&lt;link&gt;static</code>.<programlisting>lib foo : main.cpp : &lt;link&gt;static : : &lt;define&gt;FOO_STATIC ;</programlisting></para>
        <para>Target will produce static library <code>foo</code> from sources <code>main.cpp</code>  using target requirements <code>&lt;link&gt;static</code> and set usage requirements to <code>&lt;define&gt;FOO_STATIC</code>.</para>
        <para>Target&apos;s default build  argument is now not used, so you must leave it empty.</para>
      </section>
      <section>
        <title>Target&apos;s sources</title>
        <para>Target&apos;s sources can take three different form:</para>
        <itemizedlist>
          <listitem>
            <para>First form is a file expesed as relative to project or absolute path. </para>
          </listitem>
          <listitem>
            <para>Second form is filesystem path to project, optionaly with target name and build properties with witch target must be built. Examples:</para>
            <itemizedlist>
              <listitem>
                <programlisting>lib a : b a.cpp ;</programlisting>
                <para><code>a</code>&apos;s sources is regilar file <code>a.cpp</code> and all targets from <filename>./b/hamfile</filename> project.</para>
              </listitem>
              <listitem>
                <programlisting>lib b : ../c b.cpp ;</programlisting>
                <para><code>b</code>&apos;s sources is regular file <filename>b.cpp</filename> and all targets from <filename>../c/hamfile</filename> project.</para>
              </listitem>
              <listitem>
                <programlisting>lib c : ../d//d_1 c.cpp ;</programlisting>
                <para><code>c</code>&apos;s sources is regular file <filename>c.cpp</filename> and target  <code>d_1</code> from <filename>../d/hamfile</filename> project.</para>
              </listitem>
              <listitem>
                <programlisting>lib d : f/lib_f//f_1/&lt;link&gt;static d.cpp ;</programlisting>
                <para> <code>d</code>&apos;s sources is regular file <code>d.cpp</code> and <code>f_1</code> target from <filename>./f/lib_f/hamfile</filename> project that must be build as static library.</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Third form similar to second with one addition - prepended <code>slash (&apos;/&apos;)</code>. This one describes <emphasis>symbolic name</emphasis> that doesn&apos;t tied to directory layout or file path.  </para>
          </listitem>
        </itemizedlist>
        <para>The last one  is <emphasis>recomended</emphasis> form for sources that are targets. When you specify relative path to source target or even worth - absolute path,  that makes project highly tied to filesystem. </para>
        <para>Consider small example. You write simple library that uses <code>zlib</code> library:<programlisting>lib foo : foo.cpp ../../zlib/build ;</programlisting></para>
        <para>By using second form you mandate that <code>zlib</code> project  must lay close to <code>foo</code>. This forces all developers to place this  two projects together. This is unacceptable. But if you use third form you will never have such problems:<programlisting>lib foo : foo.cpp /zlib ;</programlisting></para>
        <para>Now <code>foo</code> is not tied with  <code>zlib</code> placement. Hammer will resolve /zlib into appropriate path that was specified somewhere previously  using <code>use-project</code> rule.</para>
      </section>
      <section>
        <title>Target&apos;s requirements</title>
        <para>Target&apos;s requirements is a property set that specify how target must be built. When you what that library should be build  as static library you place <code>&lt;link&gt;static</code> in requirements.  </para>
      </section>
      <section>
        <title>Target&apos;s usage requirements</title>
      </section>
      <section>
        <title>Target alternatives</title>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Let&apos;s build!</title>
  </chapter>
  <chapter>
    <title>Reference</title>
  </chapter>
</book>
