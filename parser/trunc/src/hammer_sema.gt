tree grammar hammer_sema;

options { 
        language = C; 
        tokenVocab = hammer;
        ASTLabelType = pANTLR3_BASE_TREE;
}

@header {

#include <hammer/sema/actions.h>
#include <hammer/parscore/identifier.h>
#include <hammer/ast/requirement_set.h>
#include <hammer/ast/requirement.h>
#include <hammer/ast/path_like_seq.h>

#define SEMA static_cast<const hammer::sema::actions*>(PARSER->super)
}

hamfile returns [const hammer::ast::hamfile* result]
@init { hammer::ast::statements_t statements; }
        : ^(HAMFILE project_def statement[&statements]*) { result = SEMA->on_hamfile($project_def.result, statements); }
        ;
        
project_def returns[const hammer::ast::project_def* result]
@init { hammer::ast::expressions_t args; }
        : IMPLICIT_PROJECT_DEF { result = SEMA->on_implicit_project_def(); }
        | ^(EXPLICIT_PROJECT_DEF p='project' arguments[&args]) { result = SEMA->on_explicit_project_def($p->getToken($p), args); }
        ;

statement[hammer::ast::statements_t* statements]
	: target_def_or_rule_call { statements->push_back($target_def_or_rule_call.result); }
	;

target_def_or_rule_call returns[const hammer::ast::expression* result] 
@init { hammer::ast::expressions_t args; }
	: ^(TARGET_DECL_OR_RULE_CALL name=ID arguments[&args]) { result = SEMA->on_target_or_rule_call($name->getToken($name), args); }
	; 

arguments[hammer::ast::expressions_t* args]
        : ^(ARGUMENTS (argument { args->push_back($argument.result); })* )
        ;

argument returns[const hammer::ast::expression* result]
	: expression { result = $expression.result; }
	| named_expression { result = $named_expression.result; }
	;
	
named_expression returns[const hammer::ast::expression* result]
	: ^(NAMED_EXPRESSION ID expression { result = SEMA->on_named_expr($ID->getToken($ID), $expression.result); } ) 
	;	
	
expression returns[const hammer::ast::expression* result]
@init { hammer::ast::expressions_t args; }
	: EMPTY_EXPRESSION { result = SEMA->on_empty_expr(); }
        | list_of[&args] { result = SEMA->on_list_of(args); }
        | requirement_set { result = $requirement_set.result; }
        ;

requirement_set returns[const hammer::ast::requirement_set* result]
@init { hammer::ast::requirements_t requirements; }
 	: ^(REQUIREMENT_SET (requirement { requirements.push_back($requirement.result); })+) { result = SEMA->on_requirement_set(requirements); }
 	;

requirement returns[const hammer::ast::requirement* result]
	: simple_requirement { result = $simple_requirement.result; } 
	| conditional_requirement { result = $conditional_requirement.result; }
	;
	
conditional_requirement returns[const hammer::ast::requirement* result]
@init { 
   hammer::ast::features_t features; 
   hammer::parscore::source_location tag_loc;
}
	: ^(REQUIREMENT public_tag[&tag_loc] ^(CONDITION (con=feature { features.push_back($con.result); })+ COLON) res=feature) { result = SEMA->on_conditional_requirement(tag_loc, features, $res.result); }
	;
	
simple_requirement returns[const hammer::ast::requirement* result]
@init { hammer::parscore::source_location tag_loc; }
	: ^(REQUIREMENT public_tag[&tag_loc] feature) { result = SEMA->on_simple_requirement(tag_loc, $feature.result); }
	;

feature returns[const hammer::ast::feature* result]
	: ^(FEATURE ID feature_value) { result = SEMA->on_feature($ID->getToken($ID), $feature_value.result); }
	;
	
feature_value returns[const hammer::ast::expression* result]
	: path_like_seq { result = $path_like_seq.result; }
	| target_ref { result = $target_ref.result; }
	;

list_of[hammer::ast::expressions_t* args]
	: ^(LIST_OF (list_of_impl { args->push_back($list_of_impl.result); })+ )
	;           

list_of_impl returns[const hammer::ast::expression* result ] 
	: path_like_seq { result = $path_like_seq.result; }
	| target_def_or_rule_call { result = $target_def_or_rule_call.result; }
	| target_ref { result = $target_ref.result; }
	;

target_ref returns[const hammer::ast::expression* result]
@init 
{ 
   hammer::parscore::identifier name;
   hammer::parscore::source_location public_tag_loc;
} 
	: ^(TARGET_REF public_tag[&public_tag_loc] path_like_seq target_ref_name[&name] target_ref_requirements) 
		{ result = SEMA->on_target_ref(public_tag_loc, $path_like_seq.result, name, $target_ref_requirements.result); }
	;

public_tag[hammer::parscore::source_location* tag_loc] 
	: PUBLIC_TAG { *tag_loc = hammer::parscore::source_location($PUBLIC_TAG->getToken($PUBLIC_TAG)); } 
	|
	;

target_ref_name[hammer::parscore::identifier* name] 
	: ^(TARGET_NAME EMPTY_TARGET_NAME)
	| ^(TARGET_NAME ID) { *name = hammer::parscore::identifier($ID->getToken($ID)); }
	| 
	;

target_ref_requirements returns[const hammer::ast::requirement_set* result]
	: requirement_set { result = $requirement_set.result; }
	| { result = NULL; }
	;

path_like_seq returns[const hammer::ast::path_like_seq* result]
@init { std::pair<pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN> bounds; } 
	: ^(PATH_LIKE_SEQ SLASH path_like_seq_impl[&bounds]) { result = SEMA->on_path_like_seq($SLASH->getToken($SLASH), bounds.second); }
	| ^(PATH_LIKE_SEQ path_like_seq_impl[&bounds])       { result = SEMA->on_path_like_seq(bounds.first, bounds.second); }
	; 

path_like_seq_impl[std::pair<pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN>* bounds] 
	: ID { bounds->first = bounds->second = $ID->getToken($ID); }
	| first=ID ID* last=ID { bounds->first = $first->getToken($first); bounds->second = $last->getToken($last); }
	;
