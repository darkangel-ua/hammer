tree grammar hammer_sema;

options { 
        language = C; 
        tokenVocab = hammer;
        ASTLabelType = pANTLR3_BASE_TREE;
}

@header {

#include <hammer/sema/actions.h>
#include <hammer/parscore/identifier.h>
#include <hammer/ast/requirement_set.h>
#include <hammer/ast/requirement.h>
#include <hammer/ast/path_like_seq.h>
#include <hammer/ast/feature.h>

#define SEMA static_cast<const hammer::sema::actions*>(PARSER->super)
#define DECLARE_TYPE(Type, name) Type name ( Type ::allocator_type{SEMA->get_context()});
}

hamfile returns [const hammer::ast::hamfile* result]
@init { DECLARE_TYPE(hammer::ast::statements_t, statements); }
	: ^(Hamfile statement[&statements]*) { result = SEMA->on_hamfile(statements); }
        ;
        
statement[hammer::ast::statements_t* statements]
	: target_def_or_rule_call { statements->push_back($target_def_or_rule_call.result); }
	;

target_def_or_rule_call returns[const hammer::ast::expression* result] 
@init { DECLARE_TYPE(hammer::ast::expressions_t, args); }
	: ^(Rule name=Id arguments[&args]) { result = SEMA->on_target_or_rule_call($name->getToken($name), args); }
	; 

arguments[hammer::ast::expressions_t* args]
	: ^(Arguments (argument { args->push_back($argument.result); })* )
        ;

argument returns[const hammer::ast::expression* result]
	: EmptyArgument { result = SEMA->on_empty_expr($EmptyArgument->getToken($EmptyArgument)); }
	| expression { result = $expression.result; }
	| named_expression { result = $named_expression.result; }
	;

named_expression returns[const hammer::ast::expression* result]
	: ^(NamedArgument Id expression { result = SEMA->on_named_expr($Id->getToken($Id), $expression.result); } )
	;	
	
expression returns[const hammer::ast::expression* result]
@init { DECLARE_TYPE(hammer::ast::expressions_t, args); }
	: list_of[&args] { result = SEMA->on_list_of(args); }
//        | target
//        | public_expression
//        | expression_a
	| rule_invocation { result = $rule_invocation.result; }
	| feature { result = $feature.result; }
	| ^(PublicTag feature) { result = SEMA->on_public_expr($PublicTag->getToken($PublicTag), $feature.result); }
	| target_def_or_rule_call { result = $target_def_or_rule_call.result; }
	| path { result = $path.result; }
	| Id { result = SEMA->on_id($Id->getToken($Id)); }
	;
//public_expression returns[const hammer::ast::expression* result]
//	: ^(public_tag expression_a) { result = SEMA->on_public_expression($public_tag.result, $expression_a.result); } 
//	;
	
expression_a returns[const hammer::ast::expression* result]
//	: feature
//	| conditional_feature
: ;
	
list_of[hammer::ast::expressions_t* args]
	: ^(List (list_element { args->push_back($list_element.result); })+ )
	;           
list_element returns[const hammer::ast::expression* result]
	: //target
//	| public_expression
//	| expression_a
	  rule_invocation { result = $rule_invocation.result; }
	| path { result = $path.result; }
	| feature { result = $feature.result; }
	| ^(PublicTag feature) { result = SEMA->on_public_expr($PublicTag->getToken($PublicTag), $feature.result); }
	| Id { result = SEMA->on_id($Id->getToken($Id)); }
	;

path returns[const hammer::ast::expression* result]
@init { std::pair<pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN> bounds; }
	: ^(Path path_impl[&bounds]) { result = SEMA->on_path_like_seq(bounds.first, bounds.second); }
	;	

path_impl[std::pair<pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN>* bounds]
	: Slash path_element+ last=path_element { bounds->first = $Slash->getToken($Slash); bounds->second = $last.result; }
	| first=path_element path_element* last=path_element { bounds->first = $first.result; bounds->second = $last.result; }
	;

path_element returns[pANTLR3_COMMON_TOKEN result]
	: Id { result = $Id->getToken($Id); }
	| wildcard { result = $wildcard.result; }
	;

wildcard returns[pANTLR3_COMMON_TOKEN result]
	: ^(Wildcard wildcard_elem* last=wildcard_elem { result = $last.result; } )
	;

wildcard_elem returns[pANTLR3_COMMON_TOKEN result]
	: Id { result = $Id->getToken($Id); }
	| QuestionMark { result = $QuestionMark->getToken($QuestionMark); }
	| Asterix { result = $Asterix->getToken($Asterix); }
	;

public_tag[hammer::parscore::source_location* tag_loc] 
	: Public { *tag_loc = hammer::parscore::source_location($Public->getToken($Public)); } 
	;

rule_invocation returns[const hammer::ast::expression* result]
@init { DECLARE_TYPE(hammer::ast::expressions_t, args); }
	: ^(RuleInvocation name=Id arguments[&args]) { result = SEMA->on_target_or_rule_call($name->getToken($name), args); }
	;

feature returns[const hammer::ast::expression* result]
	: ^(Feature Id feature_value) { result = SEMA->on_feature($Id->getToken($Id), $feature_value.result); }
	;
	
feature_value returns[const hammer::ast::expression* result]
	: Id { result = SEMA->on_id($Id->getToken($Id)); }
	| path { result = $path.result; }
	 // target
	;