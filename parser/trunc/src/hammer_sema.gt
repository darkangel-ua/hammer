tree grammar hammer_sema;

options
{ 
        language = C; 
        tokenVocab = hammer;
        ASTLabelType = pANTLR3_BASE_TREE;
}

@header
{
#include <hammer/sema/actions.h>
#include <hammer/parscore/identifier.h>
#include <hammer/ast/requirement_set.h>
#include <hammer/ast/requirement.h>
#include <hammer/ast/path_like_seq.h>

#define SEMA static_cast<const hammer::sema::actions*>(PARSER->super)
}

hamfile returns [const hammer::ast::hamfile* result]
@init { hammer::ast::statements_t statements; }
        : ^(HAMFILE project_def statement[&statements]*) { result = SEMA->on_hamfile($project_def.result, statements); }
        ;
        
project_def returns[const hammer::ast::project_def* result]
@init { hammer::ast::expressions_t args; }
        : IMPLICIT_PROJECT_DEF { result = SEMA->on_implicit_project_def(); }
        | ^(EXPLICIT_PROJECT_DEF p='project' arguments[&args]) { result = SEMA->on_explicit_project_def($p->getToken($p), args); }
        ;

statement[hammer::ast::statements_t* statements]
	: target_def_or_rule_call { statements->push_back($target_def_or_rule_call.result); }
	;

target_def_or_rule_call returns[const hammer::ast::expression* result] 
@init { hammer::ast::expressions_t args; }
	: ^(TARGET_DECL_OR_RULE_CALL name=ID arguments[&args]) { result = SEMA->on_target_or_rule_call($name->getToken($name), args); }
	; 

arguments[hammer::ast::expressions_t* args]
        : ^(ARGUMENTS (expression { args->push_back($expression.result); })* )
        ;

expression returns[const hammer::ast::expression* result]
@init { hammer::ast::expressions_t args; }
	: EMPTY_EXPRESSION { result = SEMA->on_empty_expr(); }
        | list_of[&args] { result = SEMA->on_list_of(args); }
        | requirement_set { result = $requirement_set.result; }
        ;

requirement_set returns[const hammer::ast::requirement_set* result]
@init { hammer::ast::requirements_t requirements; }
 	: ^(REQUIREMENT_SET (requirement { requirements.push_back($requirement.result); })+) { result = SEMA->on_requirement_set(requirements); }
 	;

requirement returns[const hammer::ast::requirement* result]
	: simple_requirement { result = $simple_requirement.result; } 
	| conditional_requirement { result = $conditional_requirement.result; }
	;
	
conditional_requirement returns[const hammer::ast::requirement* result]
@init { hammer::ast::requirements_t requirements; }
	: ^(REQUIREMENT ^(CONDITIONAL_REQUIREMENT (con=simple_requirement { requirements.push_back($con.result); })+ COLON res=simple_requirement)) { result = SEMA->on_conditional_requirement(requirements, $res.result); }
	;
	
simple_requirement returns[const hammer::ast::requirement* result]
	: ^(REQUIREMENT name=ID requirement_value) { result = SEMA->on_simple_requirement($name->getToken($name), $requirement_value.result); }
	;

requirement_value returns[const hammer::ast::expression* result]
	: path_like_seq { result = $path_like_seq.result; }
	| target_ref { result = $target_ref.result; }
	;

list_of[hammer::ast::expressions_t* args]
	: ^(LIST_OF (list_of_impl { args->push_back($list_of_impl.result); })+ )
	;           

list_of_impl returns[const hammer::ast::expression* result ] 
	: path_like_seq { result = $path_like_seq.result; }
	| target_def_or_rule_call { result = $target_def_or_rule_call.result; }
	| target_ref { result = $target_ref.result; }
	;

target_ref returns[const hammer::ast::expression* result]
@init { hammer::parscore::identifier name; } 
	: ^(TARGET_REF path_like_seq target_ref_name[&name] target_ref_requirements) { result = SEMA->on_target_ref($path_like_seq.result, name, $target_ref_requirements.result); }
	;

target_ref_name[hammer::parscore::identifier* name] 
	: ^(TARGET_NAME EMPTY_TARGET_NAME)
	| ^(TARGET_NAME ID) { *name = hammer::parscore::identifier($ID->getToken($ID)); }
	;

target_ref_requirements returns[const hammer::ast::requirement_set* result]
	: requirement_set { result = $requirement_set.result; }
	| { result = NULL; }
	;

path_like_seq returns[const hammer::ast::path_like_seq* result]
@init { std::pair<pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN> bounds; } 
	: ^(PATH_LIKE_SEQ SLASH path_like_seq_impl[&bounds]) { result = SEMA->on_path_like_seq($SLASH->getToken($SLASH), bounds.second); }
	| ^(PATH_LIKE_SEQ path_like_seq_impl[&bounds])       { result = SEMA->on_path_like_seq(bounds.first, bounds.second); }
	; 

path_like_seq_impl[std::pair<pANTLR3_COMMON_TOKEN, pANTLR3_COMMON_TOKEN>* bounds] 
	: ID { bounds->first = bounds->second = $ID->getToken($ID); }
	| first=ID ID* last=ID { bounds->first = $first->getToken($first); bounds->second = $last->getToken($last); }
	;
