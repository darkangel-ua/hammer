/** \file
 *  This C source file was generated by $ANTLR version 3.1.1
 *
 *     -  From the grammar source file : hammer_sema_v2.gt
 *     -                            On : 2018-12-30 10:02:06
 *     -           for the tree parser : hammer_sema_v2TreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/

/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */


#include <hammer/sema/actions.h>
#include <hammer/parscore/identifier.h>
#include <hammer/ast/requirement_set.h>
#include <hammer/ast/path.h>
#include <hammer/ast/feature.h>
#include <hammer/ast/condition.h>

#define SEMA static_cast<hammer::sema::actions*>(PARSER->super)
#define DECLARE_TYPE(Type, name) Type name ( Type ::allocator_type{SEMA->get_context()});

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "hammer_sema_v2.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   phammer_sema_v2_##scope##_SCOPE
#define SCOPE_STACK(scope)  phammer_sema_v2_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->phammer_sema_v2_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   hammer_sema_v2TokenNames[51+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "Hamfile",
        (pANTLR3_UINT8) "Rule",
        (pANTLR3_UINT8) "Local",
        (pANTLR3_UINT8) "Explicit",
        (pANTLR3_UINT8) "Arguments",
        (pANTLR3_UINT8) "EmptyArgument",
        (pANTLR3_UINT8) "NamedArgument",
        (pANTLR3_UINT8) "Structure",
        (pANTLR3_UINT8) "EmptyField",
        (pANTLR3_UINT8) "NamedField",
        (pANTLR3_UINT8) "List",
        (pANTLR3_UINT8) "Feature",
        (pANTLR3_UINT8) "Condition",
        (pANTLR3_UINT8) "RuleInvocation",
        (pANTLR3_UINT8) "Path",
        (pANTLR3_UINT8) "PathRootName",
        (pANTLR3_UINT8) "PathTrailingSlash",
        (pANTLR3_UINT8) "TargetRef",
        (pANTLR3_UINT8) "TargetRefSpec",
        (pANTLR3_UINT8) "TargetRefBuildRequest",
        (pANTLR3_UINT8) "Wildcard",
        (pANTLR3_UINT8) "LogicalAnd",
        (pANTLR3_UINT8) "LogicalOr",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "Id",
        (pANTLR3_UINT8) "PublicTag",
        (pANTLR3_UINT8) "Slash",
        (pANTLR3_UINT8) "PathUri",
        (pANTLR3_UINT8) "DoubleSlash",
        (pANTLR3_UINT8) "QuestionMark",
        (pANTLR3_UINT8) "Asterix",
        (pANTLR3_UINT8) "DoubleAsterix",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "STRING_1",
        (pANTLR3_UINT8) "STRING_ID",
        (pANTLR3_UINT8) "STRING_ID1",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'->'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'&&'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static const hammer::ast::hamfile*	hamfile    (phammer_sema_v2 ctx);
static void	statement    (phammer_sema_v2 ctx, hammer::ast::statements_t* statements);
static const hammer::ast::statement*	top_level_rule_invocation    (phammer_sema_v2 ctx);
static void	target_def_prefix    (phammer_sema_v2 ctx, hammer::parscore::source_location* explicit_tag, hammer::parscore::source_location* local_tag);
static void	arguments    (phammer_sema_v2 ctx, hammer::ast::expressions_t* args);
static const hammer::ast::expression*	argument    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	named_argument    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	expression    (phammer_sema_v2 ctx);
static void	list_of    (phammer_sema_v2 ctx, hammer::ast::expressions_t* args);
static const hammer::ast::expression*	list_element    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	public_expression    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	expression_a    (phammer_sema_v2 ctx);
static const hammer::ast::path*	path    (phammer_sema_v2 ctx);
static void	path_root_name    (phammer_sema_v2 ctx, hammer::parscore::token& root_name);
static void	path_elements    (phammer_sema_v2 ctx, hammer::ast::expressions_t& elements);
static const hammer::ast::expression*	path_element    (phammer_sema_v2 ctx);
static void	path_trailing_slash    (phammer_sema_v2 ctx, hammer::parscore::token& trailing_slash);
static const hammer::ast::expression*	wildcard    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	wildcard_elem    (phammer_sema_v2 ctx);
static void	public_tag    (phammer_sema_v2 ctx, hammer::parscore::source_location* tag_loc);
static const hammer::ast::expression*	rule_invocation    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	struct_    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	struct_field    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	named_field    (phammer_sema_v2 ctx);
static const hammer::ast::feature*	feature    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	feature_value    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	target_ref    (phammer_sema_v2 ctx);
static const hammer::ast::path*	target_ref_impl    (phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request);
static void	target_ref_spec    (phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request);
static void	target_ref_build_request    (phammer_sema_v2 ctx, hammer::ast::features_t* build_request);
static const hammer::ast::expression*	condition    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	condition_condition    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	condition_result    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	logical_or    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	logical_and    (phammer_sema_v2 ctx);
static void	hammer_sema_v2Free(phammer_sema_v2 ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "hammer_sema_v2.gt";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new hammer_sema_v2 parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API phammer_sema_v2
hammer_sema_v2New   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return hammer_sema_v2NewSSD(instream, NULL);
}

/** \brief Create a new hammer_sema_v2 parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API phammer_sema_v2
hammer_sema_v2NewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    phammer_sema_v2 ctx;	    /* Context structure we will build and return   */
    
    ctx	= (phammer_sema_v2) ANTLR3_CALLOC(1, sizeof(hammer_sema_v2));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in hammer_sema_v2.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our hammer_sema_v2 interface
     */
    ctx->hamfile	= hamfile;
    ctx->statement	= statement;
    ctx->top_level_rule_invocation	= top_level_rule_invocation;
    ctx->target_def_prefix	= target_def_prefix;
    ctx->arguments	= arguments;
    ctx->argument	= argument;
    ctx->named_argument	= named_argument;
    ctx->expression	= expression;
    ctx->list_of	= list_of;
    ctx->list_element	= list_element;
    ctx->public_expression	= public_expression;
    ctx->expression_a	= expression_a;
    ctx->path	= path;
    ctx->path_root_name	= path_root_name;
    ctx->path_elements	= path_elements;
    ctx->path_element	= path_element;
    ctx->path_trailing_slash	= path_trailing_slash;
    ctx->wildcard	= wildcard;
    ctx->wildcard_elem	= wildcard_elem;
    ctx->public_tag	= public_tag;
    ctx->rule_invocation	= rule_invocation;
    ctx->struct_	= struct_;
    ctx->struct_field	= struct_field;
    ctx->named_field	= named_field;
    ctx->feature	= feature;
    ctx->feature_value	= feature_value;
    ctx->target_ref	= target_ref;
    ctx->target_ref_impl	= target_ref_impl;
    ctx->target_ref_spec	= target_ref_spec;
    ctx->target_ref_build_request	= target_ref_build_request;
    ctx->condition	= condition;
    ctx->condition_condition	= condition_condition;
    ctx->condition_result	= condition_result;
    ctx->logical_or	= logical_or;
    ctx->logical_and	= logical_and;
    ctx->free			= hammer_sema_v2Free;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = hammer_sema_v2TokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 hammer_sema_v2Free(phammer_sema_v2 ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return hammer_sema_v2TokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_Hamfile_in_hamfile81  */
static	ANTLR3_BITWORD FOLLOW_Hamfile_in_hamfile81_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Hamfile_in_hamfile81	= { FOLLOW_Hamfile_in_hamfile81_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_hamfile83  */
static	ANTLR3_BITWORD FOLLOW_statement_in_hamfile83_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000028) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_hamfile83	= { FOLLOW_statement_in_hamfile83_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_top_level_rule_invocation_in_statement115  */
static	ANTLR3_BITWORD FOLLOW_top_level_rule_invocation_in_statement115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_top_level_rule_invocation_in_statement115	= { FOLLOW_top_level_rule_invocation_in_statement115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Rule_in_top_level_rule_invocation138  */
static	ANTLR3_BITWORD FOLLOW_Rule_in_top_level_rule_invocation138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Rule_in_top_level_rule_invocation138	= { FOLLOW_Rule_in_top_level_rule_invocation138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_def_prefix_in_top_level_rule_invocation140  */
static	ANTLR3_BITWORD FOLLOW_target_def_prefix_in_top_level_rule_invocation140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_target_def_prefix_in_top_level_rule_invocation140	= { FOLLOW_target_def_prefix_in_top_level_rule_invocation140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_top_level_rule_invocation146  */
static	ANTLR3_BITWORD FOLLOW_Id_in_top_level_rule_invocation146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_top_level_rule_invocation146	= { FOLLOW_Id_in_top_level_rule_invocation146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_top_level_rule_invocation148  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_top_level_rule_invocation148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_top_level_rule_invocation148	= { FOLLOW_arguments_in_top_level_rule_invocation148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Local_in_target_def_prefix166  */
static	ANTLR3_BITWORD FOLLOW_Local_in_target_def_prefix166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Local_in_target_def_prefix166	= { FOLLOW_Local_in_target_def_prefix166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Explicit_in_target_def_prefix173  */
static	ANTLR3_BITWORD FOLLOW_Explicit_in_target_def_prefix173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Explicit_in_target_def_prefix173	= { FOLLOW_Explicit_in_target_def_prefix173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Arguments_in_arguments189  */
static	ANTLR3_BITWORD FOLLOW_Arguments_in_arguments189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Arguments_in_arguments189	= { FOLLOW_Arguments_in_arguments189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_arguments192  */
static	ANTLR3_BITWORD FOLLOW_argument_in_arguments192_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027CE08) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_arguments192	= { FOLLOW_argument_in_arguments192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyArgument_in_argument219  */
static	ANTLR3_BITWORD FOLLOW_EmptyArgument_in_argument219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyArgument_in_argument219	= { FOLLOW_EmptyArgument_in_argument219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_argument226  */
static	ANTLR3_BITWORD FOLLOW_expression_in_argument226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_argument226	= { FOLLOW_expression_in_argument226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_named_argument_in_argument233  */
static	ANTLR3_BITWORD FOLLOW_named_argument_in_argument233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_named_argument_in_argument233	= { FOLLOW_named_argument_in_argument233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedArgument_in_named_argument250  */
static	ANTLR3_BITWORD FOLLOW_NamedArgument_in_named_argument250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedArgument_in_named_argument250	= { FOLLOW_NamedArgument_in_named_argument250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_argument252  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_argument252_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027C800) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_argument252	= { FOLLOW_Id_in_named_argument252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_named_argument254  */
static	ANTLR3_BITWORD FOLLOW_expression_in_named_argument254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_named_argument254	= { FOLLOW_expression_in_named_argument254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedArgument_in_named_argument264  */
static	ANTLR3_BITWORD FOLLOW_NamedArgument_in_named_argument264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedArgument_in_named_argument264	= { FOLLOW_NamedArgument_in_named_argument264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_argument266  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_argument266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_argument266	= { FOLLOW_Id_in_named_argument266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyArgument_in_named_argument268  */
static	ANTLR3_BITWORD FOLLOW_EmptyArgument_in_named_argument268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyArgument_in_named_argument268	= { FOLLOW_EmptyArgument_in_named_argument268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_of_in_expression293  */
static	ANTLR3_BITWORD FOLLOW_list_of_in_expression293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_list_of_in_expression293	= { FOLLOW_list_of_in_expression293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_expression308  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_expression308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_expression308	= { FOLLOW_target_ref_in_expression308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_expression315  */
static	ANTLR3_BITWORD FOLLOW_path_in_expression315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_expression315	= { FOLLOW_path_in_expression315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_expression322  */
static	ANTLR3_BITWORD FOLLOW_Id_in_expression322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_expression322	= { FOLLOW_Id_in_expression322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_expression336  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_expression336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_expression336	= { FOLLOW_public_expression_in_expression336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_expression350  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_expression350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_expression350	= { FOLLOW_expression_a_in_expression350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_invocation_in_expression357  */
static	ANTLR3_BITWORD FOLLOW_rule_invocation_in_expression357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_invocation_in_expression357	= { FOLLOW_rule_invocation_in_expression357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_struct__in_expression364  */
static	ANTLR3_BITWORD FOLLOW_struct__in_expression364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_struct__in_expression364	= { FOLLOW_struct__in_expression364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_List_in_list_of380  */
static	ANTLR3_BITWORD FOLLOW_List_in_list_of380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_List_in_list_of380	= { FOLLOW_List_in_list_of380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_element_in_list_of383  */
static	ANTLR3_BITWORD FOLLOW_list_element_in_list_of383_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027C808) };
static  ANTLR3_BITSET_LIST FOLLOW_list_element_in_list_of383	= { FOLLOW_list_element_in_list_of383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_list_element413  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_list_element413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_list_element413	= { FOLLOW_target_ref_in_list_element413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_list_element420  */
static	ANTLR3_BITWORD FOLLOW_path_in_list_element420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_list_element420	= { FOLLOW_path_in_list_element420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_list_element427  */
static	ANTLR3_BITWORD FOLLOW_Id_in_list_element427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_list_element427	= { FOLLOW_Id_in_list_element427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_list_element441  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_list_element441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_list_element441	= { FOLLOW_public_expression_in_list_element441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_list_element455  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_list_element455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_list_element455	= { FOLLOW_expression_a_in_list_element455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_invocation_in_list_element462  */
static	ANTLR3_BITWORD FOLLOW_rule_invocation_in_list_element462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_invocation_in_list_element462	= { FOLLOW_rule_invocation_in_list_element462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_struct__in_list_element469  */
static	ANTLR3_BITWORD FOLLOW_struct__in_list_element469_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_struct__in_list_element469	= { FOLLOW_struct__in_list_element469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_public_expression485  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_public_expression485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_public_expression485	= { FOLLOW_PublicTag_in_public_expression485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_public_expression487  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_public_expression487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_public_expression487	= { FOLLOW_expression_a_in_public_expression487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_expression_a503  */
static	ANTLR3_BITWORD FOLLOW_feature_in_expression_a503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_expression_a503	= { FOLLOW_feature_in_expression_a503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_in_expression_a510  */
static	ANTLR3_BITWORD FOLLOW_condition_in_expression_a510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_in_expression_a510	= { FOLLOW_condition_in_expression_a510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Path_in_path532  */
static	ANTLR3_BITWORD FOLLOW_Path_in_path532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Path_in_path532	= { FOLLOW_Path_in_path532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_root_name_in_path534  */
static	ANTLR3_BITWORD FOLLOW_path_root_name_in_path534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000011000000) };
static  ANTLR3_BITSET_LIST FOLLOW_path_root_name_in_path534	= { FOLLOW_path_root_name_in_path534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_elements_in_path538  */
static	ANTLR3_BITWORD FOLLOW_path_elements_in_path538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_elements_in_path538	= { FOLLOW_path_elements_in_path538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_trailing_slash_in_path541  */
static	ANTLR3_BITWORD FOLLOW_path_trailing_slash_in_path541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_trailing_slash_in_path541	= { FOLLOW_path_trailing_slash_in_path541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PathRootName_in_path_root_name558  */
static	ANTLR3_BITWORD FOLLOW_PathRootName_in_path_root_name558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PathRootName_in_path_root_name558	= { FOLLOW_PathRootName_in_path_root_name558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_element_in_path_elements572  */
static	ANTLR3_BITWORD FOLLOW_path_element_in_path_elements572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000011000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_element_in_path_elements572	= { FOLLOW_path_element_in_path_elements572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_path_element589  */
static	ANTLR3_BITWORD FOLLOW_Id_in_path_element589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_path_element589	= { FOLLOW_Id_in_path_element589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wildcard_in_path_element596  */
static	ANTLR3_BITWORD FOLLOW_wildcard_in_path_element596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wildcard_in_path_element596	= { FOLLOW_wildcard_in_path_element596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PathTrailingSlash_in_path_trailing_slash609  */
static	ANTLR3_BITWORD FOLLOW_PathTrailingSlash_in_path_trailing_slash609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PathTrailingSlash_in_path_trailing_slash609	= { FOLLOW_PathTrailingSlash_in_path_trailing_slash609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Wildcard_in_wildcard630  */
static	ANTLR3_BITWORD FOLLOW_Wildcard_in_wildcard630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Wildcard_in_wildcard630	= { FOLLOW_Wildcard_in_wildcard630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wildcard_elem_in_wildcard633  */
static	ANTLR3_BITWORD FOLLOW_wildcard_elem_in_wildcard633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000E10000008) };
static  ANTLR3_BITSET_LIST FOLLOW_wildcard_elem_in_wildcard633	= { FOLLOW_wildcard_elem_in_wildcard633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_wildcard_elem655  */
static	ANTLR3_BITWORD FOLLOW_Id_in_wildcard_elem655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_wildcard_elem655	= { FOLLOW_Id_in_wildcard_elem655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QuestionMark_in_wildcard_elem662  */
static	ANTLR3_BITWORD FOLLOW_QuestionMark_in_wildcard_elem662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QuestionMark_in_wildcard_elem662	= { FOLLOW_QuestionMark_in_wildcard_elem662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Asterix_in_wildcard_elem669  */
static	ANTLR3_BITWORD FOLLOW_Asterix_in_wildcard_elem669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Asterix_in_wildcard_elem669	= { FOLLOW_Asterix_in_wildcard_elem669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DoubleAsterix_in_wildcard_elem676  */
static	ANTLR3_BITWORD FOLLOW_DoubleAsterix_in_wildcard_elem676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DoubleAsterix_in_wildcard_elem676	= { FOLLOW_DoubleAsterix_in_wildcard_elem676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_public_tag691  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_public_tag691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_public_tag691	= { FOLLOW_PublicTag_in_public_tag691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RuleInvocation_in_rule_invocation714  */
static	ANTLR3_BITWORD FOLLOW_RuleInvocation_in_rule_invocation714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RuleInvocation_in_rule_invocation714	= { FOLLOW_RuleInvocation_in_rule_invocation714_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_rule_invocation718  */
static	ANTLR3_BITWORD FOLLOW_Id_in_rule_invocation718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_rule_invocation718	= { FOLLOW_Id_in_rule_invocation718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_rule_invocation720  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_rule_invocation720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_rule_invocation720	= { FOLLOW_arguments_in_rule_invocation720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Structure_in_struct_743  */
static	ANTLR3_BITWORD FOLLOW_Structure_in_struct_743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Structure_in_struct_743	= { FOLLOW_Structure_in_struct_743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_struct_field_in_struct_746  */
static	ANTLR3_BITWORD FOLLOW_struct_field_in_struct_746_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027F808) };
static  ANTLR3_BITSET_LIST FOLLOW_struct_field_in_struct_746	= { FOLLOW_struct_field_in_struct_746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyField_in_struct_field767  */
static	ANTLR3_BITWORD FOLLOW_EmptyField_in_struct_field767_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyField_in_struct_field767	= { FOLLOW_EmptyField_in_struct_field767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_named_field_in_struct_field774  */
static	ANTLR3_BITWORD FOLLOW_named_field_in_struct_field774_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_named_field_in_struct_field774	= { FOLLOW_named_field_in_struct_field774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_struct_field781  */
static	ANTLR3_BITWORD FOLLOW_expression_in_struct_field781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_struct_field781	= { FOLLOW_expression_in_struct_field781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedField_in_named_field797  */
static	ANTLR3_BITWORD FOLLOW_NamedField_in_named_field797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedField_in_named_field797	= { FOLLOW_NamedField_in_named_field797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_field799  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_field799_bits[]	= { ANTLR3_UINT64_LIT(0x000000003027C800) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_field799	= { FOLLOW_Id_in_named_field799_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_named_field801  */
static	ANTLR3_BITWORD FOLLOW_expression_in_named_field801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_named_field801	= { FOLLOW_expression_in_named_field801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedField_in_named_field811  */
static	ANTLR3_BITWORD FOLLOW_NamedField_in_named_field811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedField_in_named_field811	= { FOLLOW_NamedField_in_named_field811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_field813  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_field813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_field813	= { FOLLOW_Id_in_named_field813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyField_in_named_field815  */
static	ANTLR3_BITWORD FOLLOW_EmptyField_in_named_field815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyField_in_named_field815	= { FOLLOW_EmptyField_in_named_field815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Feature_in_feature833  */
static	ANTLR3_BITWORD FOLLOW_Feature_in_feature833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Feature_in_feature833	= { FOLLOW_Feature_in_feature833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_feature835  */
static	ANTLR3_BITWORD FOLLOW_Id_in_feature835_bits[]	= { ANTLR3_UINT64_LIT(0x0000000030240000) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_feature835	= { FOLLOW_Id_in_feature835_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_value_in_feature837  */
static	ANTLR3_BITWORD FOLLOW_feature_value_in_feature837_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_value_in_feature837	= { FOLLOW_feature_value_in_feature837_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_feature_value855  */
static	ANTLR3_BITWORD FOLLOW_Id_in_feature_value855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_feature_value855	= { FOLLOW_Id_in_feature_value855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_feature_value862  */
static	ANTLR3_BITWORD FOLLOW_path_in_feature_value862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_feature_value862	= { FOLLOW_path_in_feature_value862_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_feature_value869  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_feature_value869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_feature_value869	= { FOLLOW_target_ref_in_feature_value869_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_target_ref890  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_target_ref890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_target_ref890	= { FOLLOW_PublicTag_in_target_ref890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_impl_in_target_ref892  */
static	ANTLR3_BITWORD FOLLOW_target_ref_impl_in_target_ref892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_impl_in_target_ref892	= { FOLLOW_target_ref_impl_in_target_ref892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_impl_in_target_ref901  */
static	ANTLR3_BITWORD FOLLOW_target_ref_impl_in_target_ref901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_impl_in_target_ref901	= { FOLLOW_target_ref_impl_in_target_ref901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRef_in_target_ref_impl920  */
static	ANTLR3_BITWORD FOLLOW_TargetRef_in_target_ref_impl920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRef_in_target_ref_impl920	= { FOLLOW_TargetRef_in_target_ref_impl920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_target_ref_impl922  */
static	ANTLR3_BITWORD FOLLOW_path_in_target_ref_impl922_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_target_ref_impl922	= { FOLLOW_path_in_target_ref_impl922_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_spec_in_target_ref_impl924  */
static	ANTLR3_BITWORD FOLLOW_target_ref_spec_in_target_ref_impl924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_spec_in_target_ref_impl924	= { FOLLOW_target_ref_spec_in_target_ref_impl924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRef_in_target_ref_impl935  */
static	ANTLR3_BITWORD FOLLOW_TargetRef_in_target_ref_impl935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRef_in_target_ref_impl935	= { FOLLOW_TargetRef_in_target_ref_impl935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_target_ref_impl937  */
static	ANTLR3_BITWORD FOLLOW_Id_in_target_ref_impl937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400008) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_target_ref_impl937	= { FOLLOW_Id_in_target_ref_impl937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_spec_in_target_ref_impl939  */
static	ANTLR3_BITWORD FOLLOW_target_ref_spec_in_target_ref_impl939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_spec_in_target_ref_impl939	= { FOLLOW_target_ref_spec_in_target_ref_impl939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefSpec_in_target_ref_spec958  */
static	ANTLR3_BITWORD FOLLOW_TargetRefSpec_in_target_ref_spec958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefSpec_in_target_ref_spec958	= { FOLLOW_TargetRefSpec_in_target_ref_spec958_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_target_ref_spec960  */
static	ANTLR3_BITWORD FOLLOW_Id_in_target_ref_spec960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800008) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_target_ref_spec960	= { FOLLOW_Id_in_target_ref_spec960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_build_request_in_target_ref_spec962  */
static	ANTLR3_BITWORD FOLLOW_target_ref_build_request_in_target_ref_spec962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_build_request_in_target_ref_spec962	= { FOLLOW_target_ref_build_request_in_target_ref_spec962_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefSpec_in_target_ref_spec973  */
static	ANTLR3_BITWORD FOLLOW_TargetRefSpec_in_target_ref_spec973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefSpec_in_target_ref_spec973	= { FOLLOW_TargetRefSpec_in_target_ref_spec973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_build_request_in_target_ref_spec975  */
static	ANTLR3_BITWORD FOLLOW_target_ref_build_request_in_target_ref_spec975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_build_request_in_target_ref_spec975	= { FOLLOW_target_ref_build_request_in_target_ref_spec975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefBuildRequest_in_target_ref_build_request990  */
static	ANTLR3_BITWORD FOLLOW_TargetRefBuildRequest_in_target_ref_build_request990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefBuildRequest_in_target_ref_build_request990	= { FOLLOW_TargetRefBuildRequest_in_target_ref_build_request990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_target_ref_build_request993  */
static	ANTLR3_BITWORD FOLLOW_feature_in_target_ref_build_request993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008008) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_target_ref_build_request993	= { FOLLOW_feature_in_target_ref_build_request993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Condition_in_condition1013  */
static	ANTLR3_BITWORD FOLLOW_Condition_in_condition1013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Condition_in_condition1013	= { FOLLOW_Condition_in_condition1013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_condition1015  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_condition1015_bits[]	= { ANTLR3_UINT64_LIT(0x000000002000C000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_condition1015	= { FOLLOW_condition_condition_in_condition1015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_result_in_condition1017  */
static	ANTLR3_BITWORD FOLLOW_condition_result_in_condition1017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_result_in_condition1017	= { FOLLOW_condition_result_in_condition1017_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_condition_condition1034  */
static	ANTLR3_BITWORD FOLLOW_feature_in_condition_condition1034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_condition_condition1034	= { FOLLOW_feature_in_condition_condition1034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logical_or_in_condition_condition1041  */
static	ANTLR3_BITWORD FOLLOW_logical_or_in_condition_condition1041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logical_or_in_condition_condition1041	= { FOLLOW_logical_or_in_condition_condition1041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logical_and_in_condition_condition1048  */
static	ANTLR3_BITWORD FOLLOW_logical_and_in_condition_condition1048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logical_and_in_condition_condition1048	= { FOLLOW_logical_and_in_condition_condition1048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_condition_result1068  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_condition_result1068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_condition_result1068	= { FOLLOW_public_expression_in_condition_result1068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_condition_result1076  */
static	ANTLR3_BITWORD FOLLOW_feature_in_condition_result1076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_condition_result1076	= { FOLLOW_feature_in_condition_result1076_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_of_in_condition_result1083  */
static	ANTLR3_BITWORD FOLLOW_list_of_in_condition_result1083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_list_of_in_condition_result1083	= { FOLLOW_list_of_in_condition_result1083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LogicalOr_in_logical_or1101  */
static	ANTLR3_BITWORD FOLLOW_LogicalOr_in_logical_or1101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LogicalOr_in_logical_or1101	= { FOLLOW_LogicalOr_in_logical_or1101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_or1105  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_or1105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006008000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_or1105	= { FOLLOW_condition_condition_in_logical_or1105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_or1109  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_or1109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_or1109	= { FOLLOW_condition_condition_in_logical_or1109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LogicalAnd_in_logical_and1127  */
static	ANTLR3_BITWORD FOLLOW_LogicalAnd_in_logical_and1127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LogicalAnd_in_logical_and1127	= { FOLLOW_LogicalAnd_in_logical_and1127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_and1131  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_and1131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006008000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_and1131	= { FOLLOW_condition_condition_in_logical_and1131_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_and1135  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_and1135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_and1135	= { FOLLOW_condition_condition_in_logical_and1135_bits, 1	};
     


/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );
 */
static const ANTLR3_INT32 dfa7_eot[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_eof[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_min[11] =
    {
	11, -1, 2, -1, -1, -1, -1, -1, -1, 15, -1
    };
static const ANTLR3_INT32 dfa7_max[11] =
    {
	29, -1, 2, -1, -1, -1, -1, -1, -1, 21, -1
    };
static const ANTLR3_INT32 dfa7_accept[11] =
    {
	-1, 1, -1, 2, 3, 4, 6, 7, 8, -1, 5
    };
static const ANTLR3_INT32 dfa7_special[11] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa7_T_empty	    NULL

static const ANTLR3_INT32 dfa7_T0[] =
    {
	8, -1, -1, 1, 6, 6, 7, 4, -1, -1, 3, -1, -1, -1, -1, -1, -1, 5, 2
    };static const ANTLR3_INT32 dfa7_T1[] =
    {
	10, 10, -1, -1, -1, -1, 3
    };static const ANTLR3_INT32 dfa7_T2[] =
    {
	9
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa7_transitions[] =
{
    dfa7_T0, dfa7_T_empty, dfa7_T2, dfa7_T_empty, dfa7_T_empty, dfa7_T_empty, 
    dfa7_T_empty, dfa7_T_empty, dfa7_T_empty, dfa7_T1, dfa7_T_empty	
};


/* Declare tracking structure for Cyclic DFA 7
 */
static
ANTLR3_CYCLIC_DFA cdfa7
    =	{
	    7,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa7_eot,	    /* EOT table			    */
	    dfa7_eof,	    /* EOF table			    */
	    dfa7_min,	    /* Minimum tokens for each state    */
	    dfa7_max,	    /* Maximum tokens for each state    */
	    dfa7_accept,	/* Accept table			    */
	    dfa7_special,	/* Special transition states	    */
	    dfa7_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 7
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    75:1: list_element returns [const hammer::ast::expression* result] : ( target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );
 */
static const ANTLR3_INT32 dfa9_eot[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_eof[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_min[10] =
    {
	11, 2, -1, -1, -1, -1, -1, -1, 15, -1
    };
static const ANTLR3_INT32 dfa9_max[10] =
    {
	29, 2, -1, -1, -1, -1, -1, -1, 21, -1
    };
static const ANTLR3_INT32 dfa9_accept[10] =
    {
	-1, -1, 1, 2, 3, 5, 6, 7, -1, 4
    };
static const ANTLR3_INT32 dfa9_special[10] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa9_T_empty	    NULL

static const ANTLR3_INT32 dfa9_T0[] =
    {
	9, 9, -1, -1, -1, -1, 2
    };static const ANTLR3_INT32 dfa9_T1[] =
    {
	7, -1, -1, -1, 5, 5, 6, 3, -1, -1, 2, -1, -1, -1, -1, -1, -1, 4, 1
    };static const ANTLR3_INT32 dfa9_T2[] =
    {
	8
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa9_transitions[] =
{
    dfa9_T1, dfa9_T2, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T0, dfa9_T_empty	
};


/* Declare tracking structure for Cyclic DFA 9
 */
static
ANTLR3_CYCLIC_DFA cdfa9
    =	{
	    9,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"75:1: list_element returns [const hammer::ast::expression* result] : ( target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa9_eot,	    /* EOT table			    */
	    dfa9_eof,	    /* EOF table			    */
	    dfa9_min,	    /* Minimum tokens for each state    */
	    dfa9_max,	    /* Maximum tokens for each state    */
	    dfa9_accept,	/* Accept table			    */
	    dfa9_special,	/* Special transition states	    */
	    dfa9_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 9
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */ 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start hamfile
 * hammer_sema_v2.gt:22:1: hamfile returns [const hammer::ast::hamfile* result] : ^( Hamfile ( statement[&statements] )* ) ;
 */
static const hammer::ast::hamfile*
hamfile(phammer_sema_v2 ctx)
{   
    const hammer::ast::hamfile* result = NULL;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::statements_t, statements); 
    {
        // hammer_sema_v2.gt:24:2: ( ^( Hamfile ( statement[&statements] )* ) )
        // hammer_sema_v2.gt:24:4: ^( Hamfile ( statement[&statements] )* )
        {
             MATCHT(Hamfile, &FOLLOW_Hamfile_in_hamfile81); 
            if  (HASEXCEPTION())
            {
                goto rulehamfileEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulehamfileEx;
                }


                // hammer_sema_v2.gt:24:14: ( statement[&statements] )*

                for (;;)
                {
                    int alt1=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA1_0 = LA(1);
                        if ( (LA1_0 == Rule) ) 
                        {
                            alt1=1;
                        }

                    }
                    switch (alt1) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:24:14: statement[&statements]
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_hamfile83);
                	        statement(ctx, &statements);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulehamfileEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop1;	/* break out of the loop */
                	    break;
                    }
                }
                loop1: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulehamfileEx;
                }

            }
            {
                 result = SEMA->on_hamfile(statements); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehamfileEx; /* Prevent compiler warnings */
    rulehamfileEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end hamfile */

/** 
 * $ANTLR start statement
 * hammer_sema_v2.gt:27:1: statement[hammer::ast::statements_t* statements] : top_level_rule_invocation ;
 */
static void
statement(phammer_sema_v2 ctx, hammer::ast::statements_t* statements)
{   
    const hammer::ast::statement* top_level_rule_invocation1;
    #undef	RETURN_TYPE_top_level_rule_invocation1
    #define	RETURN_TYPE_top_level_rule_invocation1 const hammer::ast::statement*

    /* Initialize rule variables
     */


    top_level_rule_invocation1 = NULL;

    {
        // hammer_sema_v2.gt:28:2: ( top_level_rule_invocation )
        // hammer_sema_v2.gt:28:4: top_level_rule_invocation
        {
            FOLLOWPUSH(FOLLOW_top_level_rule_invocation_in_statement115);
            top_level_rule_invocation1=top_level_rule_invocation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatementEx;
            }

            {
                 statements->push_back(top_level_rule_invocation1); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start top_level_rule_invocation
 * hammer_sema_v2.gt:31:1: top_level_rule_invocation returns [const hammer::ast::statement* result] : ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] ) ;
 */
static const hammer::ast::statement*
top_level_rule_invocation(phammer_sema_v2 ctx)
{   
    const hammer::ast::statement* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
            hammer::parscore::source_location explicit_tag, local_tag;

    name       = NULL;

    {
        // hammer_sema_v2.gt:35:2: ( ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] ) )
        // hammer_sema_v2.gt:35:4: ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] )
        {
             MATCHT(Rule, &FOLLOW_Rule_in_top_level_rule_invocation138); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            // hammer_sema_v2.gt:35:11: ( target_def_prefix[&explicit_tag, &local_tag] )?
            {
                int alt2=2;
                {
                    int LA2_0 = LA(1);
                    if ( (((LA2_0 >= Local) && (LA2_0 <= Explicit))) ) 
                    {
                        alt2=1;
                    }
                }
                switch (alt2) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:35:11: target_def_prefix[&explicit_tag, &local_tag]
            	    {
            	        FOLLOWPUSH(FOLLOW_target_def_prefix_in_top_level_rule_invocation140);
            	        target_def_prefix(ctx, &explicit_tag, &local_tag);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletop_level_rule_invocationEx;
            	        }


            	    }
            	    break;

                }
            }
            name = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_top_level_rule_invocation146); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }

            FOLLOWPUSH(FOLLOW_arguments_in_top_level_rule_invocation148);
            arguments(ctx, &args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }

            {
                 result = SEMA->on_top_level_rule_invocation(explicit_tag, local_tag, name->getToken(name), args); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletop_level_rule_invocationEx; /* Prevent compiler warnings */
    ruletop_level_rule_invocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end top_level_rule_invocation */

/** 
 * $ANTLR start target_def_prefix
 * hammer_sema_v2.gt:38:1: target_def_prefix[hammer::parscore::source_location* explicit_tag,\n\t\t hammer::parscore::source_location* local_tag] : ( Local | Explicit );
 */
static void
target_def_prefix(phammer_sema_v2 ctx, hammer::parscore::source_location* explicit_tag, hammer::parscore::source_location* local_tag)
{   
    pANTLR3_BASE_TREE    Local2;
    pANTLR3_BASE_TREE    Explicit3;

    /* Initialize rule variables
     */


    Local2       = NULL;
    Explicit3       = NULL;

    {
        {
            //  hammer_sema_v2.gt:40:2: ( Local | Explicit )
            
            ANTLR3_UINT32 alt3;

            alt3=2;


            {
                int LA3_0 = LA(1);
                if ( (LA3_0 == Local) ) 
                {
                    alt3=1;
                }
                else if ( (LA3_0 == Explicit) ) 
                {
                    alt3=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 3;
                    EXCEPTION->state        = 0;


                    goto ruletarget_def_prefixEx;
                }
            }
            switch (alt3) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:40:4: Local
        	    {
        	        Local2 = (pANTLR3_BASE_TREE) MATCHT(Local, &FOLLOW_Local_in_target_def_prefix166); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_def_prefixEx;
        	        }

        	        {
        	             *local_tag = hammer::parscore::source_location(Local2->getToken(Local2)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:41:4: Explicit
        	    {
        	        Explicit3 = (pANTLR3_BASE_TREE) MATCHT(Explicit, &FOLLOW_Explicit_in_target_def_prefix173); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_def_prefixEx;
        	        }

        	        {
        	             *explicit_tag = hammer::parscore::source_location(Explicit3->getToken(Explicit3)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_def_prefixEx; /* Prevent compiler warnings */
    ruletarget_def_prefixEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_def_prefix */

/** 
 * $ANTLR start arguments
 * hammer_sema_v2.gt:44:1: arguments[hammer::ast::expressions_t* args] : ^( Arguments ( argument )* ) ;
 */
static void
arguments(phammer_sema_v2 ctx, hammer::ast::expressions_t* args)
{   
    const hammer::ast::expression* argument4;
    #undef	RETURN_TYPE_argument4
    #define	RETURN_TYPE_argument4 const hammer::ast::expression*

    /* Initialize rule variables
     */


    argument4 = NULL;

    {
        // hammer_sema_v2.gt:45:2: ( ^( Arguments ( argument )* ) )
        // hammer_sema_v2.gt:45:4: ^( Arguments ( argument )* )
        {
             MATCHT(Arguments, &FOLLOW_Arguments_in_arguments189); 
            if  (HASEXCEPTION())
            {
                goto ruleargumentsEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargumentsEx;
                }


                // hammer_sema_v2.gt:45:16: ( argument )*

                for (;;)
                {
                    int alt4=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA4_0 = LA(1);
                        if ( (((LA4_0 >= EmptyArgument) && (LA4_0 <= Structure)) || ((LA4_0 >= List) && (LA4_0 <= Path)) || LA4_0 == TargetRef || ((LA4_0 >= Id) && (LA4_0 <= PublicTag))) ) 
                        {
                            alt4=1;
                        }

                    }
                    switch (alt4) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:45:17: argument
                	    {
                	        FOLLOWPUSH(FOLLOW_argument_in_arguments192);
                	        argument4=argument(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleargumentsEx;
                	        }

                	        {
                	             args->push_back(argument4); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop4;	/* break out of the loop */
                	    break;
                    }
                }
                loop4: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargumentsEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentsEx; /* Prevent compiler warnings */
    ruleargumentsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end arguments */

/** 
 * $ANTLR start argument
 * hammer_sema_v2.gt:48:1: argument returns [const hammer::ast::expression* result] : ( EmptyArgument | expression | named_argument );
 */
static const hammer::ast::expression*
argument(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    EmptyArgument5;
    const hammer::ast::expression* expression6;
    #undef	RETURN_TYPE_expression6
    #define	RETURN_TYPE_expression6 const hammer::ast::expression*

    const hammer::ast::expression* named_argument7;
    #undef	RETURN_TYPE_named_argument7
    #define	RETURN_TYPE_named_argument7 const hammer::ast::expression*

    /* Initialize rule variables
     */


    EmptyArgument5       = NULL;
    expression6 = NULL;
    named_argument7 = NULL;

    {
        {
            //  hammer_sema_v2.gt:49:2: ( EmptyArgument | expression | named_argument )
            
            ANTLR3_UINT32 alt5;

            alt5=3;

            switch ( LA(1) ) 
            {
            case EmptyArgument:
            	{
            		alt5=1;
            	}
                break;
            case Structure:
            case List:
            case Feature:
            case Condition:
            case RuleInvocation:
            case Path:
            case TargetRef:
            case Id:
            case PublicTag:
            	{
            		alt5=2;
            	}
                break;
            case NamedArgument:
            	{
            		alt5=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;
            }

            switch (alt5) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:49:4: EmptyArgument
        	    {
        	        EmptyArgument5 = (pANTLR3_BASE_TREE) MATCHT(EmptyArgument, &FOLLOW_EmptyArgument_in_argument219); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = SEMA->on_empty_expr(EmptyArgument5->getToken(EmptyArgument5)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:50:4: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_argument226);
        	        expression6=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = expression6; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:51:4: named_argument
        	    {
        	        FOLLOWPUSH(FOLLOW_named_argument_in_argument233);
        	        named_argument7=named_argument(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = named_argument7; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end argument */

/** 
 * $ANTLR start named_argument
 * hammer_sema_v2.gt:54:1: named_argument returns [const hammer::ast::expression* result] : ( ^( NamedArgument Id expression ) | ^( NamedArgument Id EmptyArgument ) );
 */
static const hammer::ast::expression*
named_argument(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id8;
    pANTLR3_BASE_TREE    Id10;
    pANTLR3_BASE_TREE    EmptyArgument11;
    const hammer::ast::expression* expression9;
    #undef	RETURN_TYPE_expression9
    #define	RETURN_TYPE_expression9 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id8       = NULL;
    Id10       = NULL;
    EmptyArgument11       = NULL;
    expression9 = NULL;

    {
        {
            //  hammer_sema_v2.gt:55:2: ( ^( NamedArgument Id expression ) | ^( NamedArgument Id EmptyArgument ) )
            
            ANTLR3_UINT32 alt6;

            alt6=2;


            {
                int LA6_0 = LA(1);
                if ( (LA6_0 == NamedArgument) ) 
                {

                    {
                        int LA6_1 = LA(2);
                        if ( (LA6_1 == DOWN) ) 
                        {

                            {
                                int LA6_2 = LA(3);
                                if ( (LA6_2 == Id) ) 
                                {

                                    {
                                        int LA6_3 = LA(4);
                                        if ( (LA6_3 == EmptyArgument) ) 
                                        {
                                            alt6=2;
                                        }
                                        else if ( (LA6_3 == Structure || ((LA6_3 >= List) && (LA6_3 <= Path)) || LA6_3 == TargetRef || ((LA6_3 >= Id) && (LA6_3 <= PublicTag))) ) 
                                        {
                                            alt6=1;
                                        }
                                        else 
                                        {
                                        
                                            CONSTRUCTEX();
                                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            EXCEPTION->message      = (void *)"";
                                            EXCEPTION->decisionNum  = 6;
                                            EXCEPTION->state        = 3;


                                            goto rulenamed_argumentEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 6;
                                    EXCEPTION->state        = 2;


                                    goto rulenamed_argumentEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 6;
                            EXCEPTION->state        = 1;


                            goto rulenamed_argumentEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 6;
                    EXCEPTION->state        = 0;


                    goto rulenamed_argumentEx;
                }
            }
            switch (alt6) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:55:4: ^( NamedArgument Id expression )
        	    {
        	         MATCHT(NamedArgument, &FOLLOW_NamedArgument_in_named_argument250); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        Id8 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_argument252); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_named_argument254);
        	        expression9=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id8->getToken(Id8), expression9); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:56:4: ^( NamedArgument Id EmptyArgument )
        	    {
        	         MATCHT(NamedArgument, &FOLLOW_NamedArgument_in_named_argument264); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        Id10 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_argument266); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        EmptyArgument11 = (pANTLR3_BASE_TREE) MATCHT(EmptyArgument, &FOLLOW_EmptyArgument_in_named_argument268); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id10->getToken(Id10), SEMA->on_empty_expr(EmptyArgument11->getToken(EmptyArgument11))); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenamed_argumentEx; /* Prevent compiler warnings */
    rulenamed_argumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end named_argument */

/** 
 * $ANTLR start expression
 * hammer_sema_v2.gt:59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );
 */
static const hammer::ast::expression*
expression(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id14;
    const hammer::ast::expression* target_ref12;
    #undef	RETURN_TYPE_target_ref12
    #define	RETURN_TYPE_target_ref12 const hammer::ast::expression*

    const hammer::ast::path* path13;
    #undef	RETURN_TYPE_path13
    #define	RETURN_TYPE_path13 const hammer::ast::path*

    const hammer::ast::expression* public_expression15;
    #undef	RETURN_TYPE_public_expression15
    #define	RETURN_TYPE_public_expression15 const hammer::ast::expression*

    const hammer::ast::expression* expression_a16;
    #undef	RETURN_TYPE_expression_a16
    #define	RETURN_TYPE_expression_a16 const hammer::ast::expression*

    const hammer::ast::expression* rule_invocation17;
    #undef	RETURN_TYPE_rule_invocation17
    #define	RETURN_TYPE_rule_invocation17 const hammer::ast::expression*

    const hammer::ast::expression* struct_18;
    #undef	RETURN_TYPE_struct_18
    #define	RETURN_TYPE_struct_18 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
    Id14       = NULL;
    target_ref12 = NULL;
    path13 = NULL;
    public_expression15 = NULL;
    expression_a16 = NULL;
    rule_invocation17 = NULL;
    struct_18 = NULL;

    {
        {
            //  hammer_sema_v2.gt:61:2: ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ )
            
            ANTLR3_UINT32 alt7;

            alt7=8;

            alt7 = cdfa7.predict(ctx, RECOGNIZER, ISTREAM, &cdfa7);
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }

            switch (alt7) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:61:4: list_of[&args]
        	    {
        	        FOLLOWPUSH(FOLLOW_list_of_in_expression293);
        	        list_of(ctx, &args);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = SEMA->on_list_of(args); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:62:11: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_expression308);
        	        target_ref12=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = target_ref12; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:63:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_expression315);
        	        path13=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = path13; 
        	        }

        	    }
        	    break;
        	case 4:
        	    // hammer_sema_v2.gt:64:4: Id
        	    {
        	        Id14 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_expression322); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id14->getToken(Id14)); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // hammer_sema_v2.gt:65:11: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_expression336);
        	        public_expression15=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = public_expression15; 
        	        }

        	    }
        	    break;
        	case 6:
        	    // hammer_sema_v2.gt:66:11: expression_a
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_a_in_expression350);
        	        expression_a16=expression_a(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = expression_a16; 
        	        }

        	    }
        	    break;
        	case 7:
        	    // hammer_sema_v2.gt:67:4: rule_invocation
        	    {
        	        FOLLOWPUSH(FOLLOW_rule_invocation_in_expression357);
        	        rule_invocation17=rule_invocation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = rule_invocation17; 
        	        }

        	    }
        	    break;
        	case 8:
        	    // hammer_sema_v2.gt:68:4: struct_
        	    {
        	        FOLLOWPUSH(FOLLOW_struct__in_expression364);
        	        struct_18=struct_(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = struct_18; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end expression */

/** 
 * $ANTLR start list_of
 * hammer_sema_v2.gt:72:1: list_of[hammer::ast::expressions_t* args] : ^( List ( list_element )+ ) ;
 */
static void
list_of(phammer_sema_v2 ctx, hammer::ast::expressions_t* args)
{   
    const hammer::ast::expression* list_element19;
    #undef	RETURN_TYPE_list_element19
    #define	RETURN_TYPE_list_element19 const hammer::ast::expression*

    /* Initialize rule variables
     */


    list_element19 = NULL;

    {
        // hammer_sema_v2.gt:73:2: ( ^( List ( list_element )+ ) )
        // hammer_sema_v2.gt:73:4: ^( List ( list_element )+ )
        {
             MATCHT(List, &FOLLOW_List_in_list_of380); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }

            // hammer_sema_v2.gt:73:11: ( list_element )+
            {
                int cnt8=0;

                for (;;)
                {
                    int alt8=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA8_0 = LA(1);
            	    if ( (LA8_0 == Structure || ((LA8_0 >= Feature) && (LA8_0 <= Path)) || LA8_0 == TargetRef || ((LA8_0 >= Id) && (LA8_0 <= PublicTag))) ) 
            	    {
            	        alt8=1;
            	    }

            	}
            	switch (alt8) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:73:12: list_element
            	        {
            	            FOLLOWPUSH(FOLLOW_list_element_in_list_of383);
            	            list_element19=list_element(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulelist_ofEx;
            	            }

            	            {
            	                 args->push_back(list_element19); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt8 >= 1 )
            		{
            		    goto loop8;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulelist_ofEx;
            	}
            	cnt8++;
                }
                loop8: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelist_ofEx; /* Prevent compiler warnings */
    rulelist_ofEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end list_of */

/** 
 * $ANTLR start list_element
 * hammer_sema_v2.gt:75:1: list_element returns [const hammer::ast::expression* result] : ( target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ );
 */
static const hammer::ast::expression*
list_element(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id22;
    const hammer::ast::expression* target_ref20;
    #undef	RETURN_TYPE_target_ref20
    #define	RETURN_TYPE_target_ref20 const hammer::ast::expression*

    const hammer::ast::path* path21;
    #undef	RETURN_TYPE_path21
    #define	RETURN_TYPE_path21 const hammer::ast::path*

    const hammer::ast::expression* public_expression23;
    #undef	RETURN_TYPE_public_expression23
    #define	RETURN_TYPE_public_expression23 const hammer::ast::expression*

    const hammer::ast::expression* expression_a24;
    #undef	RETURN_TYPE_expression_a24
    #define	RETURN_TYPE_expression_a24 const hammer::ast::expression*

    const hammer::ast::expression* rule_invocation25;
    #undef	RETURN_TYPE_rule_invocation25
    #define	RETURN_TYPE_rule_invocation25 const hammer::ast::expression*

    const hammer::ast::expression* struct_26;
    #undef	RETURN_TYPE_struct_26
    #define	RETURN_TYPE_struct_26 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id22       = NULL;
    target_ref20 = NULL;
    path21 = NULL;
    public_expression23 = NULL;
    expression_a24 = NULL;
    rule_invocation25 = NULL;
    struct_26 = NULL;

    {
        {
            //  hammer_sema_v2.gt:76:2: ( target_ref | path | Id | public_expression | expression_a | rule_invocation | struct_ )
            
            ANTLR3_UINT32 alt9;

            alt9=7;

            alt9 = cdfa9.predict(ctx, RECOGNIZER, ISTREAM, &cdfa9);
            if  (HASEXCEPTION())
            {
                goto rulelist_elementEx;
            }

            switch (alt9) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:76:4: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_list_element413);
        	        target_ref20=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = target_ref20; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:77:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_list_element420);
        	        path21=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = path21; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:78:4: Id
        	    {
        	        Id22 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_list_element427); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id22->getToken(Id22)); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // hammer_sema_v2.gt:79:11: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_list_element441);
        	        public_expression23=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = public_expression23; 
        	        }

        	    }
        	    break;
        	case 5:
        	    // hammer_sema_v2.gt:80:11: expression_a
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_a_in_list_element455);
        	        expression_a24=expression_a(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = expression_a24; 
        	        }

        	    }
        	    break;
        	case 6:
        	    // hammer_sema_v2.gt:81:4: rule_invocation
        	    {
        	        FOLLOWPUSH(FOLLOW_rule_invocation_in_list_element462);
        	        rule_invocation25=rule_invocation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = rule_invocation25; 
        	        }

        	    }
        	    break;
        	case 7:
        	    // hammer_sema_v2.gt:82:4: struct_
        	    {
        	        FOLLOWPUSH(FOLLOW_struct__in_list_element469);
        	        struct_26=struct_(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = struct_26; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulelist_elementEx; /* Prevent compiler warnings */
    rulelist_elementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end list_element */

/** 
 * $ANTLR start public_expression
 * hammer_sema_v2.gt:84:1: public_expression returns [const hammer::ast::expression* result] : ^( PublicTag expression_a ) ;
 */
static const hammer::ast::expression*
public_expression(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    PublicTag27;
    const hammer::ast::expression* expression_a28;
    #undef	RETURN_TYPE_expression_a28
    #define	RETURN_TYPE_expression_a28 const hammer::ast::expression*

    /* Initialize rule variables
     */


    PublicTag27       = NULL;
    expression_a28 = NULL;

    {
        // hammer_sema_v2.gt:85:2: ( ^( PublicTag expression_a ) )
        // hammer_sema_v2.gt:85:4: ^( PublicTag expression_a )
        {
            PublicTag27 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_public_expression485); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_a_in_public_expression487);
            expression_a28=expression_a(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }

            {
                 result = SEMA->on_public_expr(PublicTag27->getToken(PublicTag27), expression_a28); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepublic_expressionEx; /* Prevent compiler warnings */
    rulepublic_expressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end public_expression */

/** 
 * $ANTLR start expression_a
 * hammer_sema_v2.gt:87:1: expression_a returns [const hammer::ast::expression* result] : ( feature | condition );
 */
static const hammer::ast::expression*
expression_a(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::feature* feature29;
    #undef	RETURN_TYPE_feature29
    #define	RETURN_TYPE_feature29 const hammer::ast::feature*

    const hammer::ast::expression* condition30;
    #undef	RETURN_TYPE_condition30
    #define	RETURN_TYPE_condition30 const hammer::ast::expression*

    /* Initialize rule variables
     */


    feature29 = NULL;
    condition30 = NULL;

    {
        {
            //  hammer_sema_v2.gt:88:2: ( feature | condition )
            
            ANTLR3_UINT32 alt10;

            alt10=2;


            {
                int LA10_0 = LA(1);
                if ( (LA10_0 == Feature) ) 
                {
                    alt10=1;
                }
                else if ( (LA10_0 == Condition) ) 
                {
                    alt10=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 10;
                    EXCEPTION->state        = 0;


                    goto ruleexpression_aEx;
                }
            }
            switch (alt10) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:88:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_expression_a503);
        	        feature29=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpression_aEx;
        	        }

        	        {
        	             result = feature29; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:89:4: condition
        	    {
        	        FOLLOWPUSH(FOLLOW_condition_in_expression_a510);
        	        condition30=condition(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpression_aEx;
        	        }

        	        {
        	             result = condition30; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpression_aEx; /* Prevent compiler warnings */
    ruleexpression_aEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end expression_a */

/** 
 * $ANTLR start path
 * hammer_sema_v2.gt:91:1: path returns [const hammer::ast::path* result] : ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? ) ;
 */
static const hammer::ast::path*
path(phammer_sema_v2 ctx)
{   
    const hammer::ast::path* result = NULL;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
            hammer::parscore::token root_name, trailing_slash; 
    {
        // hammer_sema_v2.gt:94:2: ( ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? ) )
        // hammer_sema_v2.gt:94:4: ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? )
        {
             MATCHT(Path, &FOLLOW_Path_in_path532); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            // hammer_sema_v2.gt:94:11: ( path_root_name[root_name] )?
            {
                int alt11=2;
                {
                    int LA11_0 = LA(1);
                    if ( (LA11_0 == PathRootName) ) 
                    {
                        alt11=1;
                    }
                }
                switch (alt11) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:94:11: path_root_name[root_name]
            	    {
            	        FOLLOWPUSH(FOLLOW_path_root_name_in_path534);
            	        path_root_name(ctx, root_name);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepathEx;
            	        }


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_path_elements_in_path538);
            path_elements(ctx, elements);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            // hammer_sema_v2.gt:94:62: ( path_trailing_slash[trailing_slash] )?
            {
                int alt12=2;
                {
                    int LA12_0 = LA(1);
                    if ( (LA12_0 == PathTrailingSlash) ) 
                    {
                        alt12=1;
                    }
                }
                switch (alt12) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:94:62: path_trailing_slash[trailing_slash]
            	    {
            	        FOLLOWPUSH(FOLLOW_path_trailing_slash_in_path541);
            	        path_trailing_slash(ctx, trailing_slash);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepathEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }

            {
                 result = SEMA->on_path(root_name, elements, trailing_slash); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepathEx; /* Prevent compiler warnings */
    rulepathEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end path */

/** 
 * $ANTLR start path_root_name
 * hammer_sema_v2.gt:96:1: path_root_name[hammer::parscore::token& root_name] : PathRootName ;
 */
static void
path_root_name(phammer_sema_v2 ctx, hammer::parscore::token& root_name)
{   
    pANTLR3_BASE_TREE    PathRootName31;

    /* Initialize rule variables
     */


    PathRootName31       = NULL;

    {
        // hammer_sema_v2.gt:97:2: ( PathRootName )
        // hammer_sema_v2.gt:97:4: PathRootName
        {
            PathRootName31 = (pANTLR3_BASE_TREE) MATCHT(PathRootName, &FOLLOW_PathRootName_in_path_root_name558); 
            if  (HASEXCEPTION())
            {
                goto rulepath_root_nameEx;
            }

            {
                 root_name = hammer::parscore::token(PathRootName31->getToken(PathRootName31)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_root_nameEx; /* Prevent compiler warnings */
    rulepath_root_nameEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_root_name */

/** 
 * $ANTLR start path_elements
 * hammer_sema_v2.gt:99:1: path_elements[hammer::ast::expressions_t& elements] : ( path_element )+ ;
 */
static void
path_elements(phammer_sema_v2 ctx, hammer::ast::expressions_t& elements)
{   
    const hammer::ast::expression* path_element32;
    #undef	RETURN_TYPE_path_element32
    #define	RETURN_TYPE_path_element32 const hammer::ast::expression*

    /* Initialize rule variables
     */


    path_element32 = NULL;

    {
        // hammer_sema_v2.gt:100:2: ( ( path_element )+ )
        // hammer_sema_v2.gt:100:4: ( path_element )+
        {
            // hammer_sema_v2.gt:100:4: ( path_element )+
            {
                int cnt13=0;

                for (;;)
                {
                    int alt13=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA13_0 = LA(1);
            	    if ( (LA13_0 == Wildcard || LA13_0 == Id) ) 
            	    {
            	        alt13=1;
            	    }

            	}
            	switch (alt13) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:100:5: path_element
            	        {
            	            FOLLOWPUSH(FOLLOW_path_element_in_path_elements572);
            	            path_element32=path_element(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepath_elementsEx;
            	            }

            	            {
            	                 elements.push_back(path_element32); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt13 >= 1 )
            		{
            		    goto loop13;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepath_elementsEx;
            	}
            	cnt13++;
                }
                loop13: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_elementsEx; /* Prevent compiler warnings */
    rulepath_elementsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_elements */

/** 
 * $ANTLR start path_element
 * hammer_sema_v2.gt:102:1: path_element returns [const hammer::ast::expression* result] : ( Id | wildcard );
 */
static const hammer::ast::expression*
path_element(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id33;
    const hammer::ast::expression* wildcard34;
    #undef	RETURN_TYPE_wildcard34
    #define	RETURN_TYPE_wildcard34 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id33       = NULL;
    wildcard34 = NULL;

    {
        {
            //  hammer_sema_v2.gt:103:2: ( Id | wildcard )
            
            ANTLR3_UINT32 alt14;

            alt14=2;


            {
                int LA14_0 = LA(1);
                if ( (LA14_0 == Id) ) 
                {
                    alt14=1;
                }
                else if ( (LA14_0 == Wildcard) ) 
                {
                    alt14=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulepath_elementEx;
                }
            }
            switch (alt14) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:103:4: Id
        	    {
        	        Id33 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_path_element589); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepath_elementEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id33->getToken(Id33)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:104:4: wildcard
        	    {
        	        FOLLOWPUSH(FOLLOW_wildcard_in_path_element596);
        	        wildcard34=wildcard(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepath_elementEx;
        	        }

        	        {
        	             result = wildcard34; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_elementEx; /* Prevent compiler warnings */
    rulepath_elementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end path_element */

/** 
 * $ANTLR start path_trailing_slash
 * hammer_sema_v2.gt:106:1: path_trailing_slash[hammer::parscore::token& trailing_slash] : PathTrailingSlash ;
 */
static void
path_trailing_slash(phammer_sema_v2 ctx, hammer::parscore::token& trailing_slash)
{   
    pANTLR3_BASE_TREE    PathTrailingSlash35;

    /* Initialize rule variables
     */


    PathTrailingSlash35       = NULL;

    {
        // hammer_sema_v2.gt:107:2: ( PathTrailingSlash )
        // hammer_sema_v2.gt:107:4: PathTrailingSlash
        {
            PathTrailingSlash35 = (pANTLR3_BASE_TREE) MATCHT(PathTrailingSlash, &FOLLOW_PathTrailingSlash_in_path_trailing_slash609); 
            if  (HASEXCEPTION())
            {
                goto rulepath_trailing_slashEx;
            }

            {
                 trailing_slash = hammer::parscore::token(PathTrailingSlash35->getToken(PathTrailingSlash35)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_trailing_slashEx; /* Prevent compiler warnings */
    rulepath_trailing_slashEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_trailing_slash */

/** 
 * $ANTLR start wildcard
 * hammer_sema_v2.gt:109:1: wildcard returns [const hammer::ast::expression* result] : ^( Wildcard ( wildcard_elem )+ ) ;
 */
static const hammer::ast::expression*
wildcard(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* wildcard_elem36;
    #undef	RETURN_TYPE_wildcard_elem36
    #define	RETURN_TYPE_wildcard_elem36 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
    wildcard_elem36 = NULL;

    {
        // hammer_sema_v2.gt:111:2: ( ^( Wildcard ( wildcard_elem )+ ) )
        // hammer_sema_v2.gt:111:4: ^( Wildcard ( wildcard_elem )+ )
        {
             MATCHT(Wildcard, &FOLLOW_Wildcard_in_wildcard630); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }

            // hammer_sema_v2.gt:111:15: ( wildcard_elem )+
            {
                int cnt15=0;

                for (;;)
                {
                    int alt15=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA15_0 = LA(1);
            	    if ( (LA15_0 == Id || ((LA15_0 >= QuestionMark) && (LA15_0 <= DoubleAsterix))) ) 
            	    {
            	        alt15=1;
            	    }

            	}
            	switch (alt15) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:111:16: wildcard_elem
            	        {
            	            FOLLOWPUSH(FOLLOW_wildcard_elem_in_wildcard633);
            	            wildcard_elem36=wildcard_elem(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewildcardEx;
            	            }

            	            {
            	                 elements.push_back(wildcard_elem36); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt15 >= 1 )
            		{
            		    goto loop15;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulewildcardEx;
            	}
            	cnt15++;
                }
                loop15: ;	/* Jump to here if this rule does not match */
            }
            {
                 result = SEMA->on_list_of(elements); 
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewildcardEx; /* Prevent compiler warnings */
    rulewildcardEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end wildcard */

/** 
 * $ANTLR start wildcard_elem
 * hammer_sema_v2.gt:114:1: wildcard_elem returns [const hammer::ast::expression* result] : ( Id | QuestionMark | Asterix | DoubleAsterix );
 */
static const hammer::ast::expression*
wildcard_elem(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id37;
    pANTLR3_BASE_TREE    QuestionMark38;
    pANTLR3_BASE_TREE    Asterix39;
    pANTLR3_BASE_TREE    DoubleAsterix40;

    /* Initialize rule variables
     */


    Id37       = NULL;
    QuestionMark38       = NULL;
    Asterix39       = NULL;
    DoubleAsterix40       = NULL;

    {
        {
            //  hammer_sema_v2.gt:115:2: ( Id | QuestionMark | Asterix | DoubleAsterix )
            
            ANTLR3_UINT32 alt16;

            alt16=4;

            switch ( LA(1) ) 
            {
            case Id:
            	{
            		alt16=1;
            	}
                break;
            case QuestionMark:
            	{
            		alt16=2;
            	}
                break;
            case Asterix:
            	{
            		alt16=3;
            	}
                break;
            case DoubleAsterix:
            	{
            		alt16=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto rulewildcard_elemEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:115:4: Id
        	    {
        	        Id37 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_wildcard_elem655); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id37->getToken(Id37)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:116:4: QuestionMark
        	    {
        	        QuestionMark38 = (pANTLR3_BASE_TREE) MATCHT(QuestionMark, &FOLLOW_QuestionMark_in_wildcard_elem662); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(QuestionMark38->getToken(QuestionMark38)); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:117:4: Asterix
        	    {
        	        Asterix39 = (pANTLR3_BASE_TREE) MATCHT(Asterix, &FOLLOW_Asterix_in_wildcard_elem669); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(Asterix39->getToken(Asterix39)); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // hammer_sema_v2.gt:118:4: DoubleAsterix
        	    {
        	        DoubleAsterix40 = (pANTLR3_BASE_TREE) MATCHT(DoubleAsterix, &FOLLOW_DoubleAsterix_in_wildcard_elem676); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(DoubleAsterix40->getToken(DoubleAsterix40)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulewildcard_elemEx; /* Prevent compiler warnings */
    rulewildcard_elemEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end wildcard_elem */

/** 
 * $ANTLR start public_tag
 * hammer_sema_v2.gt:121:1: public_tag[hammer::parscore::source_location* tag_loc] : PublicTag ;
 */
static void
public_tag(phammer_sema_v2 ctx, hammer::parscore::source_location* tag_loc)
{   
    pANTLR3_BASE_TREE    PublicTag41;

    /* Initialize rule variables
     */


    PublicTag41       = NULL;

    {
        // hammer_sema_v2.gt:122:2: ( PublicTag )
        // hammer_sema_v2.gt:122:4: PublicTag
        {
            PublicTag41 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_public_tag691); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_tagEx;
            }

            {
                 *tag_loc = hammer::parscore::source_location(PublicTag41->getToken(PublicTag41)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepublic_tagEx; /* Prevent compiler warnings */
    rulepublic_tagEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end public_tag */

/** 
 * $ANTLR start rule_invocation
 * hammer_sema_v2.gt:125:1: rule_invocation returns [const hammer::ast::expression* result] : ^( RuleInvocation name= Id arguments[&args] ) ;
 */
static const hammer::ast::expression*
rule_invocation(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
    name       = NULL;

    {
        // hammer_sema_v2.gt:127:2: ( ^( RuleInvocation name= Id arguments[&args] ) )
        // hammer_sema_v2.gt:127:4: ^( RuleInvocation name= Id arguments[&args] )
        {
             MATCHT(RuleInvocation, &FOLLOW_RuleInvocation_in_rule_invocation714); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_rule_invocation718); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            FOLLOWPUSH(FOLLOW_arguments_in_rule_invocation720);
            arguments(ctx, &args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            {
                 result = SEMA->on_rule_invocation(name->getToken(name), args); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerule_invocationEx; /* Prevent compiler warnings */
    rulerule_invocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end rule_invocation */

/** 
 * $ANTLR start struct_
 * hammer_sema_v2.gt:129:1: struct_ returns [const hammer::ast::expression* result] : ^( Structure ( struct_field )* ) ;
 */
static const hammer::ast::expression*
struct_(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Structure43;
    const hammer::ast::expression* struct_field42;
    #undef	RETURN_TYPE_struct_field42
    #define	RETURN_TYPE_struct_field42 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, fields); 
            hammer::parscore::source_location start_brace;

    Structure43       = NULL;
    struct_field42 = NULL;

    {
        // hammer_sema_v2.gt:133:2: ( ^( Structure ( struct_field )* ) )
        // hammer_sema_v2.gt:133:4: ^( Structure ( struct_field )* )
        {
            Structure43 = (pANTLR3_BASE_TREE) MATCHT(Structure, &FOLLOW_Structure_in_struct_743); 
            if  (HASEXCEPTION())
            {
                goto rulestruct_Ex;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulestruct_Ex;
                }


                // hammer_sema_v2.gt:133:16: ( struct_field )*

                for (;;)
                {
                    int alt17=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA17_0 = LA(1);
                        if ( (((LA17_0 >= Structure) && (LA17_0 <= Path)) || LA17_0 == TargetRef || ((LA17_0 >= Id) && (LA17_0 <= PublicTag))) ) 
                        {
                            alt17=1;
                        }

                    }
                    switch (alt17) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:133:17: struct_field
                	    {
                	        FOLLOWPUSH(FOLLOW_struct_field_in_struct_746);
                	        struct_field42=struct_field(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulestruct_Ex;
                	        }

                	        {
                	             fields.push_back(struct_field42); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop17;	/* break out of the loop */
                	    break;
                    }
                }
                loop17: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulestruct_Ex;
                }

            }
            {
                 result = SEMA->on_struct(Structure43->getToken(Structure43), fields); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestruct_Ex; /* Prevent compiler warnings */
    rulestruct_Ex: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end struct_ */

/** 
 * $ANTLR start struct_field
 * hammer_sema_v2.gt:135:1: struct_field returns [const hammer::ast::expression* result] : ( EmptyField | named_field | expression );
 */
static const hammer::ast::expression*
struct_field(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    EmptyField44;
    const hammer::ast::expression* named_field45;
    #undef	RETURN_TYPE_named_field45
    #define	RETURN_TYPE_named_field45 const hammer::ast::expression*

    const hammer::ast::expression* expression46;
    #undef	RETURN_TYPE_expression46
    #define	RETURN_TYPE_expression46 const hammer::ast::expression*

    /* Initialize rule variables
     */


    EmptyField44       = NULL;
    named_field45 = NULL;
    expression46 = NULL;

    {
        {
            //  hammer_sema_v2.gt:136:2: ( EmptyField | named_field | expression )
            
            ANTLR3_UINT32 alt18;

            alt18=3;

            switch ( LA(1) ) 
            {
            case EmptyField:
            	{
            		alt18=1;
            	}
                break;
            case NamedField:
            	{
            		alt18=2;
            	}
                break;
            case Structure:
            case List:
            case Feature:
            case Condition:
            case RuleInvocation:
            case Path:
            case TargetRef:
            case Id:
            case PublicTag:
            	{
            		alt18=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto rulestruct_fieldEx;
            }

            switch (alt18) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:136:4: EmptyField
        	    {
        	        EmptyField44 = (pANTLR3_BASE_TREE) MATCHT(EmptyField, &FOLLOW_EmptyField_in_struct_field767); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestruct_fieldEx;
        	        }

        	        {
        	             result = SEMA->on_empty_expr(EmptyField44->getToken(EmptyField44)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:137:4: named_field
        	    {
        	        FOLLOWPUSH(FOLLOW_named_field_in_struct_field774);
        	        named_field45=named_field(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestruct_fieldEx;
        	        }

        	        {
        	             result = named_field45; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:138:4: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_struct_field781);
        	        expression46=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestruct_fieldEx;
        	        }

        	        {
        	             result = expression46; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestruct_fieldEx; /* Prevent compiler warnings */
    rulestruct_fieldEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end struct_field */

/** 
 * $ANTLR start named_field
 * hammer_sema_v2.gt:140:1: named_field returns [const hammer::ast::expression* result] : ( ^( NamedField Id expression ) | ^( NamedField Id EmptyField ) );
 */
static const hammer::ast::expression*
named_field(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id47;
    pANTLR3_BASE_TREE    Id49;
    pANTLR3_BASE_TREE    EmptyField50;
    const hammer::ast::expression* expression48;
    #undef	RETURN_TYPE_expression48
    #define	RETURN_TYPE_expression48 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id47       = NULL;
    Id49       = NULL;
    EmptyField50       = NULL;
    expression48 = NULL;

    {
        {
            //  hammer_sema_v2.gt:141:2: ( ^( NamedField Id expression ) | ^( NamedField Id EmptyField ) )
            
            ANTLR3_UINT32 alt19;

            alt19=2;


            {
                int LA19_0 = LA(1);
                if ( (LA19_0 == NamedField) ) 
                {

                    {
                        int LA19_1 = LA(2);
                        if ( (LA19_1 == DOWN) ) 
                        {

                            {
                                int LA19_2 = LA(3);
                                if ( (LA19_2 == Id) ) 
                                {

                                    {
                                        int LA19_3 = LA(4);
                                        if ( (LA19_3 == EmptyField) ) 
                                        {
                                            alt19=2;
                                        }
                                        else if ( (LA19_3 == Structure || ((LA19_3 >= List) && (LA19_3 <= Path)) || LA19_3 == TargetRef || ((LA19_3 >= Id) && (LA19_3 <= PublicTag))) ) 
                                        {
                                            alt19=1;
                                        }
                                        else 
                                        {
                                        
                                            CONSTRUCTEX();
                                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            EXCEPTION->message      = (void *)"";
                                            EXCEPTION->decisionNum  = 19;
                                            EXCEPTION->state        = 3;


                                            goto rulenamed_fieldEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 19;
                                    EXCEPTION->state        = 2;


                                    goto rulenamed_fieldEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 19;
                            EXCEPTION->state        = 1;


                            goto rulenamed_fieldEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 19;
                    EXCEPTION->state        = 0;


                    goto rulenamed_fieldEx;
                }
            }
            switch (alt19) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:141:4: ^( NamedField Id expression )
        	    {
        	         MATCHT(NamedField, &FOLLOW_NamedField_in_named_field797); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        Id47 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_field799); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_named_field801);
        	        expression48=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id47->getToken(Id47), expression48); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:142:4: ^( NamedField Id EmptyField )
        	    {
        	         MATCHT(NamedField, &FOLLOW_NamedField_in_named_field811); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        Id49 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_field813); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        EmptyField50 = (pANTLR3_BASE_TREE) MATCHT(EmptyField, &FOLLOW_EmptyField_in_named_field815); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id49->getToken(Id49), SEMA->on_empty_expr(EmptyField50->getToken(EmptyField50))); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_fieldEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenamed_fieldEx; /* Prevent compiler warnings */
    rulenamed_fieldEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end named_field */

/** 
 * $ANTLR start feature
 * hammer_sema_v2.gt:144:1: feature returns [const hammer::ast::feature* result] : ^( Feature Id feature_value ) ;
 */
static const hammer::ast::feature*
feature(phammer_sema_v2 ctx)
{   
    const hammer::ast::feature* result = NULL;

    pANTLR3_BASE_TREE    Id51;
    const hammer::ast::expression* feature_value52;
    #undef	RETURN_TYPE_feature_value52
    #define	RETURN_TYPE_feature_value52 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id51       = NULL;
    feature_value52 = NULL;

    {
        // hammer_sema_v2.gt:145:2: ( ^( Feature Id feature_value ) )
        // hammer_sema_v2.gt:145:4: ^( Feature Id feature_value )
        {
             MATCHT(Feature, &FOLLOW_Feature_in_feature833); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            Id51 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_feature835); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            FOLLOWPUSH(FOLLOW_feature_value_in_feature837);
            feature_value52=feature_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            {
                 result = SEMA->on_feature(Id51->getToken(Id51), feature_value52); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefeatureEx; /* Prevent compiler warnings */
    rulefeatureEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end feature */

/** 
 * $ANTLR start feature_value
 * hammer_sema_v2.gt:148:1: feature_value returns [const hammer::ast::expression* result] : ( Id | path | target_ref );
 */
static const hammer::ast::expression*
feature_value(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id53;
    const hammer::ast::path* path54;
    #undef	RETURN_TYPE_path54
    #define	RETURN_TYPE_path54 const hammer::ast::path*

    const hammer::ast::expression* target_ref55;
    #undef	RETURN_TYPE_target_ref55
    #define	RETURN_TYPE_target_ref55 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id53       = NULL;
    path54 = NULL;
    target_ref55 = NULL;

    {
        {
            //  hammer_sema_v2.gt:149:2: ( Id | path | target_ref )
            
            ANTLR3_UINT32 alt20;

            alt20=3;

            switch ( LA(1) ) 
            {
            case Id:
            	{
            		alt20=1;
            	}
                break;
            case Path:
            	{
            		alt20=2;
            	}
                break;
            case TargetRef:
            case PublicTag:
            	{
            		alt20=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto rulefeature_valueEx;
            }

            switch (alt20) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:149:4: Id
        	    {
        	        Id53 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_feature_value855); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id53->getToken(Id53)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:150:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_feature_value862);
        	        path54=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = path54; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:151:4: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_feature_value869);
        	        target_ref55=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = target_ref55; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulefeature_valueEx; /* Prevent compiler warnings */
    rulefeature_valueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end feature_value */

/** 
 * $ANTLR start target_ref
 * hammer_sema_v2.gt:153:1: target_ref returns [const hammer::ast::expression* result] : ( ^( PublicTag target_ref_impl[&target_name, &build_request] ) | target_ref_impl[&target_name, &build_request] );
 */
static const hammer::ast::expression*
target_ref(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    PublicTag56;
    const hammer::ast::path* target_ref_impl57;
    #undef	RETURN_TYPE_target_ref_impl57
    #define	RETURN_TYPE_target_ref_impl57 const hammer::ast::path*

    const hammer::ast::path* target_ref_impl58;
    #undef	RETURN_TYPE_target_ref_impl58
    #define	RETURN_TYPE_target_ref_impl58 const hammer::ast::path*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::features_t, build_request); 
            hammer::parscore::identifier target_name; 
    PublicTag56       = NULL;
    target_ref_impl57 = NULL;
    target_ref_impl58 = NULL;

    {
        {
            //  hammer_sema_v2.gt:156:2: ( ^( PublicTag target_ref_impl[&target_name, &build_request] ) | target_ref_impl[&target_name, &build_request] )
            
            ANTLR3_UINT32 alt21;

            alt21=2;


            {
                int LA21_0 = LA(1);
                if ( (LA21_0 == PublicTag) ) 
                {
                    alt21=1;
                }
                else if ( (LA21_0 == TargetRef) ) 
                {
                    alt21=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 21;
                    EXCEPTION->state        = 0;


                    goto ruletarget_refEx;
                }
            }
            switch (alt21) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:156:4: ^( PublicTag target_ref_impl[&target_name, &build_request] )
        	    {
        	        PublicTag56 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_target_ref890); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_target_ref_impl_in_target_ref892);
        	        target_ref_impl57=target_ref_impl(ctx, &target_name, &build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        {
        	             result = SEMA->on_target_ref(PublicTag56->getToken(PublicTag56), target_ref_impl57, target_name, build_request); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:157:4: target_ref_impl[&target_name, &build_request]
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_impl_in_target_ref901);
        	        target_ref_impl58=target_ref_impl(ctx, &target_name, &build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        {
        	             result = SEMA->on_target_ref(hammer::parscore::source_location(), target_ref_impl58, target_name, build_request); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_refEx; /* Prevent compiler warnings */
    ruletarget_refEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end target_ref */

/** 
 * $ANTLR start target_ref_impl
 * hammer_sema_v2.gt:160:1: target_ref_impl[hammer::parscore::identifier* target_name, \n\t hammer::ast::features_t* build_request] returns [const hammer::ast::path* result] : ( ^( TargetRef path ( target_ref_spec[target_name, build_request] )? ) | ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? ) );
 */
static const hammer::ast::path*
target_ref_impl(phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request)
{   
    const hammer::ast::path* result = NULL;

    pANTLR3_BASE_TREE    Id60;
    const hammer::ast::path* path59;
    #undef	RETURN_TYPE_path59
    #define	RETURN_TYPE_path59 const hammer::ast::path*

    /* Initialize rule variables
     */


    Id60       = NULL;
    path59 = NULL;

    {
        {
            //  hammer_sema_v2.gt:163:2: ( ^( TargetRef path ( target_ref_spec[target_name, build_request] )? ) | ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? ) )
            
            ANTLR3_UINT32 alt24;

            alt24=2;


            {
                int LA24_0 = LA(1);
                if ( (LA24_0 == TargetRef) ) 
                {

                    {
                        int LA24_1 = LA(2);
                        if ( (LA24_1 == DOWN) ) 
                        {

                            {
                                int LA24_2 = LA(3);
                                if ( (LA24_2 == Id) ) 
                                {
                                    alt24=2;
                                }
                                else if ( (LA24_2 == Path) ) 
                                {
                                    alt24=1;
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 24;
                                    EXCEPTION->state        = 2;


                                    goto ruletarget_ref_implEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 24;
                            EXCEPTION->state        = 1;


                            goto ruletarget_ref_implEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 24;
                    EXCEPTION->state        = 0;


                    goto ruletarget_ref_implEx;
                }
            }
            switch (alt24) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:163:4: ^( TargetRef path ( target_ref_spec[target_name, build_request] )? )
        	    {
        	         MATCHT(TargetRef, &FOLLOW_TargetRef_in_target_ref_impl920); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_path_in_target_ref_impl922);
        	        path59=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        // hammer_sema_v2.gt:163:21: ( target_ref_spec[target_name, build_request] )?
        	        {
        	            int alt22=2;
        	            {
        	                int LA22_0 = LA(1);
        	                if ( (LA22_0 == TargetRefSpec) ) 
        	                {
        	                    alt22=1;
        	                }
        	            }
        	            switch (alt22) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:163:21: target_ref_spec[target_name, build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_spec_in_target_ref_impl924);
        	        	        target_ref_spec(ctx, target_name, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_implEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        {
        	             result = path59; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:164:4: ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? )
        	    {
        	         MATCHT(TargetRef, &FOLLOW_TargetRef_in_target_ref_impl935); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        Id60 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_target_ref_impl937); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        // hammer_sema_v2.gt:164:19: ( target_ref_spec[target_name, build_request] )?
        	        {
        	            int alt23=2;
        	            {
        	                int LA23_0 = LA(1);
        	                if ( (LA23_0 == TargetRefSpec) ) 
        	                {
        	                    alt23=1;
        	                }
        	            }
        	            switch (alt23) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:164:19: target_ref_spec[target_name, build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_spec_in_target_ref_impl939);
        	        	        target_ref_spec(ctx, target_name, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_implEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        {
        	             DECLARE_TYPE(hammer::ast::expressions_t, elements); elements.push_back(SEMA->on_id(Id60->getToken(Id60))); result = SEMA->on_path({}, elements, {}); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_implEx; /* Prevent compiler warnings */
    ruletarget_ref_implEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end target_ref_impl */

/** 
 * $ANTLR start target_ref_spec
 * hammer_sema_v2.gt:167:1: target_ref_spec[hammer::parscore::identifier* target_name, \n\t hammer::ast::features_t* build_request] : ( ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? ) | ^( TargetRefSpec target_ref_build_request[build_request] ) );
 */
static void
target_ref_spec(phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request)
{   
    pANTLR3_BASE_TREE    Id61;

    /* Initialize rule variables
     */


    Id61       = NULL;

    {
        {
            //  hammer_sema_v2.gt:169:2: ( ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? ) | ^( TargetRefSpec target_ref_build_request[build_request] ) )
            
            ANTLR3_UINT32 alt26;

            alt26=2;


            {
                int LA26_0 = LA(1);
                if ( (LA26_0 == TargetRefSpec) ) 
                {

                    {
                        int LA26_1 = LA(2);
                        if ( (LA26_1 == DOWN) ) 
                        {

                            {
                                int LA26_2 = LA(3);
                                if ( (LA26_2 == Id) ) 
                                {
                                    alt26=1;
                                }
                                else if ( (LA26_2 == TargetRefBuildRequest) ) 
                                {
                                    alt26=2;
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 26;
                                    EXCEPTION->state        = 2;


                                    goto ruletarget_ref_specEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 26;
                            EXCEPTION->state        = 1;


                            goto ruletarget_ref_specEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 26;
                    EXCEPTION->state        = 0;


                    goto ruletarget_ref_specEx;
                }
            }
            switch (alt26) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:169:4: ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? )
        	    {
        	         MATCHT(TargetRefSpec, &FOLLOW_TargetRefSpec_in_target_ref_spec958); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        Id61 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_target_ref_spec960); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        // hammer_sema_v2.gt:169:23: ( target_ref_build_request[build_request] )?
        	        {
        	            int alt25=2;
        	            {
        	                int LA25_0 = LA(1);
        	                if ( (LA25_0 == TargetRefBuildRequest) ) 
        	                {
        	                    alt25=1;
        	                }
        	            }
        	            switch (alt25) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:169:23: target_ref_build_request[build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_build_request_in_target_ref_spec962);
        	        	        target_ref_build_request(ctx, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_specEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        {
        	             *target_name = hammer::parscore::identifier(Id61->getToken(Id61)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:170:4: ^( TargetRefSpec target_ref_build_request[build_request] )
        	    {
        	         MATCHT(TargetRefSpec, &FOLLOW_TargetRefSpec_in_target_ref_spec973); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_target_ref_build_request_in_target_ref_spec975);
        	        target_ref_build_request(ctx, build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_specEx; /* Prevent compiler warnings */
    ruletarget_ref_specEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_ref_spec */

/** 
 * $ANTLR start target_ref_build_request
 * hammer_sema_v2.gt:172:1: target_ref_build_request[hammer::ast::features_t* build_request] : ^( TargetRefBuildRequest ( feature )+ ) ;
 */
static void
target_ref_build_request(phammer_sema_v2 ctx, hammer::ast::features_t* build_request)
{   
    const hammer::ast::feature* feature62;
    #undef	RETURN_TYPE_feature62
    #define	RETURN_TYPE_feature62 const hammer::ast::feature*

    /* Initialize rule variables
     */


    feature62 = NULL;

    {
        // hammer_sema_v2.gt:173:2: ( ^( TargetRefBuildRequest ( feature )+ ) )
        // hammer_sema_v2.gt:173:4: ^( TargetRefBuildRequest ( feature )+ )
        {
             MATCHT(TargetRefBuildRequest, &FOLLOW_TargetRefBuildRequest_in_target_ref_build_request990); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }

            // hammer_sema_v2.gt:173:28: ( feature )+
            {
                int cnt27=0;

                for (;;)
                {
                    int alt27=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA27_0 = LA(1);
            	    if ( (LA27_0 == Feature) ) 
            	    {
            	        alt27=1;
            	    }

            	}
            	switch (alt27) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:173:29: feature
            	        {
            	            FOLLOWPUSH(FOLLOW_feature_in_target_ref_build_request993);
            	            feature62=feature(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletarget_ref_build_requestEx;
            	            }

            	            {
            	                 build_request->push_back(feature62); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt27 >= 1 )
            		{
            		    goto loop27;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletarget_ref_build_requestEx;
            	}
            	cnt27++;
                }
                loop27: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_build_requestEx; /* Prevent compiler warnings */
    ruletarget_ref_build_requestEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_ref_build_request */

/** 
 * $ANTLR start condition
 * hammer_sema_v2.gt:175:1: condition returns [const hammer::ast::expression* result] : ^( Condition condition_condition condition_result ) ;
 */
static const hammer::ast::expression*
condition(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* condition_condition63;
    #undef	RETURN_TYPE_condition_condition63
    #define	RETURN_TYPE_condition_condition63 const hammer::ast::expression*

    const hammer::ast::expression* condition_result64;
    #undef	RETURN_TYPE_condition_result64
    #define	RETURN_TYPE_condition_result64 const hammer::ast::expression*

    /* Initialize rule variables
     */


    condition_condition63 = NULL;
    condition_result64 = NULL;

    {
        // hammer_sema_v2.gt:176:2: ( ^( Condition condition_condition condition_result ) )
        // hammer_sema_v2.gt:176:4: ^( Condition condition_condition condition_result )
        {
             MATCHT(Condition, &FOLLOW_Condition_in_condition1013); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_condition1015);
            condition_condition63=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            FOLLOWPUSH(FOLLOW_condition_result_in_condition1017);
            condition_result64=condition_result(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            {
                 result = SEMA->on_condition(condition_condition63, condition_result64); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconditionEx; /* Prevent compiler warnings */
    ruleconditionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition */

/** 
 * $ANTLR start condition_condition
 * hammer_sema_v2.gt:178:1: condition_condition returns [const hammer::ast::expression* result] : ( feature | logical_or | logical_and );
 */
static const hammer::ast::expression*
condition_condition(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::feature* feature65;
    #undef	RETURN_TYPE_feature65
    #define	RETURN_TYPE_feature65 const hammer::ast::feature*

    const hammer::ast::expression* logical_or66;
    #undef	RETURN_TYPE_logical_or66
    #define	RETURN_TYPE_logical_or66 const hammer::ast::expression*

    const hammer::ast::expression* logical_and67;
    #undef	RETURN_TYPE_logical_and67
    #define	RETURN_TYPE_logical_and67 const hammer::ast::expression*

    /* Initialize rule variables
     */


    feature65 = NULL;
    logical_or66 = NULL;
    logical_and67 = NULL;

    {
        {
            //  hammer_sema_v2.gt:179:2: ( feature | logical_or | logical_and )
            
            ANTLR3_UINT32 alt28;

            alt28=3;

            switch ( LA(1) ) 
            {
            case Feature:
            	{
            		alt28=1;
            	}
                break;
            case LogicalOr:
            	{
            		alt28=2;
            	}
                break;
            case LogicalAnd:
            	{
            		alt28=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto rulecondition_conditionEx;
            }

            switch (alt28) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:179:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_condition_condition1034);
        	        feature65=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = feature65; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:180:4: logical_or
        	    {
        	        FOLLOWPUSH(FOLLOW_logical_or_in_condition_condition1041);
        	        logical_or66=logical_or(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = logical_or66; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:181:4: logical_and
        	    {
        	        FOLLOWPUSH(FOLLOW_logical_and_in_condition_condition1048);
        	        logical_and67=logical_and(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = logical_and67; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecondition_conditionEx; /* Prevent compiler warnings */
    rulecondition_conditionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition_condition */

/** 
 * $ANTLR start condition_result
 * hammer_sema_v2.gt:183:1: condition_result returns [const hammer::ast::expression* result] : ( public_expression | feature | list_of[&elements] );
 */
static const hammer::ast::expression*
condition_result(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* public_expression68;
    #undef	RETURN_TYPE_public_expression68
    #define	RETURN_TYPE_public_expression68 const hammer::ast::expression*

    const hammer::ast::feature* feature69;
    #undef	RETURN_TYPE_feature69
    #define	RETURN_TYPE_feature69 const hammer::ast::feature*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
    public_expression68 = NULL;
    feature69 = NULL;

    {
        {
            //  hammer_sema_v2.gt:185:2: ( public_expression | feature | list_of[&elements] )
            
            ANTLR3_UINT32 alt29;

            alt29=3;

            switch ( LA(1) ) 
            {
            case PublicTag:
            	{
            		alt29=1;
            	}
                break;
            case Feature:
            	{
            		alt29=2;
            	}
                break;
            case List:
            	{
            		alt29=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto rulecondition_resultEx;
            }

            switch (alt29) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:185:4: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_condition_result1068);
        	        public_expression68=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = public_expression68; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:186:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_condition_result1076);
        	        feature69=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = feature69; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:187:4: list_of[&elements]
        	    {
        	        FOLLOWPUSH(FOLLOW_list_of_in_condition_result1083);
        	        list_of(ctx, &elements);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = SEMA->on_list_of(elements); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecondition_resultEx; /* Prevent compiler warnings */
    rulecondition_resultEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition_result */

/** 
 * $ANTLR start logical_or
 * hammer_sema_v2.gt:189:1: logical_or returns [const hammer::ast::expression* result] : ^( LogicalOr left= condition_condition right= condition_condition ) ;
 */
static const hammer::ast::expression*
logical_or(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* left;
    #undef	RETURN_TYPE_left
    #define	RETURN_TYPE_left const hammer::ast::expression*

    const hammer::ast::expression* right;
    #undef	RETURN_TYPE_right
    #define	RETURN_TYPE_right const hammer::ast::expression*

    /* Initialize rule variables
     */


    left = NULL;
    right = NULL;

    {
        // hammer_sema_v2.gt:190:2: ( ^( LogicalOr left= condition_condition right= condition_condition ) )
        // hammer_sema_v2.gt:190:4: ^( LogicalOr left= condition_condition right= condition_condition )
        {
             MATCHT(LogicalOr, &FOLLOW_LogicalOr_in_logical_or1101); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_or1105);
            left=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_or1109);
            right=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            {
                 result = SEMA->on_logical_or(left, right); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelogical_orEx; /* Prevent compiler warnings */
    rulelogical_orEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end logical_or */

/** 
 * $ANTLR start logical_and
 * hammer_sema_v2.gt:192:1: logical_and returns [const hammer::ast::expression* result] : ^( LogicalAnd left= condition_condition right= condition_condition ) ;
 */
static const hammer::ast::expression*
logical_and(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* left;
    #undef	RETURN_TYPE_left
    #define	RETURN_TYPE_left const hammer::ast::expression*

    const hammer::ast::expression* right;
    #undef	RETURN_TYPE_right
    #define	RETURN_TYPE_right const hammer::ast::expression*

    /* Initialize rule variables
     */


    left = NULL;
    right = NULL;

    {
        // hammer_sema_v2.gt:193:2: ( ^( LogicalAnd left= condition_condition right= condition_condition ) )
        // hammer_sema_v2.gt:193:4: ^( LogicalAnd left= condition_condition right= condition_condition )
        {
             MATCHT(LogicalAnd, &FOLLOW_LogicalAnd_in_logical_and1127); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_and1131);
            left=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_and1135);
            right=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            {
                 result = SEMA->on_logical_and(left, right); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelogical_andEx; /* Prevent compiler warnings */
    rulelogical_andEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end logical_and */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
