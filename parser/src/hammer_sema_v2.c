/** \file
 *  This C source file was generated by $ANTLR version 3.1.1
 *
 *     -  From the grammar source file : hammer_sema_v2.gt
 *     -                            On : 2018-05-01 17:53:26
 *     -           for the tree parser : hammer_sema_v2TreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/

/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */


#include <hammer/sema/actions.h>
#include <hammer/parscore/identifier.h>
#include <hammer/ast/requirement_set.h>
#include <hammer/ast/path.h>
#include <hammer/ast/feature.h>
#include <hammer/ast/condition.h>

#define SEMA static_cast<hammer::sema::actions*>(PARSER->super)
#define DECLARE_TYPE(Type, name) Type name ( Type ::allocator_type{SEMA->get_context()});

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "hammer_sema_v2.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   phammer_sema_v2_##scope##_SCOPE
#define SCOPE_STACK(scope)  phammer_sema_v2_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->phammer_sema_v2_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   hammer_sema_v2TokenNames[49+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "Hamfile",
        (pANTLR3_UINT8) "Rule",
        (pANTLR3_UINT8) "Local",
        (pANTLR3_UINT8) "Explicit",
        (pANTLR3_UINT8) "Arguments",
        (pANTLR3_UINT8) "EmptyArgument",
        (pANTLR3_UINT8) "NamedArgument",
        (pANTLR3_UINT8) "Structure",
        (pANTLR3_UINT8) "StructureField",
        (pANTLR3_UINT8) "List",
        (pANTLR3_UINT8) "Feature",
        (pANTLR3_UINT8) "Condition",
        (pANTLR3_UINT8) "RuleInvocation",
        (pANTLR3_UINT8) "Path",
        (pANTLR3_UINT8) "PathRootName",
        (pANTLR3_UINT8) "PathTrailingSlash",
        (pANTLR3_UINT8) "TargetRef",
        (pANTLR3_UINT8) "TargetRefSpec",
        (pANTLR3_UINT8) "TargetRefBuildRequest",
        (pANTLR3_UINT8) "Wildcard",
        (pANTLR3_UINT8) "LogicalAnd",
        (pANTLR3_UINT8) "LogicalOr",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "Id",
        (pANTLR3_UINT8) "PublicTag",
        (pANTLR3_UINT8) "Slash",
        (pANTLR3_UINT8) "PathUri",
        (pANTLR3_UINT8) "DoubleSlash",
        (pANTLR3_UINT8) "QuestionMark",
        (pANTLR3_UINT8) "Asterix",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "STRING_1",
        (pANTLR3_UINT8) "STRING_ID",
        (pANTLR3_UINT8) "STRING_ID1",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'->'",
        (pANTLR3_UINT8) "'||'",
        (pANTLR3_UINT8) "'&&'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static const hammer::ast::hamfile*	hamfile    (phammer_sema_v2 ctx);
static void	statement    (phammer_sema_v2 ctx, hammer::ast::statements_t* statements);
static const hammer::ast::statement*	top_level_rule_invocation    (phammer_sema_v2 ctx);
static void	target_def_prefix    (phammer_sema_v2 ctx, hammer::parscore::source_location* explicit_tag, hammer::parscore::source_location* local_tag);
static void	arguments    (phammer_sema_v2 ctx, hammer::ast::expressions_t* args);
static const hammer::ast::expression*	argument    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	named_argument    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	expression    (phammer_sema_v2 ctx);
static void	list_of    (phammer_sema_v2 ctx, hammer::ast::expressions_t* args);
static const hammer::ast::expression*	list_element    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	public_expression    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	expression_a    (phammer_sema_v2 ctx);
static const hammer::ast::path*	path    (phammer_sema_v2 ctx);
static void	path_root_name    (phammer_sema_v2 ctx, hammer::parscore::token& root_name);
static void	path_elements    (phammer_sema_v2 ctx, hammer::ast::expressions_t& elements);
static const hammer::ast::expression*	path_element    (phammer_sema_v2 ctx);
static void	path_trailing_slash    (phammer_sema_v2 ctx, hammer::parscore::token& trailing_slash);
static const hammer::ast::expression*	wildcard    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	wildcard_elem    (phammer_sema_v2 ctx);
static void	public_tag    (phammer_sema_v2 ctx, hammer::parscore::source_location* tag_loc);
static const hammer::ast::expression*	rule_invocation    (phammer_sema_v2 ctx);
static const hammer::ast::feature*	feature    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	feature_value    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	target_ref    (phammer_sema_v2 ctx);
static const hammer::ast::path*	target_ref_impl    (phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request);
static void	target_ref_spec    (phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request);
static void	target_ref_build_request    (phammer_sema_v2 ctx, hammer::ast::features_t* build_request);
static const hammer::ast::expression*	condition    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	condition_condition    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	condition_result    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	logical_or    (phammer_sema_v2 ctx);
static const hammer::ast::expression*	logical_and    (phammer_sema_v2 ctx);
static void	hammer_sema_v2Free(phammer_sema_v2 ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "hammer_sema_v2.gt";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new hammer_sema_v2 parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API phammer_sema_v2
hammer_sema_v2New   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return hammer_sema_v2NewSSD(instream, NULL);
}

/** \brief Create a new hammer_sema_v2 parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API phammer_sema_v2
hammer_sema_v2NewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    phammer_sema_v2 ctx;	    /* Context structure we will build and return   */
    
    ctx	= (phammer_sema_v2) ANTLR3_CALLOC(1, sizeof(hammer_sema_v2));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in hammer_sema_v2.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our hammer_sema_v2 interface
     */
    ctx->hamfile	= hamfile;
    ctx->statement	= statement;
    ctx->top_level_rule_invocation	= top_level_rule_invocation;
    ctx->target_def_prefix	= target_def_prefix;
    ctx->arguments	= arguments;
    ctx->argument	= argument;
    ctx->named_argument	= named_argument;
    ctx->expression	= expression;
    ctx->list_of	= list_of;
    ctx->list_element	= list_element;
    ctx->public_expression	= public_expression;
    ctx->expression_a	= expression_a;
    ctx->path	= path;
    ctx->path_root_name	= path_root_name;
    ctx->path_elements	= path_elements;
    ctx->path_element	= path_element;
    ctx->path_trailing_slash	= path_trailing_slash;
    ctx->wildcard	= wildcard;
    ctx->wildcard_elem	= wildcard_elem;
    ctx->public_tag	= public_tag;
    ctx->rule_invocation	= rule_invocation;
    ctx->feature	= feature;
    ctx->feature_value	= feature_value;
    ctx->target_ref	= target_ref;
    ctx->target_ref_impl	= target_ref_impl;
    ctx->target_ref_spec	= target_ref_spec;
    ctx->target_ref_build_request	= target_ref_build_request;
    ctx->condition	= condition;
    ctx->condition_condition	= condition_condition;
    ctx->condition_result	= condition_result;
    ctx->logical_or	= logical_or;
    ctx->logical_and	= logical_and;
    ctx->free			= hammer_sema_v2Free;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = hammer_sema_v2TokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 hammer_sema_v2Free(phammer_sema_v2 ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return hammer_sema_v2TokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_Hamfile_in_hamfile81  */
static	ANTLR3_BITWORD FOLLOW_Hamfile_in_hamfile81_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Hamfile_in_hamfile81	= { FOLLOW_Hamfile_in_hamfile81_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_hamfile83  */
static	ANTLR3_BITWORD FOLLOW_statement_in_hamfile83_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000028) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_hamfile83	= { FOLLOW_statement_in_hamfile83_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_top_level_rule_invocation_in_statement115  */
static	ANTLR3_BITWORD FOLLOW_top_level_rule_invocation_in_statement115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_top_level_rule_invocation_in_statement115	= { FOLLOW_top_level_rule_invocation_in_statement115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Rule_in_top_level_rule_invocation138  */
static	ANTLR3_BITWORD FOLLOW_Rule_in_top_level_rule_invocation138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Rule_in_top_level_rule_invocation138	= { FOLLOW_Rule_in_top_level_rule_invocation138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_def_prefix_in_top_level_rule_invocation140  */
static	ANTLR3_BITWORD FOLLOW_target_def_prefix_in_top_level_rule_invocation140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_target_def_prefix_in_top_level_rule_invocation140	= { FOLLOW_target_def_prefix_in_top_level_rule_invocation140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_top_level_rule_invocation146  */
static	ANTLR3_BITWORD FOLLOW_Id_in_top_level_rule_invocation146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_top_level_rule_invocation146	= { FOLLOW_Id_in_top_level_rule_invocation146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_top_level_rule_invocation148  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_top_level_rule_invocation148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_top_level_rule_invocation148	= { FOLLOW_arguments_in_top_level_rule_invocation148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Local_in_target_def_prefix166  */
static	ANTLR3_BITWORD FOLLOW_Local_in_target_def_prefix166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Local_in_target_def_prefix166	= { FOLLOW_Local_in_target_def_prefix166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Explicit_in_target_def_prefix173  */
static	ANTLR3_BITWORD FOLLOW_Explicit_in_target_def_prefix173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Explicit_in_target_def_prefix173	= { FOLLOW_Explicit_in_target_def_prefix173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Arguments_in_arguments189  */
static	ANTLR3_BITWORD FOLLOW_Arguments_in_arguments189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Arguments_in_arguments189	= { FOLLOW_Arguments_in_arguments189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_argument_in_arguments192  */
static	ANTLR3_BITWORD FOLLOW_argument_in_arguments192_bits[]	= { ANTLR3_UINT64_LIT(0x000000001813E608) };
static  ANTLR3_BITSET_LIST FOLLOW_argument_in_arguments192	= { FOLLOW_argument_in_arguments192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyArgument_in_argument219  */
static	ANTLR3_BITWORD FOLLOW_EmptyArgument_in_argument219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyArgument_in_argument219	= { FOLLOW_EmptyArgument_in_argument219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_argument226  */
static	ANTLR3_BITWORD FOLLOW_expression_in_argument226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_argument226	= { FOLLOW_expression_in_argument226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_named_argument_in_argument233  */
static	ANTLR3_BITWORD FOLLOW_named_argument_in_argument233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_named_argument_in_argument233	= { FOLLOW_named_argument_in_argument233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedArgument_in_named_argument250  */
static	ANTLR3_BITWORD FOLLOW_NamedArgument_in_named_argument250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedArgument_in_named_argument250	= { FOLLOW_NamedArgument_in_named_argument250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_argument252  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_argument252_bits[]	= { ANTLR3_UINT64_LIT(0x000000001813E000) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_argument252	= { FOLLOW_Id_in_named_argument252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_named_argument254  */
static	ANTLR3_BITWORD FOLLOW_expression_in_named_argument254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_named_argument254	= { FOLLOW_expression_in_named_argument254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NamedArgument_in_named_argument264  */
static	ANTLR3_BITWORD FOLLOW_NamedArgument_in_named_argument264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NamedArgument_in_named_argument264	= { FOLLOW_NamedArgument_in_named_argument264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_named_argument266  */
static	ANTLR3_BITWORD FOLLOW_Id_in_named_argument266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_named_argument266	= { FOLLOW_Id_in_named_argument266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EmptyArgument_in_named_argument268  */
static	ANTLR3_BITWORD FOLLOW_EmptyArgument_in_named_argument268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_EmptyArgument_in_named_argument268	= { FOLLOW_EmptyArgument_in_named_argument268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_of_in_expression293  */
static	ANTLR3_BITWORD FOLLOW_list_of_in_expression293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_list_of_in_expression293	= { FOLLOW_list_of_in_expression293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_expression308  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_expression308_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_expression308	= { FOLLOW_target_ref_in_expression308_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_expression315  */
static	ANTLR3_BITWORD FOLLOW_path_in_expression315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_expression315	= { FOLLOW_path_in_expression315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_expression322  */
static	ANTLR3_BITWORD FOLLOW_Id_in_expression322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_expression322	= { FOLLOW_Id_in_expression322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_expression336  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_expression336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_expression336	= { FOLLOW_public_expression_in_expression336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_expression350  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_expression350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_expression350	= { FOLLOW_expression_a_in_expression350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_invocation_in_expression357  */
static	ANTLR3_BITWORD FOLLOW_rule_invocation_in_expression357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_invocation_in_expression357	= { FOLLOW_rule_invocation_in_expression357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_List_in_list_of373  */
static	ANTLR3_BITWORD FOLLOW_List_in_list_of373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_List_in_list_of373	= { FOLLOW_List_in_list_of373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_element_in_list_of376  */
static	ANTLR3_BITWORD FOLLOW_list_element_in_list_of376_bits[]	= { ANTLR3_UINT64_LIT(0x000000001813E008) };
static  ANTLR3_BITSET_LIST FOLLOW_list_element_in_list_of376	= { FOLLOW_list_element_in_list_of376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_list_element406  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_list_element406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_list_element406	= { FOLLOW_target_ref_in_list_element406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_list_element413  */
static	ANTLR3_BITWORD FOLLOW_path_in_list_element413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_list_element413	= { FOLLOW_path_in_list_element413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_list_element420  */
static	ANTLR3_BITWORD FOLLOW_Id_in_list_element420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_list_element420	= { FOLLOW_Id_in_list_element420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_list_element434  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_list_element434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_list_element434	= { FOLLOW_public_expression_in_list_element434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_list_element448  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_list_element448_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_list_element448	= { FOLLOW_expression_a_in_list_element448_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rule_invocation_in_list_element455  */
static	ANTLR3_BITWORD FOLLOW_rule_invocation_in_list_element455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rule_invocation_in_list_element455	= { FOLLOW_rule_invocation_in_list_element455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_public_expression471  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_public_expression471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_public_expression471	= { FOLLOW_PublicTag_in_public_expression471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_a_in_public_expression473  */
static	ANTLR3_BITWORD FOLLOW_expression_a_in_public_expression473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_a_in_public_expression473	= { FOLLOW_expression_a_in_public_expression473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_expression_a489  */
static	ANTLR3_BITWORD FOLLOW_feature_in_expression_a489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_expression_a489	= { FOLLOW_feature_in_expression_a489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_in_expression_a496  */
static	ANTLR3_BITWORD FOLLOW_condition_in_expression_a496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_in_expression_a496	= { FOLLOW_condition_in_expression_a496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Path_in_path518  */
static	ANTLR3_BITWORD FOLLOW_Path_in_path518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Path_in_path518	= { FOLLOW_Path_in_path518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_root_name_in_path520  */
static	ANTLR3_BITWORD FOLLOW_path_root_name_in_path520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008800000) };
static  ANTLR3_BITSET_LIST FOLLOW_path_root_name_in_path520	= { FOLLOW_path_root_name_in_path520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_elements_in_path524  */
static	ANTLR3_BITWORD FOLLOW_path_elements_in_path524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_elements_in_path524	= { FOLLOW_path_elements_in_path524_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_trailing_slash_in_path527  */
static	ANTLR3_BITWORD FOLLOW_path_trailing_slash_in_path527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_trailing_slash_in_path527	= { FOLLOW_path_trailing_slash_in_path527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PathRootName_in_path_root_name544  */
static	ANTLR3_BITWORD FOLLOW_PathRootName_in_path_root_name544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PathRootName_in_path_root_name544	= { FOLLOW_PathRootName_in_path_root_name544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_element_in_path_elements558  */
static	ANTLR3_BITWORD FOLLOW_path_element_in_path_elements558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008800002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_element_in_path_elements558	= { FOLLOW_path_element_in_path_elements558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_path_element575  */
static	ANTLR3_BITWORD FOLLOW_Id_in_path_element575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_path_element575	= { FOLLOW_Id_in_path_element575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wildcard_in_path_element582  */
static	ANTLR3_BITWORD FOLLOW_wildcard_in_path_element582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_wildcard_in_path_element582	= { FOLLOW_wildcard_in_path_element582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PathTrailingSlash_in_path_trailing_slash595  */
static	ANTLR3_BITWORD FOLLOW_PathTrailingSlash_in_path_trailing_slash595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PathTrailingSlash_in_path_trailing_slash595	= { FOLLOW_PathTrailingSlash_in_path_trailing_slash595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Wildcard_in_wildcard616  */
static	ANTLR3_BITWORD FOLLOW_Wildcard_in_wildcard616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Wildcard_in_wildcard616	= { FOLLOW_Wildcard_in_wildcard616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_wildcard_elem_in_wildcard619  */
static	ANTLR3_BITWORD FOLLOW_wildcard_elem_in_wildcard619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000308000008) };
static  ANTLR3_BITSET_LIST FOLLOW_wildcard_elem_in_wildcard619	= { FOLLOW_wildcard_elem_in_wildcard619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_wildcard_elem641  */
static	ANTLR3_BITWORD FOLLOW_Id_in_wildcard_elem641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_wildcard_elem641	= { FOLLOW_Id_in_wildcard_elem641_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QuestionMark_in_wildcard_elem648  */
static	ANTLR3_BITWORD FOLLOW_QuestionMark_in_wildcard_elem648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QuestionMark_in_wildcard_elem648	= { FOLLOW_QuestionMark_in_wildcard_elem648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Asterix_in_wildcard_elem655  */
static	ANTLR3_BITWORD FOLLOW_Asterix_in_wildcard_elem655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Asterix_in_wildcard_elem655	= { FOLLOW_Asterix_in_wildcard_elem655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_public_tag670  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_public_tag670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_public_tag670	= { FOLLOW_PublicTag_in_public_tag670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RuleInvocation_in_rule_invocation693  */
static	ANTLR3_BITWORD FOLLOW_RuleInvocation_in_rule_invocation693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RuleInvocation_in_rule_invocation693	= { FOLLOW_RuleInvocation_in_rule_invocation693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_rule_invocation697  */
static	ANTLR3_BITWORD FOLLOW_Id_in_rule_invocation697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_rule_invocation697	= { FOLLOW_Id_in_rule_invocation697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_arguments_in_rule_invocation699  */
static	ANTLR3_BITWORD FOLLOW_arguments_in_rule_invocation699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_arguments_in_rule_invocation699	= { FOLLOW_arguments_in_rule_invocation699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Feature_in_feature718  */
static	ANTLR3_BITWORD FOLLOW_Feature_in_feature718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Feature_in_feature718	= { FOLLOW_Feature_in_feature718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_feature720  */
static	ANTLR3_BITWORD FOLLOW_Id_in_feature720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000018120000) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_feature720	= { FOLLOW_Id_in_feature720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_value_in_feature722  */
static	ANTLR3_BITWORD FOLLOW_feature_value_in_feature722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_value_in_feature722	= { FOLLOW_feature_value_in_feature722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_feature_value740  */
static	ANTLR3_BITWORD FOLLOW_Id_in_feature_value740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_feature_value740	= { FOLLOW_Id_in_feature_value740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_feature_value747  */
static	ANTLR3_BITWORD FOLLOW_path_in_feature_value747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_feature_value747	= { FOLLOW_path_in_feature_value747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_in_feature_value754  */
static	ANTLR3_BITWORD FOLLOW_target_ref_in_feature_value754_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_in_feature_value754	= { FOLLOW_target_ref_in_feature_value754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PublicTag_in_target_ref775  */
static	ANTLR3_BITWORD FOLLOW_PublicTag_in_target_ref775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PublicTag_in_target_ref775	= { FOLLOW_PublicTag_in_target_ref775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_impl_in_target_ref777  */
static	ANTLR3_BITWORD FOLLOW_target_ref_impl_in_target_ref777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_impl_in_target_ref777	= { FOLLOW_target_ref_impl_in_target_ref777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_impl_in_target_ref786  */
static	ANTLR3_BITWORD FOLLOW_target_ref_impl_in_target_ref786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_impl_in_target_ref786	= { FOLLOW_target_ref_impl_in_target_ref786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRef_in_target_ref_impl805  */
static	ANTLR3_BITWORD FOLLOW_TargetRef_in_target_ref_impl805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRef_in_target_ref_impl805	= { FOLLOW_TargetRef_in_target_ref_impl805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_in_target_ref_impl807  */
static	ANTLR3_BITWORD FOLLOW_path_in_target_ref_impl807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200008) };
static  ANTLR3_BITSET_LIST FOLLOW_path_in_target_ref_impl807	= { FOLLOW_path_in_target_ref_impl807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_spec_in_target_ref_impl809  */
static	ANTLR3_BITWORD FOLLOW_target_ref_spec_in_target_ref_impl809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_spec_in_target_ref_impl809	= { FOLLOW_target_ref_spec_in_target_ref_impl809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRef_in_target_ref_impl820  */
static	ANTLR3_BITWORD FOLLOW_TargetRef_in_target_ref_impl820_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRef_in_target_ref_impl820	= { FOLLOW_TargetRef_in_target_ref_impl820_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_target_ref_impl822  */
static	ANTLR3_BITWORD FOLLOW_Id_in_target_ref_impl822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200008) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_target_ref_impl822	= { FOLLOW_Id_in_target_ref_impl822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_spec_in_target_ref_impl824  */
static	ANTLR3_BITWORD FOLLOW_target_ref_spec_in_target_ref_impl824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_spec_in_target_ref_impl824	= { FOLLOW_target_ref_spec_in_target_ref_impl824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefSpec_in_target_ref_spec843  */
static	ANTLR3_BITWORD FOLLOW_TargetRefSpec_in_target_ref_spec843_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefSpec_in_target_ref_spec843	= { FOLLOW_TargetRefSpec_in_target_ref_spec843_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Id_in_target_ref_spec845  */
static	ANTLR3_BITWORD FOLLOW_Id_in_target_ref_spec845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400008) };
static  ANTLR3_BITSET_LIST FOLLOW_Id_in_target_ref_spec845	= { FOLLOW_Id_in_target_ref_spec845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_build_request_in_target_ref_spec847  */
static	ANTLR3_BITWORD FOLLOW_target_ref_build_request_in_target_ref_spec847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_build_request_in_target_ref_spec847	= { FOLLOW_target_ref_build_request_in_target_ref_spec847_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefSpec_in_target_ref_spec858  */
static	ANTLR3_BITWORD FOLLOW_TargetRefSpec_in_target_ref_spec858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefSpec_in_target_ref_spec858	= { FOLLOW_TargetRefSpec_in_target_ref_spec858_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_target_ref_build_request_in_target_ref_spec860  */
static	ANTLR3_BITWORD FOLLOW_target_ref_build_request_in_target_ref_spec860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_target_ref_build_request_in_target_ref_spec860	= { FOLLOW_target_ref_build_request_in_target_ref_spec860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TargetRefBuildRequest_in_target_ref_build_request875  */
static	ANTLR3_BITWORD FOLLOW_TargetRefBuildRequest_in_target_ref_build_request875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TargetRefBuildRequest_in_target_ref_build_request875	= { FOLLOW_TargetRefBuildRequest_in_target_ref_build_request875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_target_ref_build_request878  */
static	ANTLR3_BITWORD FOLLOW_feature_in_target_ref_build_request878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004008) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_target_ref_build_request878	= { FOLLOW_feature_in_target_ref_build_request878_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Condition_in_condition898  */
static	ANTLR3_BITWORD FOLLOW_Condition_in_condition898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_Condition_in_condition898	= { FOLLOW_Condition_in_condition898_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_condition900  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_condition900_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010006000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_condition900	= { FOLLOW_condition_condition_in_condition900_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_result_in_condition902  */
static	ANTLR3_BITWORD FOLLOW_condition_result_in_condition902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_result_in_condition902	= { FOLLOW_condition_result_in_condition902_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_condition_condition919  */
static	ANTLR3_BITWORD FOLLOW_feature_in_condition_condition919_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_condition_condition919	= { FOLLOW_feature_in_condition_condition919_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logical_or_in_condition_condition926  */
static	ANTLR3_BITWORD FOLLOW_logical_or_in_condition_condition926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logical_or_in_condition_condition926	= { FOLLOW_logical_or_in_condition_condition926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logical_and_in_condition_condition933  */
static	ANTLR3_BITWORD FOLLOW_logical_and_in_condition_condition933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logical_and_in_condition_condition933	= { FOLLOW_logical_and_in_condition_condition933_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_expression_in_condition_result953  */
static	ANTLR3_BITWORD FOLLOW_public_expression_in_condition_result953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_public_expression_in_condition_result953	= { FOLLOW_public_expression_in_condition_result953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_feature_in_condition_result961  */
static	ANTLR3_BITWORD FOLLOW_feature_in_condition_result961_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_feature_in_condition_result961	= { FOLLOW_feature_in_condition_result961_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_list_of_in_condition_result968  */
static	ANTLR3_BITWORD FOLLOW_list_of_in_condition_result968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_list_of_in_condition_result968	= { FOLLOW_list_of_in_condition_result968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LogicalOr_in_logical_or986  */
static	ANTLR3_BITWORD FOLLOW_LogicalOr_in_logical_or986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LogicalOr_in_logical_or986	= { FOLLOW_LogicalOr_in_logical_or986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_or990  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_or990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003004000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_or990	= { FOLLOW_condition_condition_in_logical_or990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_or994  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_or994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_or994	= { FOLLOW_condition_condition_in_logical_or994_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LogicalAnd_in_logical_and1012  */
static	ANTLR3_BITWORD FOLLOW_LogicalAnd_in_logical_and1012_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LogicalAnd_in_logical_and1012	= { FOLLOW_LogicalAnd_in_logical_and1012_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_and1016  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_and1016_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003004000) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_and1016	= { FOLLOW_condition_condition_in_logical_and1016_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_condition_condition_in_logical_and1020  */
static	ANTLR3_BITWORD FOLLOW_condition_condition_in_logical_and1020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_condition_condition_in_logical_and1020	= { FOLLOW_condition_condition_in_logical_and1020_bits, 1	};
     


/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation );
 */
static const ANTLR3_INT32 dfa7_eot[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_eof[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_min[10] =
    {
	13, -1, 2, -1, -1, -1, -1, -1, 14, -1
    };
static const ANTLR3_INT32 dfa7_max[10] =
    {
	28, -1, 2, -1, -1, -1, -1, -1, 20, -1
    };
static const ANTLR3_INT32 dfa7_accept[10] =
    {
	-1, 1, -1, 2, 3, 4, 6, 7, -1, 5
    };
static const ANTLR3_INT32 dfa7_special[10] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa7_T_empty	    NULL

static const ANTLR3_INT32 dfa7_T0[] =
    {
	8
    };static const ANTLR3_INT32 dfa7_T1[] =
    {
	1, 6, 6, 7, 4, -1, -1, 3, -1, -1, -1, -1, -1, -1, 5, 2
    };static const ANTLR3_INT32 dfa7_T2[] =
    {
	9, 9, -1, -1, -1, -1, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa7_transitions[] =
{
    dfa7_T1, dfa7_T_empty, dfa7_T0, dfa7_T_empty, dfa7_T_empty, dfa7_T_empty, 
    dfa7_T_empty, dfa7_T_empty, dfa7_T2, dfa7_T_empty	
};


/* Declare tracking structure for Cyclic DFA 7
 */
static
ANTLR3_CYCLIC_DFA cdfa7
    =	{
	    7,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa7_eot,	    /* EOT table			    */
	    dfa7_eof,	    /* EOF table			    */
	    dfa7_min,	    /* Minimum tokens for each state    */
	    dfa7_max,	    /* Maximum tokens for each state    */
	    dfa7_accept,	/* Accept table			    */
	    dfa7_special,	/* Special transition states	    */
	    dfa7_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 7
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */ 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start hamfile
 * hammer_sema_v2.gt:22:1: hamfile returns [const hammer::ast::hamfile* result] : ^( Hamfile ( statement[&statements] )* ) ;
 */
static const hammer::ast::hamfile*
hamfile(phammer_sema_v2 ctx)
{   
    const hammer::ast::hamfile* result = NULL;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::statements_t, statements); 
    {
        // hammer_sema_v2.gt:24:2: ( ^( Hamfile ( statement[&statements] )* ) )
        // hammer_sema_v2.gt:24:4: ^( Hamfile ( statement[&statements] )* )
        {
             MATCHT(Hamfile, &FOLLOW_Hamfile_in_hamfile81); 
            if  (HASEXCEPTION())
            {
                goto rulehamfileEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulehamfileEx;
                }


                // hammer_sema_v2.gt:24:14: ( statement[&statements] )*

                for (;;)
                {
                    int alt1=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA1_0 = LA(1);
                        if ( (LA1_0 == Rule) ) 
                        {
                            alt1=1;
                        }

                    }
                    switch (alt1) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:24:14: statement[&statements]
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_hamfile83);
                	        statement(ctx, &statements);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulehamfileEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop1;	/* break out of the loop */
                	    break;
                    }
                }
                loop1: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto rulehamfileEx;
                }

            }
            {
                 result = SEMA->on_hamfile(statements); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehamfileEx; /* Prevent compiler warnings */
    rulehamfileEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end hamfile */

/** 
 * $ANTLR start statement
 * hammer_sema_v2.gt:27:1: statement[hammer::ast::statements_t* statements] : top_level_rule_invocation ;
 */
static void
statement(phammer_sema_v2 ctx, hammer::ast::statements_t* statements)
{   
    const hammer::ast::statement* top_level_rule_invocation1;
    #undef	RETURN_TYPE_top_level_rule_invocation1
    #define	RETURN_TYPE_top_level_rule_invocation1 const hammer::ast::statement*

    /* Initialize rule variables
     */


    top_level_rule_invocation1 = NULL;

    {
        // hammer_sema_v2.gt:28:2: ( top_level_rule_invocation )
        // hammer_sema_v2.gt:28:4: top_level_rule_invocation
        {
            FOLLOWPUSH(FOLLOW_top_level_rule_invocation_in_statement115);
            top_level_rule_invocation1=top_level_rule_invocation(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatementEx;
            }

            {
                 statements->push_back(top_level_rule_invocation1); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start top_level_rule_invocation
 * hammer_sema_v2.gt:31:1: top_level_rule_invocation returns [const hammer::ast::statement* result] : ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] ) ;
 */
static const hammer::ast::statement*
top_level_rule_invocation(phammer_sema_v2 ctx)
{   
    const hammer::ast::statement* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
            hammer::parscore::source_location explicit_tag, local_tag;

    name       = NULL;

    {
        // hammer_sema_v2.gt:35:2: ( ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] ) )
        // hammer_sema_v2.gt:35:4: ^( Rule ( target_def_prefix[&explicit_tag, &local_tag] )? name= Id arguments[&args] )
        {
             MATCHT(Rule, &FOLLOW_Rule_in_top_level_rule_invocation138); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            // hammer_sema_v2.gt:35:11: ( target_def_prefix[&explicit_tag, &local_tag] )?
            {
                int alt2=2;
                {
                    int LA2_0 = LA(1);
                    if ( (((LA2_0 >= Local) && (LA2_0 <= Explicit))) ) 
                    {
                        alt2=1;
                    }
                }
                switch (alt2) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:35:11: target_def_prefix[&explicit_tag, &local_tag]
            	    {
            	        FOLLOWPUSH(FOLLOW_target_def_prefix_in_top_level_rule_invocation140);
            	        target_def_prefix(ctx, &explicit_tag, &local_tag);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletop_level_rule_invocationEx;
            	        }


            	    }
            	    break;

                }
            }
            name = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_top_level_rule_invocation146); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }

            FOLLOWPUSH(FOLLOW_arguments_in_top_level_rule_invocation148);
            arguments(ctx, &args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletop_level_rule_invocationEx;
            }

            {
                 result = SEMA->on_top_level_rule_invocation(explicit_tag, local_tag, name->getToken(name), args); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletop_level_rule_invocationEx; /* Prevent compiler warnings */
    ruletop_level_rule_invocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end top_level_rule_invocation */

/** 
 * $ANTLR start target_def_prefix
 * hammer_sema_v2.gt:38:1: target_def_prefix[hammer::parscore::source_location* explicit_tag,\n\t\t hammer::parscore::source_location* local_tag] : ( Local | Explicit );
 */
static void
target_def_prefix(phammer_sema_v2 ctx, hammer::parscore::source_location* explicit_tag, hammer::parscore::source_location* local_tag)
{   
    pANTLR3_BASE_TREE    Local2;
    pANTLR3_BASE_TREE    Explicit3;

    /* Initialize rule variables
     */


    Local2       = NULL;
    Explicit3       = NULL;

    {
        {
            //  hammer_sema_v2.gt:40:2: ( Local | Explicit )
            
            ANTLR3_UINT32 alt3;

            alt3=2;


            {
                int LA3_0 = LA(1);
                if ( (LA3_0 == Local) ) 
                {
                    alt3=1;
                }
                else if ( (LA3_0 == Explicit) ) 
                {
                    alt3=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 3;
                    EXCEPTION->state        = 0;


                    goto ruletarget_def_prefixEx;
                }
            }
            switch (alt3) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:40:4: Local
        	    {
        	        Local2 = (pANTLR3_BASE_TREE) MATCHT(Local, &FOLLOW_Local_in_target_def_prefix166); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_def_prefixEx;
        	        }

        	        {
        	             *local_tag = hammer::parscore::source_location(Local2->getToken(Local2)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:41:4: Explicit
        	    {
        	        Explicit3 = (pANTLR3_BASE_TREE) MATCHT(Explicit, &FOLLOW_Explicit_in_target_def_prefix173); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_def_prefixEx;
        	        }

        	        {
        	             *explicit_tag = hammer::parscore::source_location(Explicit3->getToken(Explicit3)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_def_prefixEx; /* Prevent compiler warnings */
    ruletarget_def_prefixEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_def_prefix */

/** 
 * $ANTLR start arguments
 * hammer_sema_v2.gt:44:1: arguments[hammer::ast::expressions_t* args] : ^( Arguments ( argument )* ) ;
 */
static void
arguments(phammer_sema_v2 ctx, hammer::ast::expressions_t* args)
{   
    const hammer::ast::expression* argument4;
    #undef	RETURN_TYPE_argument4
    #define	RETURN_TYPE_argument4 const hammer::ast::expression*

    /* Initialize rule variables
     */


    argument4 = NULL;

    {
        // hammer_sema_v2.gt:45:2: ( ^( Arguments ( argument )* ) )
        // hammer_sema_v2.gt:45:4: ^( Arguments ( argument )* )
        {
             MATCHT(Arguments, &FOLLOW_Arguments_in_arguments189); 
            if  (HASEXCEPTION())
            {
                goto ruleargumentsEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargumentsEx;
                }


                // hammer_sema_v2.gt:45:16: ( argument )*

                for (;;)
                {
                    int alt4=2;
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA4_0 = LA(1);
                        if ( (((LA4_0 >= EmptyArgument) && (LA4_0 <= NamedArgument)) || ((LA4_0 >= List) && (LA4_0 <= Path)) || LA4_0 == TargetRef || ((LA4_0 >= Id) && (LA4_0 <= PublicTag))) ) 
                        {
                            alt4=1;
                        }

                    }
                    switch (alt4) 
                    {
                	case 1:
                	    // hammer_sema_v2.gt:45:17: argument
                	    {
                	        FOLLOWPUSH(FOLLOW_argument_in_arguments192);
                	        argument4=argument(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleargumentsEx;
                	        }

                	        {
                	             args->push_back(argument4); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop4;	/* break out of the loop */
                	    break;
                    }
                }
                loop4: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL); 
                if  (HASEXCEPTION())
                {
                    goto ruleargumentsEx;
                }

            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentsEx; /* Prevent compiler warnings */
    ruleargumentsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end arguments */

/** 
 * $ANTLR start argument
 * hammer_sema_v2.gt:48:1: argument returns [const hammer::ast::expression* result] : ( EmptyArgument | expression | named_argument );
 */
static const hammer::ast::expression*
argument(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    EmptyArgument5;
    const hammer::ast::expression* expression6;
    #undef	RETURN_TYPE_expression6
    #define	RETURN_TYPE_expression6 const hammer::ast::expression*

    const hammer::ast::expression* named_argument7;
    #undef	RETURN_TYPE_named_argument7
    #define	RETURN_TYPE_named_argument7 const hammer::ast::expression*

    /* Initialize rule variables
     */


    EmptyArgument5       = NULL;
    expression6 = NULL;
    named_argument7 = NULL;

    {
        {
            //  hammer_sema_v2.gt:49:2: ( EmptyArgument | expression | named_argument )
            
            ANTLR3_UINT32 alt5;

            alt5=3;

            switch ( LA(1) ) 
            {
            case EmptyArgument:
            	{
            		alt5=1;
            	}
                break;
            case List:
            case Feature:
            case Condition:
            case RuleInvocation:
            case Path:
            case TargetRef:
            case Id:
            case PublicTag:
            	{
            		alt5=2;
            	}
                break;
            case NamedArgument:
            	{
            		alt5=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto ruleargumentEx;
            }

            switch (alt5) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:49:4: EmptyArgument
        	    {
        	        EmptyArgument5 = (pANTLR3_BASE_TREE) MATCHT(EmptyArgument, &FOLLOW_EmptyArgument_in_argument219); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = SEMA->on_empty_expr(EmptyArgument5->getToken(EmptyArgument5)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:50:4: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_argument226);
        	        expression6=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = expression6; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:51:4: named_argument
        	    {
        	        FOLLOWPUSH(FOLLOW_named_argument_in_argument233);
        	        named_argument7=named_argument(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleargumentEx;
        	        }

        	        {
        	             result = named_argument7; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end argument */

/** 
 * $ANTLR start named_argument
 * hammer_sema_v2.gt:54:1: named_argument returns [const hammer::ast::expression* result] : ( ^( NamedArgument Id expression ) | ^( NamedArgument Id EmptyArgument ) );
 */
static const hammer::ast::expression*
named_argument(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id8;
    pANTLR3_BASE_TREE    Id10;
    pANTLR3_BASE_TREE    EmptyArgument11;
    const hammer::ast::expression* expression9;
    #undef	RETURN_TYPE_expression9
    #define	RETURN_TYPE_expression9 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id8       = NULL;
    Id10       = NULL;
    EmptyArgument11       = NULL;
    expression9 = NULL;

    {
        {
            //  hammer_sema_v2.gt:55:2: ( ^( NamedArgument Id expression ) | ^( NamedArgument Id EmptyArgument ) )
            
            ANTLR3_UINT32 alt6;

            alt6=2;


            {
                int LA6_0 = LA(1);
                if ( (LA6_0 == NamedArgument) ) 
                {

                    {
                        int LA6_1 = LA(2);
                        if ( (LA6_1 == DOWN) ) 
                        {

                            {
                                int LA6_2 = LA(3);
                                if ( (LA6_2 == Id) ) 
                                {

                                    {
                                        int LA6_3 = LA(4);
                                        if ( (LA6_3 == EmptyArgument) ) 
                                        {
                                            alt6=2;
                                        }
                                        else if ( (((LA6_3 >= List) && (LA6_3 <= Path)) || LA6_3 == TargetRef || ((LA6_3 >= Id) && (LA6_3 <= PublicTag))) ) 
                                        {
                                            alt6=1;
                                        }
                                        else 
                                        {
                                        
                                            CONSTRUCTEX();
                                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                            EXCEPTION->message      = (void *)"";
                                            EXCEPTION->decisionNum  = 6;
                                            EXCEPTION->state        = 3;


                                            goto rulenamed_argumentEx;
                                        }
                                    }
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 6;
                                    EXCEPTION->state        = 2;


                                    goto rulenamed_argumentEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 6;
                            EXCEPTION->state        = 1;


                            goto rulenamed_argumentEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 6;
                    EXCEPTION->state        = 0;


                    goto rulenamed_argumentEx;
                }
            }
            switch (alt6) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:55:4: ^( NamedArgument Id expression )
        	    {
        	         MATCHT(NamedArgument, &FOLLOW_NamedArgument_in_named_argument250); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        Id8 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_argument252); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_named_argument254);
        	        expression9=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id8->getToken(Id8), expression9); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:56:4: ^( NamedArgument Id EmptyArgument )
        	    {
        	         MATCHT(NamedArgument, &FOLLOW_NamedArgument_in_named_argument264); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        Id10 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_named_argument266); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        EmptyArgument11 = (pANTLR3_BASE_TREE) MATCHT(EmptyArgument, &FOLLOW_EmptyArgument_in_named_argument268); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }

        	        {
        	             result = SEMA->on_named_expr(Id10->getToken(Id10), SEMA->on_empty_expr(EmptyArgument11->getToken(EmptyArgument11))); 
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenamed_argumentEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenamed_argumentEx; /* Prevent compiler warnings */
    rulenamed_argumentEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end named_argument */

/** 
 * $ANTLR start expression
 * hammer_sema_v2.gt:59:1: expression returns [const hammer::ast::expression* result] : ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation );
 */
static const hammer::ast::expression*
expression(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id14;
    const hammer::ast::expression* target_ref12;
    #undef	RETURN_TYPE_target_ref12
    #define	RETURN_TYPE_target_ref12 const hammer::ast::expression*

    const hammer::ast::path* path13;
    #undef	RETURN_TYPE_path13
    #define	RETURN_TYPE_path13 const hammer::ast::path*

    const hammer::ast::expression* public_expression15;
    #undef	RETURN_TYPE_public_expression15
    #define	RETURN_TYPE_public_expression15 const hammer::ast::expression*

    const hammer::ast::expression* expression_a16;
    #undef	RETURN_TYPE_expression_a16
    #define	RETURN_TYPE_expression_a16 const hammer::ast::expression*

    const hammer::ast::expression* rule_invocation17;
    #undef	RETURN_TYPE_rule_invocation17
    #define	RETURN_TYPE_rule_invocation17 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
    Id14       = NULL;
    target_ref12 = NULL;
    path13 = NULL;
    public_expression15 = NULL;
    expression_a16 = NULL;
    rule_invocation17 = NULL;

    {
        {
            //  hammer_sema_v2.gt:61:2: ( list_of[&args] | target_ref | path | Id | public_expression | expression_a | rule_invocation )
            
            ANTLR3_UINT32 alt7;

            alt7=7;

            alt7 = cdfa7.predict(ctx, RECOGNIZER, ISTREAM, &cdfa7);
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }

            switch (alt7) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:61:4: list_of[&args]
        	    {
        	        FOLLOWPUSH(FOLLOW_list_of_in_expression293);
        	        list_of(ctx, &args);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = SEMA->on_list_of(args); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:62:11: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_expression308);
        	        target_ref12=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = target_ref12; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:63:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_expression315);
        	        path13=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = path13; 
        	        }

        	    }
        	    break;
        	case 4:
        	    // hammer_sema_v2.gt:64:4: Id
        	    {
        	        Id14 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_expression322); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id14->getToken(Id14)); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // hammer_sema_v2.gt:65:11: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_expression336);
        	        public_expression15=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = public_expression15; 
        	        }

        	    }
        	    break;
        	case 6:
        	    // hammer_sema_v2.gt:66:11: expression_a
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_a_in_expression350);
        	        expression_a16=expression_a(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = expression_a16; 
        	        }

        	    }
        	    break;
        	case 7:
        	    // hammer_sema_v2.gt:67:4: rule_invocation
        	    {
        	        FOLLOWPUSH(FOLLOW_rule_invocation_in_expression357);
        	        rule_invocation17=rule_invocation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        {
        	             result = rule_invocation17; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end expression */

/** 
 * $ANTLR start list_of
 * hammer_sema_v2.gt:71:1: list_of[hammer::ast::expressions_t* args] : ^( List ( list_element )+ ) ;
 */
static void
list_of(phammer_sema_v2 ctx, hammer::ast::expressions_t* args)
{   
    const hammer::ast::expression* list_element18;
    #undef	RETURN_TYPE_list_element18
    #define	RETURN_TYPE_list_element18 const hammer::ast::expression*

    /* Initialize rule variables
     */


    list_element18 = NULL;

    {
        // hammer_sema_v2.gt:72:2: ( ^( List ( list_element )+ ) )
        // hammer_sema_v2.gt:72:4: ^( List ( list_element )+ )
        {
             MATCHT(List, &FOLLOW_List_in_list_of373); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }

            // hammer_sema_v2.gt:72:11: ( list_element )+
            {
                int cnt8=0;

                for (;;)
                {
                    int alt8=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA8_0 = LA(1);
            	    if ( (((LA8_0 >= Feature) && (LA8_0 <= Path)) || LA8_0 == TargetRef || ((LA8_0 >= Id) && (LA8_0 <= PublicTag))) ) 
            	    {
            	        alt8=1;
            	    }

            	}
            	switch (alt8) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:72:12: list_element
            	        {
            	            FOLLOWPUSH(FOLLOW_list_element_in_list_of376);
            	            list_element18=list_element(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulelist_ofEx;
            	            }

            	            {
            	                 args->push_back(list_element18); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt8 >= 1 )
            		{
            		    goto loop8;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulelist_ofEx;
            	}
            	cnt8++;
                }
                loop8: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelist_ofEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelist_ofEx; /* Prevent compiler warnings */
    rulelist_ofEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end list_of */

/** 
 * $ANTLR start list_element
 * hammer_sema_v2.gt:74:1: list_element returns [const hammer::ast::expression* result] : ( target_ref | path | Id | public_expression | expression_a | rule_invocation );
 */
static const hammer::ast::expression*
list_element(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id21;
    const hammer::ast::expression* target_ref19;
    #undef	RETURN_TYPE_target_ref19
    #define	RETURN_TYPE_target_ref19 const hammer::ast::expression*

    const hammer::ast::path* path20;
    #undef	RETURN_TYPE_path20
    #define	RETURN_TYPE_path20 const hammer::ast::path*

    const hammer::ast::expression* public_expression22;
    #undef	RETURN_TYPE_public_expression22
    #define	RETURN_TYPE_public_expression22 const hammer::ast::expression*

    const hammer::ast::expression* expression_a23;
    #undef	RETURN_TYPE_expression_a23
    #define	RETURN_TYPE_expression_a23 const hammer::ast::expression*

    const hammer::ast::expression* rule_invocation24;
    #undef	RETURN_TYPE_rule_invocation24
    #define	RETURN_TYPE_rule_invocation24 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id21       = NULL;
    target_ref19 = NULL;
    path20 = NULL;
    public_expression22 = NULL;
    expression_a23 = NULL;
    rule_invocation24 = NULL;

    {
        {
            //  hammer_sema_v2.gt:75:2: ( target_ref | path | Id | public_expression | expression_a | rule_invocation )
            
            ANTLR3_UINT32 alt9;

            alt9=6;

            switch ( LA(1) ) 
            {
            case PublicTag:
            	{

            		{
            		    int LA9_1 = LA(2);
            		    if ( (LA9_1 == DOWN) ) 
            		    {

            		        {
            		            int LA9_7 = LA(3);
            		            if ( (((LA9_7 >= Feature) && (LA9_7 <= Condition))) ) 
            		            {
            		                alt9=4;
            		            }
            		            else if ( (LA9_7 == TargetRef) ) 
            		            {
            		                alt9=1;
            		            }
            		            else 
            		            {
            		            
            		                CONSTRUCTEX();
            		                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		                EXCEPTION->message      = (void *)"";
            		                EXCEPTION->decisionNum  = 9;
            		                EXCEPTION->state        = 7;


            		                goto rulelist_elementEx;
            		            }
            		        }
            		    }
            		    else 
            		    {
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 9;
            		        EXCEPTION->state        = 1;


            		        goto rulelist_elementEx;
            		    }
            		}
            	}
                break;
            case TargetRef:
            	{
            		alt9=1;
            	}
                break;
            case Path:
            	{
            		alt9=2;
            	}
                break;
            case Id:
            	{
            		alt9=3;
            	}
                break;
            case Feature:
            case Condition:
            	{
            		alt9=5;
            	}
                break;
            case RuleInvocation:
            	{
            		alt9=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto rulelist_elementEx;
            }

            switch (alt9) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:75:4: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_list_element406);
        	        target_ref19=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = target_ref19; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:76:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_list_element413);
        	        path20=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = path20; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:77:4: Id
        	    {
        	        Id21 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_list_element420); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id21->getToken(Id21)); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // hammer_sema_v2.gt:78:11: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_list_element434);
        	        public_expression22=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = public_expression22; 
        	        }

        	    }
        	    break;
        	case 5:
        	    // hammer_sema_v2.gt:79:11: expression_a
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_a_in_list_element448);
        	        expression_a23=expression_a(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = expression_a23; 
        	        }

        	    }
        	    break;
        	case 6:
        	    // hammer_sema_v2.gt:80:4: rule_invocation
        	    {
        	        FOLLOWPUSH(FOLLOW_rule_invocation_in_list_element455);
        	        rule_invocation24=rule_invocation(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelist_elementEx;
        	        }

        	        {
        	             result = rule_invocation24; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulelist_elementEx; /* Prevent compiler warnings */
    rulelist_elementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end list_element */

/** 
 * $ANTLR start public_expression
 * hammer_sema_v2.gt:82:1: public_expression returns [const hammer::ast::expression* result] : ^( PublicTag expression_a ) ;
 */
static const hammer::ast::expression*
public_expression(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    PublicTag25;
    const hammer::ast::expression* expression_a26;
    #undef	RETURN_TYPE_expression_a26
    #define	RETURN_TYPE_expression_a26 const hammer::ast::expression*

    /* Initialize rule variables
     */


    PublicTag25       = NULL;
    expression_a26 = NULL;

    {
        // hammer_sema_v2.gt:83:2: ( ^( PublicTag expression_a ) )
        // hammer_sema_v2.gt:83:4: ^( PublicTag expression_a )
        {
            PublicTag25 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_public_expression471); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_a_in_public_expression473);
            expression_a26=expression_a(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_expressionEx;
            }

            {
                 result = SEMA->on_public_expr(PublicTag25->getToken(PublicTag25), expression_a26); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepublic_expressionEx; /* Prevent compiler warnings */
    rulepublic_expressionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end public_expression */

/** 
 * $ANTLR start expression_a
 * hammer_sema_v2.gt:85:1: expression_a returns [const hammer::ast::expression* result] : ( feature | condition );
 */
static const hammer::ast::expression*
expression_a(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::feature* feature27;
    #undef	RETURN_TYPE_feature27
    #define	RETURN_TYPE_feature27 const hammer::ast::feature*

    const hammer::ast::expression* condition28;
    #undef	RETURN_TYPE_condition28
    #define	RETURN_TYPE_condition28 const hammer::ast::expression*

    /* Initialize rule variables
     */


    feature27 = NULL;
    condition28 = NULL;

    {
        {
            //  hammer_sema_v2.gt:86:2: ( feature | condition )
            
            ANTLR3_UINT32 alt10;

            alt10=2;


            {
                int LA10_0 = LA(1);
                if ( (LA10_0 == Feature) ) 
                {
                    alt10=1;
                }
                else if ( (LA10_0 == Condition) ) 
                {
                    alt10=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 10;
                    EXCEPTION->state        = 0;


                    goto ruleexpression_aEx;
                }
            }
            switch (alt10) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:86:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_expression_a489);
        	        feature27=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpression_aEx;
        	        }

        	        {
        	             result = feature27; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:87:4: condition
        	    {
        	        FOLLOWPUSH(FOLLOW_condition_in_expression_a496);
        	        condition28=condition(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpression_aEx;
        	        }

        	        {
        	             result = condition28; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpression_aEx; /* Prevent compiler warnings */
    ruleexpression_aEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end expression_a */

/** 
 * $ANTLR start path
 * hammer_sema_v2.gt:89:1: path returns [const hammer::ast::path* result] : ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? ) ;
 */
static const hammer::ast::path*
path(phammer_sema_v2 ctx)
{   
    const hammer::ast::path* result = NULL;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
            hammer::parscore::token root_name, trailing_slash; 
    {
        // hammer_sema_v2.gt:92:2: ( ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? ) )
        // hammer_sema_v2.gt:92:4: ^( Path ( path_root_name[root_name] )? path_elements[elements] ( path_trailing_slash[trailing_slash] )? )
        {
             MATCHT(Path, &FOLLOW_Path_in_path518); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            // hammer_sema_v2.gt:92:11: ( path_root_name[root_name] )?
            {
                int alt11=2;
                {
                    int LA11_0 = LA(1);
                    if ( (LA11_0 == PathRootName) ) 
                    {
                        alt11=1;
                    }
                }
                switch (alt11) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:92:11: path_root_name[root_name]
            	    {
            	        FOLLOWPUSH(FOLLOW_path_root_name_in_path520);
            	        path_root_name(ctx, root_name);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepathEx;
            	        }


            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_path_elements_in_path524);
            path_elements(ctx, elements);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }


            // hammer_sema_v2.gt:92:62: ( path_trailing_slash[trailing_slash] )?
            {
                int alt12=2;
                {
                    int LA12_0 = LA(1);
                    if ( (LA12_0 == PathTrailingSlash) ) 
                    {
                        alt12=1;
                    }
                }
                switch (alt12) 
                {
            	case 1:
            	    // hammer_sema_v2.gt:92:62: path_trailing_slash[trailing_slash]
            	    {
            	        FOLLOWPUSH(FOLLOW_path_trailing_slash_in_path527);
            	        path_trailing_slash(ctx, trailing_slash);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepathEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulepathEx;
            }

            {
                 result = SEMA->on_path(root_name, elements, trailing_slash); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepathEx; /* Prevent compiler warnings */
    rulepathEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end path */

/** 
 * $ANTLR start path_root_name
 * hammer_sema_v2.gt:94:1: path_root_name[hammer::parscore::token& root_name] : PathRootName ;
 */
static void
path_root_name(phammer_sema_v2 ctx, hammer::parscore::token& root_name)
{   
    pANTLR3_BASE_TREE    PathRootName29;

    /* Initialize rule variables
     */


    PathRootName29       = NULL;

    {
        // hammer_sema_v2.gt:95:2: ( PathRootName )
        // hammer_sema_v2.gt:95:4: PathRootName
        {
            PathRootName29 = (pANTLR3_BASE_TREE) MATCHT(PathRootName, &FOLLOW_PathRootName_in_path_root_name544); 
            if  (HASEXCEPTION())
            {
                goto rulepath_root_nameEx;
            }

            {
                 root_name = hammer::parscore::token(PathRootName29->getToken(PathRootName29)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_root_nameEx; /* Prevent compiler warnings */
    rulepath_root_nameEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_root_name */

/** 
 * $ANTLR start path_elements
 * hammer_sema_v2.gt:97:1: path_elements[hammer::ast::expressions_t& elements] : ( path_element )+ ;
 */
static void
path_elements(phammer_sema_v2 ctx, hammer::ast::expressions_t& elements)
{   
    const hammer::ast::expression* path_element30;
    #undef	RETURN_TYPE_path_element30
    #define	RETURN_TYPE_path_element30 const hammer::ast::expression*

    /* Initialize rule variables
     */


    path_element30 = NULL;

    {
        // hammer_sema_v2.gt:98:2: ( ( path_element )+ )
        // hammer_sema_v2.gt:98:4: ( path_element )+
        {
            // hammer_sema_v2.gt:98:4: ( path_element )+
            {
                int cnt13=0;

                for (;;)
                {
                    int alt13=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA13_0 = LA(1);
            	    if ( (LA13_0 == Wildcard || LA13_0 == Id) ) 
            	    {
            	        alt13=1;
            	    }

            	}
            	switch (alt13) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:98:5: path_element
            	        {
            	            FOLLOWPUSH(FOLLOW_path_element_in_path_elements558);
            	            path_element30=path_element(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepath_elementsEx;
            	            }

            	            {
            	                 elements.push_back(path_element30); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt13 >= 1 )
            		{
            		    goto loop13;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepath_elementsEx;
            	}
            	cnt13++;
                }
                loop13: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_elementsEx; /* Prevent compiler warnings */
    rulepath_elementsEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_elements */

/** 
 * $ANTLR start path_element
 * hammer_sema_v2.gt:100:1: path_element returns [const hammer::ast::expression* result] : ( Id | wildcard );
 */
static const hammer::ast::expression*
path_element(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id31;
    const hammer::ast::expression* wildcard32;
    #undef	RETURN_TYPE_wildcard32
    #define	RETURN_TYPE_wildcard32 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id31       = NULL;
    wildcard32 = NULL;

    {
        {
            //  hammer_sema_v2.gt:101:2: ( Id | wildcard )
            
            ANTLR3_UINT32 alt14;

            alt14=2;


            {
                int LA14_0 = LA(1);
                if ( (LA14_0 == Id) ) 
                {
                    alt14=1;
                }
                else if ( (LA14_0 == Wildcard) ) 
                {
                    alt14=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulepath_elementEx;
                }
            }
            switch (alt14) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:101:4: Id
        	    {
        	        Id31 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_path_element575); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepath_elementEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id31->getToken(Id31)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:102:4: wildcard
        	    {
        	        FOLLOWPUSH(FOLLOW_wildcard_in_path_element582);
        	        wildcard32=wildcard(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepath_elementEx;
        	        }

        	        {
        	             result = wildcard32; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_elementEx; /* Prevent compiler warnings */
    rulepath_elementEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end path_element */

/** 
 * $ANTLR start path_trailing_slash
 * hammer_sema_v2.gt:104:1: path_trailing_slash[hammer::parscore::token& trailing_slash] : PathTrailingSlash ;
 */
static void
path_trailing_slash(phammer_sema_v2 ctx, hammer::parscore::token& trailing_slash)
{   
    pANTLR3_BASE_TREE    PathTrailingSlash33;

    /* Initialize rule variables
     */


    PathTrailingSlash33       = NULL;

    {
        // hammer_sema_v2.gt:105:2: ( PathTrailingSlash )
        // hammer_sema_v2.gt:105:4: PathTrailingSlash
        {
            PathTrailingSlash33 = (pANTLR3_BASE_TREE) MATCHT(PathTrailingSlash, &FOLLOW_PathTrailingSlash_in_path_trailing_slash595); 
            if  (HASEXCEPTION())
            {
                goto rulepath_trailing_slashEx;
            }

            {
                 trailing_slash = hammer::parscore::token(PathTrailingSlash33->getToken(PathTrailingSlash33)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_trailing_slashEx; /* Prevent compiler warnings */
    rulepath_trailing_slashEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end path_trailing_slash */

/** 
 * $ANTLR start wildcard
 * hammer_sema_v2.gt:107:1: wildcard returns [const hammer::ast::expression* result] : ^( Wildcard ( wildcard_elem )+ ) ;
 */
static const hammer::ast::expression*
wildcard(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* wildcard_elem34;
    #undef	RETURN_TYPE_wildcard_elem34
    #define	RETURN_TYPE_wildcard_elem34 const hammer::ast::expression*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
    wildcard_elem34 = NULL;

    {
        // hammer_sema_v2.gt:109:2: ( ^( Wildcard ( wildcard_elem )+ ) )
        // hammer_sema_v2.gt:109:4: ^( Wildcard ( wildcard_elem )+ )
        {
             MATCHT(Wildcard, &FOLLOW_Wildcard_in_wildcard616); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }

            // hammer_sema_v2.gt:109:15: ( wildcard_elem )+
            {
                int cnt15=0;

                for (;;)
                {
                    int alt15=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA15_0 = LA(1);
            	    if ( (LA15_0 == Id || ((LA15_0 >= QuestionMark) && (LA15_0 <= Asterix))) ) 
            	    {
            	        alt15=1;
            	    }

            	}
            	switch (alt15) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:109:16: wildcard_elem
            	        {
            	            FOLLOWPUSH(FOLLOW_wildcard_elem_in_wildcard619);
            	            wildcard_elem34=wildcard_elem(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewildcardEx;
            	            }

            	            {
            	                 elements.push_back(wildcard_elem34); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt15 >= 1 )
            		{
            		    goto loop15;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulewildcardEx;
            	}
            	cnt15++;
                }
                loop15: ;	/* Jump to here if this rule does not match */
            }
            {
                 result = SEMA->on_list_of(elements); 
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulewildcardEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewildcardEx; /* Prevent compiler warnings */
    rulewildcardEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end wildcard */

/** 
 * $ANTLR start wildcard_elem
 * hammer_sema_v2.gt:112:1: wildcard_elem returns [const hammer::ast::expression* result] : ( Id | QuestionMark | Asterix );
 */
static const hammer::ast::expression*
wildcard_elem(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id35;
    pANTLR3_BASE_TREE    QuestionMark36;
    pANTLR3_BASE_TREE    Asterix37;

    /* Initialize rule variables
     */


    Id35       = NULL;
    QuestionMark36       = NULL;
    Asterix37       = NULL;

    {
        {
            //  hammer_sema_v2.gt:113:2: ( Id | QuestionMark | Asterix )
            
            ANTLR3_UINT32 alt16;

            alt16=3;

            switch ( LA(1) ) 
            {
            case Id:
            	{
            		alt16=1;
            	}
                break;
            case QuestionMark:
            	{
            		alt16=2;
            	}
                break;
            case Asterix:
            	{
            		alt16=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto rulewildcard_elemEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:113:4: Id
        	    {
        	        Id35 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_wildcard_elem641); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id35->getToken(Id35)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:114:4: QuestionMark
        	    {
        	        QuestionMark36 = (pANTLR3_BASE_TREE) MATCHT(QuestionMark, &FOLLOW_QuestionMark_in_wildcard_elem648); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(QuestionMark36->getToken(QuestionMark36)); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:115:4: Asterix
        	    {
        	        Asterix37 = (pANTLR3_BASE_TREE) MATCHT(Asterix, &FOLLOW_Asterix_in_wildcard_elem655); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewildcard_elemEx;
        	        }

        	        {
        	             result = SEMA->on_id(Asterix37->getToken(Asterix37)); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulewildcard_elemEx; /* Prevent compiler warnings */
    rulewildcard_elemEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end wildcard_elem */

/** 
 * $ANTLR start public_tag
 * hammer_sema_v2.gt:118:1: public_tag[hammer::parscore::source_location* tag_loc] : PublicTag ;
 */
static void
public_tag(phammer_sema_v2 ctx, hammer::parscore::source_location* tag_loc)
{   
    pANTLR3_BASE_TREE    PublicTag38;

    /* Initialize rule variables
     */


    PublicTag38       = NULL;

    {
        // hammer_sema_v2.gt:119:2: ( PublicTag )
        // hammer_sema_v2.gt:119:4: PublicTag
        {
            PublicTag38 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_public_tag670); 
            if  (HASEXCEPTION())
            {
                goto rulepublic_tagEx;
            }

            {
                 *tag_loc = hammer::parscore::source_location(PublicTag38->getToken(PublicTag38)); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepublic_tagEx; /* Prevent compiler warnings */
    rulepublic_tagEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end public_tag */

/** 
 * $ANTLR start rule_invocation
 * hammer_sema_v2.gt:122:1: rule_invocation returns [const hammer::ast::expression* result] : ^( RuleInvocation name= Id arguments[&args] ) ;
 */
static const hammer::ast::expression*
rule_invocation(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    name;

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, args); 
    name       = NULL;

    {
        // hammer_sema_v2.gt:124:2: ( ^( RuleInvocation name= Id arguments[&args] ) )
        // hammer_sema_v2.gt:124:4: ^( RuleInvocation name= Id arguments[&args] )
        {
             MATCHT(RuleInvocation, &FOLLOW_RuleInvocation_in_rule_invocation693); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_rule_invocation697); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            FOLLOWPUSH(FOLLOW_arguments_in_rule_invocation699);
            arguments(ctx, &args);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerule_invocationEx;
            }

            {
                 result = SEMA->on_rule_invocation(name->getToken(name), args); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerule_invocationEx; /* Prevent compiler warnings */
    rulerule_invocationEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end rule_invocation */

/** 
 * $ANTLR start feature
 * hammer_sema_v2.gt:127:1: feature returns [const hammer::ast::feature* result] : ^( Feature Id feature_value ) ;
 */
static const hammer::ast::feature*
feature(phammer_sema_v2 ctx)
{   
    const hammer::ast::feature* result = NULL;

    pANTLR3_BASE_TREE    Id39;
    const hammer::ast::expression* feature_value40;
    #undef	RETURN_TYPE_feature_value40
    #define	RETURN_TYPE_feature_value40 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id39       = NULL;
    feature_value40 = NULL;

    {
        // hammer_sema_v2.gt:128:2: ( ^( Feature Id feature_value ) )
        // hammer_sema_v2.gt:128:4: ^( Feature Id feature_value )
        {
             MATCHT(Feature, &FOLLOW_Feature_in_feature718); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            Id39 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_feature720); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            FOLLOWPUSH(FOLLOW_feature_value_in_feature722);
            feature_value40=feature_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulefeatureEx;
            }

            {
                 result = SEMA->on_feature(Id39->getToken(Id39), feature_value40); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefeatureEx; /* Prevent compiler warnings */
    rulefeatureEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end feature */

/** 
 * $ANTLR start feature_value
 * hammer_sema_v2.gt:131:1: feature_value returns [const hammer::ast::expression* result] : ( Id | path | target_ref );
 */
static const hammer::ast::expression*
feature_value(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    Id41;
    const hammer::ast::path* path42;
    #undef	RETURN_TYPE_path42
    #define	RETURN_TYPE_path42 const hammer::ast::path*

    const hammer::ast::expression* target_ref43;
    #undef	RETURN_TYPE_target_ref43
    #define	RETURN_TYPE_target_ref43 const hammer::ast::expression*

    /* Initialize rule variables
     */


    Id41       = NULL;
    path42 = NULL;
    target_ref43 = NULL;

    {
        {
            //  hammer_sema_v2.gt:132:2: ( Id | path | target_ref )
            
            ANTLR3_UINT32 alt17;

            alt17=3;

            switch ( LA(1) ) 
            {
            case Id:
            	{
            		alt17=1;
            	}
                break;
            case Path:
            	{
            		alt17=2;
            	}
                break;
            case TargetRef:
            case PublicTag:
            	{
            		alt17=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto rulefeature_valueEx;
            }

            switch (alt17) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:132:4: Id
        	    {
        	        Id41 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_feature_value740); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = SEMA->on_id(Id41->getToken(Id41)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:133:4: path
        	    {
        	        FOLLOWPUSH(FOLLOW_path_in_feature_value747);
        	        path42=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = path42; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:134:4: target_ref
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_in_feature_value754);
        	        target_ref43=target_ref(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefeature_valueEx;
        	        }

        	        {
        	             result = target_ref43; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulefeature_valueEx; /* Prevent compiler warnings */
    rulefeature_valueEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end feature_value */

/** 
 * $ANTLR start target_ref
 * hammer_sema_v2.gt:136:1: target_ref returns [const hammer::ast::expression* result] : ( ^( PublicTag target_ref_impl[&target_name, &build_request] ) | target_ref_impl[&target_name, &build_request] );
 */
static const hammer::ast::expression*
target_ref(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    pANTLR3_BASE_TREE    PublicTag44;
    const hammer::ast::path* target_ref_impl45;
    #undef	RETURN_TYPE_target_ref_impl45
    #define	RETURN_TYPE_target_ref_impl45 const hammer::ast::path*

    const hammer::ast::path* target_ref_impl46;
    #undef	RETURN_TYPE_target_ref_impl46
    #define	RETURN_TYPE_target_ref_impl46 const hammer::ast::path*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::features_t, build_request); 
            hammer::parscore::identifier target_name; 
    PublicTag44       = NULL;
    target_ref_impl45 = NULL;
    target_ref_impl46 = NULL;

    {
        {
            //  hammer_sema_v2.gt:139:2: ( ^( PublicTag target_ref_impl[&target_name, &build_request] ) | target_ref_impl[&target_name, &build_request] )
            
            ANTLR3_UINT32 alt18;

            alt18=2;


            {
                int LA18_0 = LA(1);
                if ( (LA18_0 == PublicTag) ) 
                {
                    alt18=1;
                }
                else if ( (LA18_0 == TargetRef) ) 
                {
                    alt18=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 18;
                    EXCEPTION->state        = 0;


                    goto ruletarget_refEx;
                }
            }
            switch (alt18) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:139:4: ^( PublicTag target_ref_impl[&target_name, &build_request] )
        	    {
        	        PublicTag44 = (pANTLR3_BASE_TREE) MATCHT(PublicTag, &FOLLOW_PublicTag_in_target_ref775); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_target_ref_impl_in_target_ref777);
        	        target_ref_impl45=target_ref_impl(ctx, &target_name, &build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        {
        	             result = SEMA->on_target_ref(PublicTag44->getToken(PublicTag44), target_ref_impl45, target_name, build_request); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:140:4: target_ref_impl[&target_name, &build_request]
        	    {
        	        FOLLOWPUSH(FOLLOW_target_ref_impl_in_target_ref786);
        	        target_ref_impl46=target_ref_impl(ctx, &target_name, &build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_refEx;
        	        }

        	        {
        	             result = SEMA->on_target_ref(hammer::parscore::source_location(), target_ref_impl46, target_name, build_request); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_refEx; /* Prevent compiler warnings */
    ruletarget_refEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end target_ref */

/** 
 * $ANTLR start target_ref_impl
 * hammer_sema_v2.gt:143:1: target_ref_impl[hammer::parscore::identifier* target_name, \n\t hammer::ast::features_t* build_request] returns [const hammer::ast::path* result] : ( ^( TargetRef path ( target_ref_spec[target_name, build_request] )? ) | ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? ) );
 */
static const hammer::ast::path*
target_ref_impl(phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request)
{   
    const hammer::ast::path* result = NULL;

    pANTLR3_BASE_TREE    Id48;
    const hammer::ast::path* path47;
    #undef	RETURN_TYPE_path47
    #define	RETURN_TYPE_path47 const hammer::ast::path*

    /* Initialize rule variables
     */


    Id48       = NULL;
    path47 = NULL;

    {
        {
            //  hammer_sema_v2.gt:146:2: ( ^( TargetRef path ( target_ref_spec[target_name, build_request] )? ) | ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? ) )
            
            ANTLR3_UINT32 alt21;

            alt21=2;


            {
                int LA21_0 = LA(1);
                if ( (LA21_0 == TargetRef) ) 
                {

                    {
                        int LA21_1 = LA(2);
                        if ( (LA21_1 == DOWN) ) 
                        {

                            {
                                int LA21_2 = LA(3);
                                if ( (LA21_2 == Id) ) 
                                {
                                    alt21=2;
                                }
                                else if ( (LA21_2 == Path) ) 
                                {
                                    alt21=1;
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 21;
                                    EXCEPTION->state        = 2;


                                    goto ruletarget_ref_implEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 21;
                            EXCEPTION->state        = 1;


                            goto ruletarget_ref_implEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 21;
                    EXCEPTION->state        = 0;


                    goto ruletarget_ref_implEx;
                }
            }
            switch (alt21) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:146:4: ^( TargetRef path ( target_ref_spec[target_name, build_request] )? )
        	    {
        	         MATCHT(TargetRef, &FOLLOW_TargetRef_in_target_ref_impl805); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_path_in_target_ref_impl807);
        	        path47=path(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        // hammer_sema_v2.gt:146:21: ( target_ref_spec[target_name, build_request] )?
        	        {
        	            int alt19=2;
        	            {
        	                int LA19_0 = LA(1);
        	                if ( (LA19_0 == TargetRefSpec) ) 
        	                {
        	                    alt19=1;
        	                }
        	            }
        	            switch (alt19) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:146:21: target_ref_spec[target_name, build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_spec_in_target_ref_impl809);
        	        	        target_ref_spec(ctx, target_name, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_implEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        {
        	             result = path47; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:147:4: ^( TargetRef Id ( target_ref_spec[target_name, build_request] )? )
        	    {
        	         MATCHT(TargetRef, &FOLLOW_TargetRef_in_target_ref_impl820); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        Id48 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_target_ref_impl822); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }


        	        // hammer_sema_v2.gt:147:19: ( target_ref_spec[target_name, build_request] )?
        	        {
        	            int alt20=2;
        	            {
        	                int LA20_0 = LA(1);
        	                if ( (LA20_0 == TargetRefSpec) ) 
        	                {
        	                    alt20=1;
        	                }
        	            }
        	            switch (alt20) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:147:19: target_ref_spec[target_name, build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_spec_in_target_ref_impl824);
        	        	        target_ref_spec(ctx, target_name, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_implEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_implEx;
        	        }

        	        {
        	             DECLARE_TYPE(hammer::ast::expressions_t, elements); elements.push_back(SEMA->on_id(Id48->getToken(Id48))); result = SEMA->on_path({}, elements, {}); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_implEx; /* Prevent compiler warnings */
    ruletarget_ref_implEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end target_ref_impl */

/** 
 * $ANTLR start target_ref_spec
 * hammer_sema_v2.gt:150:1: target_ref_spec[hammer::parscore::identifier* target_name, \n\t hammer::ast::features_t* build_request] : ( ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? ) | ^( TargetRefSpec target_ref_build_request[build_request] ) );
 */
static void
target_ref_spec(phammer_sema_v2 ctx, hammer::parscore::identifier* target_name, hammer::ast::features_t* build_request)
{   
    pANTLR3_BASE_TREE    Id49;

    /* Initialize rule variables
     */


    Id49       = NULL;

    {
        {
            //  hammer_sema_v2.gt:152:2: ( ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? ) | ^( TargetRefSpec target_ref_build_request[build_request] ) )
            
            ANTLR3_UINT32 alt23;

            alt23=2;


            {
                int LA23_0 = LA(1);
                if ( (LA23_0 == TargetRefSpec) ) 
                {

                    {
                        int LA23_1 = LA(2);
                        if ( (LA23_1 == DOWN) ) 
                        {

                            {
                                int LA23_2 = LA(3);
                                if ( (LA23_2 == Id) ) 
                                {
                                    alt23=1;
                                }
                                else if ( (LA23_2 == TargetRefBuildRequest) ) 
                                {
                                    alt23=2;
                                }
                                else 
                                {
                                
                                    CONSTRUCTEX();
                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                    EXCEPTION->message      = (void *)"";
                                    EXCEPTION->decisionNum  = 23;
                                    EXCEPTION->state        = 2;


                                    goto ruletarget_ref_specEx;
                                }
                            }
                        }
                        else 
                        {
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 23;
                            EXCEPTION->state        = 1;


                            goto ruletarget_ref_specEx;
                        }
                    }
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 23;
                    EXCEPTION->state        = 0;


                    goto ruletarget_ref_specEx;
                }
            }
            switch (alt23) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:152:4: ^( TargetRefSpec Id ( target_ref_build_request[build_request] )? )
        	    {
        	         MATCHT(TargetRefSpec, &FOLLOW_TargetRefSpec_in_target_ref_spec843); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        Id49 = (pANTLR3_BASE_TREE) MATCHT(Id, &FOLLOW_Id_in_target_ref_spec845); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        // hammer_sema_v2.gt:152:23: ( target_ref_build_request[build_request] )?
        	        {
        	            int alt22=2;
        	            {
        	                int LA22_0 = LA(1);
        	                if ( (LA22_0 == TargetRefBuildRequest) ) 
        	                {
        	                    alt22=1;
        	                }
        	            }
        	            switch (alt22) 
        	            {
        	        	case 1:
        	        	    // hammer_sema_v2.gt:152:23: target_ref_build_request[build_request]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_target_ref_build_request_in_target_ref_spec847);
        	        	        target_ref_build_request(ctx, build_request);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletarget_ref_specEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        {
        	             *target_name = hammer::parscore::identifier(Id49->getToken(Id49)); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:153:4: ^( TargetRefSpec target_ref_build_request[build_request] )
        	    {
        	         MATCHT(TargetRefSpec, &FOLLOW_TargetRefSpec_in_target_ref_spec858); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_target_ref_build_request_in_target_ref_spec860);
        	        target_ref_build_request(ctx, build_request);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletarget_ref_specEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_specEx; /* Prevent compiler warnings */
    ruletarget_ref_specEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_ref_spec */

/** 
 * $ANTLR start target_ref_build_request
 * hammer_sema_v2.gt:155:1: target_ref_build_request[hammer::ast::features_t* build_request] : ^( TargetRefBuildRequest ( feature )+ ) ;
 */
static void
target_ref_build_request(phammer_sema_v2 ctx, hammer::ast::features_t* build_request)
{   
    const hammer::ast::feature* feature50;
    #undef	RETURN_TYPE_feature50
    #define	RETURN_TYPE_feature50 const hammer::ast::feature*

    /* Initialize rule variables
     */


    feature50 = NULL;

    {
        // hammer_sema_v2.gt:156:2: ( ^( TargetRefBuildRequest ( feature )+ ) )
        // hammer_sema_v2.gt:156:4: ^( TargetRefBuildRequest ( feature )+ )
        {
             MATCHT(TargetRefBuildRequest, &FOLLOW_TargetRefBuildRequest_in_target_ref_build_request875); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }

            // hammer_sema_v2.gt:156:28: ( feature )+
            {
                int cnt24=0;

                for (;;)
                {
                    int alt24=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA24_0 = LA(1);
            	    if ( (LA24_0 == Feature) ) 
            	    {
            	        alt24=1;
            	    }

            	}
            	switch (alt24) 
            	{
            	    case 1:
            	        // hammer_sema_v2.gt:156:29: feature
            	        {
            	            FOLLOWPUSH(FOLLOW_feature_in_target_ref_build_request878);
            	            feature50=feature(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletarget_ref_build_requestEx;
            	            }

            	            {
            	                 build_request->push_back(feature50); 
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt24 >= 1 )
            		{
            		    goto loop24;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletarget_ref_build_requestEx;
            	}
            	cnt24++;
                }
                loop24: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruletarget_ref_build_requestEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletarget_ref_build_requestEx; /* Prevent compiler warnings */
    ruletarget_ref_build_requestEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return ;
}
/* $ANTLR end target_ref_build_request */

/** 
 * $ANTLR start condition
 * hammer_sema_v2.gt:158:1: condition returns [const hammer::ast::expression* result] : ^( Condition condition_condition condition_result ) ;
 */
static const hammer::ast::expression*
condition(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* condition_condition51;
    #undef	RETURN_TYPE_condition_condition51
    #define	RETURN_TYPE_condition_condition51 const hammer::ast::expression*

    const hammer::ast::expression* condition_result52;
    #undef	RETURN_TYPE_condition_result52
    #define	RETURN_TYPE_condition_result52 const hammer::ast::expression*

    /* Initialize rule variables
     */


    condition_condition51 = NULL;
    condition_result52 = NULL;

    {
        // hammer_sema_v2.gt:159:2: ( ^( Condition condition_condition condition_result ) )
        // hammer_sema_v2.gt:159:4: ^( Condition condition_condition condition_result )
        {
             MATCHT(Condition, &FOLLOW_Condition_in_condition898); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_condition900);
            condition_condition51=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            FOLLOWPUSH(FOLLOW_condition_result_in_condition902);
            condition_result52=condition_result(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleconditionEx;
            }

            {
                 result = SEMA->on_condition(condition_condition51, condition_result52); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleconditionEx; /* Prevent compiler warnings */
    ruleconditionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition */

/** 
 * $ANTLR start condition_condition
 * hammer_sema_v2.gt:161:1: condition_condition returns [const hammer::ast::expression* result] : ( feature | logical_or | logical_and );
 */
static const hammer::ast::expression*
condition_condition(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::feature* feature53;
    #undef	RETURN_TYPE_feature53
    #define	RETURN_TYPE_feature53 const hammer::ast::feature*

    const hammer::ast::expression* logical_or54;
    #undef	RETURN_TYPE_logical_or54
    #define	RETURN_TYPE_logical_or54 const hammer::ast::expression*

    const hammer::ast::expression* logical_and55;
    #undef	RETURN_TYPE_logical_and55
    #define	RETURN_TYPE_logical_and55 const hammer::ast::expression*

    /* Initialize rule variables
     */


    feature53 = NULL;
    logical_or54 = NULL;
    logical_and55 = NULL;

    {
        {
            //  hammer_sema_v2.gt:162:2: ( feature | logical_or | logical_and )
            
            ANTLR3_UINT32 alt25;

            alt25=3;

            switch ( LA(1) ) 
            {
            case Feature:
            	{
            		alt25=1;
            	}
                break;
            case LogicalOr:
            	{
            		alt25=2;
            	}
                break;
            case LogicalAnd:
            	{
            		alt25=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;


                goto rulecondition_conditionEx;
            }

            switch (alt25) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:162:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_condition_condition919);
        	        feature53=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = feature53; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:163:4: logical_or
        	    {
        	        FOLLOWPUSH(FOLLOW_logical_or_in_condition_condition926);
        	        logical_or54=logical_or(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = logical_or54; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:164:4: logical_and
        	    {
        	        FOLLOWPUSH(FOLLOW_logical_and_in_condition_condition933);
        	        logical_and55=logical_and(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_conditionEx;
        	        }

        	        {
        	             result = logical_and55; 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecondition_conditionEx; /* Prevent compiler warnings */
    rulecondition_conditionEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition_condition */

/** 
 * $ANTLR start condition_result
 * hammer_sema_v2.gt:166:1: condition_result returns [const hammer::ast::expression* result] : ( public_expression | feature | list_of[&elements] );
 */
static const hammer::ast::expression*
condition_result(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* public_expression56;
    #undef	RETURN_TYPE_public_expression56
    #define	RETURN_TYPE_public_expression56 const hammer::ast::expression*

    const hammer::ast::feature* feature57;
    #undef	RETURN_TYPE_feature57
    #define	RETURN_TYPE_feature57 const hammer::ast::feature*

    /* Initialize rule variables
     */


     DECLARE_TYPE(hammer::ast::expressions_t, elements); 
    public_expression56 = NULL;
    feature57 = NULL;

    {
        {
            //  hammer_sema_v2.gt:168:2: ( public_expression | feature | list_of[&elements] )
            
            ANTLR3_UINT32 alt26;

            alt26=3;

            switch ( LA(1) ) 
            {
            case PublicTag:
            	{
            		alt26=1;
            	}
                break;
            case Feature:
            	{
            		alt26=2;
            	}
                break;
            case List:
            	{
            		alt26=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto rulecondition_resultEx;
            }

            switch (alt26) 
            {
        	case 1:
        	    // hammer_sema_v2.gt:168:4: public_expression
        	    {
        	        FOLLOWPUSH(FOLLOW_public_expression_in_condition_result953);
        	        public_expression56=public_expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = public_expression56; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // hammer_sema_v2.gt:169:4: feature
        	    {
        	        FOLLOWPUSH(FOLLOW_feature_in_condition_result961);
        	        feature57=feature(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = feature57; 
        	        }

        	    }
        	    break;
        	case 3:
        	    // hammer_sema_v2.gt:170:4: list_of[&elements]
        	    {
        	        FOLLOWPUSH(FOLLOW_list_of_in_condition_result968);
        	        list_of(ctx, &elements);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecondition_resultEx;
        	        }

        	        {
        	             result = SEMA->on_list_of(elements); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecondition_resultEx; /* Prevent compiler warnings */
    rulecondition_resultEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end condition_result */

/** 
 * $ANTLR start logical_or
 * hammer_sema_v2.gt:172:1: logical_or returns [const hammer::ast::expression* result] : ^( LogicalOr left= condition_condition right= condition_condition ) ;
 */
static const hammer::ast::expression*
logical_or(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* left;
    #undef	RETURN_TYPE_left
    #define	RETURN_TYPE_left const hammer::ast::expression*

    const hammer::ast::expression* right;
    #undef	RETURN_TYPE_right
    #define	RETURN_TYPE_right const hammer::ast::expression*

    /* Initialize rule variables
     */


    left = NULL;
    right = NULL;

    {
        // hammer_sema_v2.gt:173:2: ( ^( LogicalOr left= condition_condition right= condition_condition ) )
        // hammer_sema_v2.gt:173:4: ^( LogicalOr left= condition_condition right= condition_condition )
        {
             MATCHT(LogicalOr, &FOLLOW_LogicalOr_in_logical_or986); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_or990);
            left=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_or994);
            right=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_orEx;
            }

            {
                 result = SEMA->on_logical_or(left, right); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelogical_orEx; /* Prevent compiler warnings */
    rulelogical_orEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end logical_or */

/** 
 * $ANTLR start logical_and
 * hammer_sema_v2.gt:175:1: logical_and returns [const hammer::ast::expression* result] : ^( LogicalAnd left= condition_condition right= condition_condition ) ;
 */
static const hammer::ast::expression*
logical_and(phammer_sema_v2 ctx)
{   
    const hammer::ast::expression* result = NULL;

    const hammer::ast::expression* left;
    #undef	RETURN_TYPE_left
    #define	RETURN_TYPE_left const hammer::ast::expression*

    const hammer::ast::expression* right;
    #undef	RETURN_TYPE_right
    #define	RETURN_TYPE_right const hammer::ast::expression*

    /* Initialize rule variables
     */


    left = NULL;
    right = NULL;

    {
        // hammer_sema_v2.gt:176:2: ( ^( LogicalAnd left= condition_condition right= condition_condition ) )
        // hammer_sema_v2.gt:176:4: ^( LogicalAnd left= condition_condition right= condition_condition )
        {
             MATCHT(LogicalAnd, &FOLLOW_LogicalAnd_in_logical_and1012); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_and1016);
            left=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            FOLLOWPUSH(FOLLOW_condition_condition_in_logical_and1020);
            right=condition_condition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulelogical_andEx;
            }

            {
                 result = SEMA->on_logical_and(left, right); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelogical_andEx; /* Prevent compiler warnings */
    rulelogical_andEx: ;

    if (HASEXCEPTION())
    {
        PREPORTERROR();
        PRECOVER();
    }

    return result;
}
/* $ANTLR end logical_and */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
