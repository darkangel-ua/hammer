tree grammar hammer_sema;

options { 
        language = C; 
        tokenVocab = hammer;
        ASTLabelType = pANTLR3_BASE_TREE;
}

@header {

#include <hammer/sema/actions.h>
#include <hammer/parscore/identifier.h>
#include <hammer/ast/requirement_set.h>
#include <hammer/ast/requirement.h>
#include <hammer/ast/path_like_seq.h>
#include <hammer/ast/feature.h>

#define SEMA static_cast<const hammer::sema::actions*>(PARSER->super)
#define DECLARE_TYPE(Type, name) Type name ( Type ::allocator_type{SEMA->get_context()});
}

hamfile returns [const hammer::ast::hamfile* result]
@init { DECLARE_TYPE(hammer::ast::statements_t, statements); }
	: ^(Hamfile statement[&statements]*) { result = SEMA->on_hamfile(statements); }
        ;
        
statement[hammer::ast::statements_t* statements]
	: target_def_or_rule_call { statements->push_back($target_def_or_rule_call.result); }
	;

target_def_or_rule_call returns[const hammer::ast::expression* result] 
@init { DECLARE_TYPE(hammer::ast::expressions_t, args); }
	: ^(Rule name=Id arguments[&args]) { result = SEMA->on_target_or_rule_call($name->getToken($name), args); }
	; 

arguments[hammer::ast::expressions_t* args]
	: ^(Arguments (argument { args->push_back($argument.result); })* )
        ;

argument returns[const hammer::ast::expression* result]
	: EmptyArgument { result = SEMA->on_empty_expr($EmptyArgument->getToken($EmptyArgument)); }
	| expression { result = $expression.result; }
	| named_expression { result = $named_expression.result; }
	;

named_expression returns[const hammer::ast::expression* result]
	: ^(NamedArgument Id expression { result = SEMA->on_named_expr($Id->getToken($Id), $expression.result); } )
	;	
	
expression returns[const hammer::ast::expression* result]
@init { DECLARE_TYPE(hammer::ast::expressions_t, args); }
	: list_of[&args] { result = SEMA->on_list_of(args); }
        | target { result = $target.result; }
//        | public_expression
//        | expression_a
	| rule_invocation { result = $rule_invocation.result; }
	| feature { result = $feature.result; }
	| ^(PublicTag feature) { result = SEMA->on_public_expr($PublicTag->getToken($PublicTag), $feature.result); }
	| target_def_or_rule_call { result = $target_def_or_rule_call.result; }
	| path { result = $path.result; }
	| Id { result = SEMA->on_id($Id->getToken($Id)); }
	;
//public_expression returns[const hammer::ast::expression* result]
//	: ^(public_tag expression_a) { result = SEMA->on_public_expression($public_tag.result, $expression_a.result); } 
//	;
	
expression_a returns[const hammer::ast::expression* result]
//	: feature
//	| conditional_feature
: ;
	
list_of[hammer::ast::expressions_t* args]
	: ^(List (list_element { args->push_back($list_element.result); })+ )
	;           
list_element returns[const hammer::ast::expression* result]
	: target { result = $target.result; }
//	| public_expression
//	| expression_a
	  rule_invocation { result = $rule_invocation.result; }
	| path { result = $path.result; }
	| feature { result = $feature.result; }
	| ^(PublicTag feature) { result = SEMA->on_public_expr($PublicTag->getToken($PublicTag), $feature.result); }
	| Id { result = SEMA->on_id($Id->getToken($Id)); }
	;

path returns[const hammer::ast::path_like_seq* result]
@init { DECLARE_TYPE(hammer::ast::expressions_t, elements); 
        hammer::parscore::source_location root; }
	: ^(Path path_impl[&root, &elements]) { result = SEMA->on_path_like_seq(root, elements); }
	;	

path_impl[hammer::parscore::source_location* root, hammer::ast::expressions_t* elements]
	: Slash { *root = $Slash->getToken($Slash); } (path_element { elements->push_back($path_element.result); })+
	| (path_element { elements->push_back($path_element.result); })+
	;

path_element returns[const hammer::ast::expression* result]
	: Id { result = SEMA->on_id($Id->getToken($Id)); }
	| wildcard { result = $wildcard.result; }
	;

wildcard returns[const hammer::ast::expression* result]
@init { DECLARE_TYPE(hammer::ast::expressions_t, elements); }
	: ^(Wildcard (wildcard_elem { elements.push_back($wildcard_elem.result); })+ { result = SEMA->on_list_of(elements); } )
	;

wildcard_elem returns[const hammer::ast::expression* result]
	: Id { result = SEMA->on_id($Id->getToken($Id)); }
	| QuestionMark { result = SEMA->on_id($QuestionMark->getToken($QuestionMark)); }
	| Asterix { result = SEMA->on_id($Asterix->getToken($Asterix)); }
	;

public_tag[hammer::parscore::source_location* tag_loc] 
	: PublicTag { *tag_loc = hammer::parscore::source_location($PublicTag->getToken($PublicTag)); } 
	;

rule_invocation returns[const hammer::ast::expression* result]
@init { DECLARE_TYPE(hammer::ast::expressions_t, args); }
	: ^(RuleInvocation name=Id arguments[&args]) { result = SEMA->on_target_or_rule_call($name->getToken($name), args); }
	;

feature returns[const hammer::ast::feature* result]
	: ^(Feature Id feature_value) { result = SEMA->on_feature($Id->getToken($Id), $feature_value.result); }
	;
	
feature_value returns[const hammer::ast::expression* result]
	: Id { result = SEMA->on_id($Id->getToken($Id)); }
	| path { result = $path.result; }
	| target { result = $target.result; }
	;
target returns[const hammer::ast::expression* result]
@init { DECLARE_TYPE(hammer::ast::features_t, build_request); 
        hammer::parscore::identifier target_name; }
	: ^(PublicTag target_impl[&target_name, &build_request]) { result = SEMA->on_target_ref($PublicTag->getToken($PublicTag), $target_impl.result, target_name, build_request); }
	| target_impl[&target_name, &build_request] { result = SEMA->on_target_ref(hammer::parscore::source_location(), $target_impl.result, target_name, build_request); }
	;

target_impl[hammer::parscore::identifier* target_name, 
	    hammer::ast::features_t* build_request]
returns[const hammer::ast::path_like_seq* result]
	: ^(Target path target_spec[target_name, build_request]?) { result = $path.result; }
	| ^(Target Id target_spec[target_name, build_request]?) { DECLARE_TYPE(hammer::ast::expressions_t, elements); elements.push_back(SEMA->on_id($Id->getToken($Id))); result = SEMA->on_path_like_seq({}, elements); }
	;
	
target_spec[hammer::parscore::identifier* target_name, 
	    hammer::ast::features_t* build_request]
	: ^(TargetSpec Id target_build_request[build_request]?) { *target_name = hammer::parscore::identifier($Id->getToken($Id)); }
	| ^(TargetSpec target_build_request[build_request])
	;	
target_build_request[hammer::ast::features_t* build_request]
	: ^(TargetBuildRequest (feature { build_request->push_back($feature.result); })+)
	;	
	